/*****************************************************************************
 *
 * (C) Copyright 1998 by National Advanced Driving Simulator and
 * Simulation Center, the University of Iowa and The University
 * of Iowa. All rights reserved.
 *
 * Version:      $Id: codegen.c,v 1.65 2018/07/16 14:22:33 IOWA\dheitbri Exp $
 *
 * Author:       Yiannis Papelis, Omar Ahmad, Ben Wehrle
 * Date:         November, 1995
 *
 * Description:  
 *  Routines that generate the C source code to support the hcsm types
 *  specified in a THcsmParserInfo structure.
 *
 *  The code generates the following files: 
 *
 *  SM_TYPE_FILE:   a C file that contains a static definition
 *      of an smStateMachType array with all the templates for the hcsms
 *  SM_HEADER_FILE: a C header file that contains definitions for all
 *      necessary enumerated types, type unions, and array lengths
 *  SM_FUNCS_FILE:  a C file that contains all the activity routines,
 *      create and delete callbacks, predicate functions, and appropriate
 *      entry functions.
 ****************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <setjmp.h>

#include "parser.h"

static THcsmParserInfo* m_pIn;

static  char *m_pHeaderPreamble1 = 
"/*****************************************************************************\n"
" *\n"
" *  (C) Copyright 1998 by National Advanced Driving Simulator and\n" 
" *  Simulation Center, the University of Iowa and The University\n"
" *  of Iowa. All rights reserved.\n"
" *\n"
" *  This file has been generated by the hcsm code generator.\n"
" *  ### DO NOT EDIT DIRECTLY ###\n"
" *\n"
" */\n"
"\n"
"\n"
;


/******************************************************************************
 *
 * Description: Returns the snoparser class name associated with an HCSM
 *   template name.
 *
 * Remarks:  This function accepts an HCSM template name and then returns 
 *   the name of the snoparser class associated with it.
 *
 * Inputs:
 *   hcsmName -- Name of the HCSM template.
 *
 * Returns:  A char pointer to the snoparser class name.  The pointer is
 *    NULL for unknown HCSM template names.
 *
 */
static char* GetSnoParserClassFromHcsmName( char* hcsmName )
{

	if ( ( !strcmp( hcsmName, "Ado" ) )        ||
		 ( !strcmp( hcsmName, "Autonomous" ) ) ||
		 ( !strcmp( hcsmName, "FreeDrive" ) )  ||
		 ( !strcmp( hcsmName, "Follow" ) )  ||
		 ( !strcmp( hcsmName, "LaneChange" ) )  ||
		 ( !strcmp( hcsmName, "LcMonitor" ) )  ||
		 ( !strcmp( hcsmName, "LcSignal" ) )  ||
		 ( !strcmp( hcsmName, "LcExecute" ) )  ||
		 ( !strcmp( hcsmName, "LcAbort" ) )  ||
		 ( !strcmp( hcsmName, "NavigateIntrsctn" ) )  ||
		 ( !strcmp( hcsmName, "RemoteControl" ) )
		 ) {

		return "CAdoParseBlock";

	}
	else if ( !strcmp( hcsmName, "Ddo" ) ) {

		return "CDdoParseBlock";

	}
	else if ( !strcmp( hcsmName, "EnvironmentController" ) ) {

		return "CEnvControlParseBlock";

	}
	else if ( !strcmp( hcsmName, "Gateway" ) ) {

		return "CGatewayParseBlock";

	}
	else if ( !strcmp( hcsmName, "IntersectionManager" ) ) {

		return "CIntersectionMngrParseBlock";

	}
	else if ( !strcmp( hcsmName, "OwnVehicleMirror" ) ) {

		return "COwnVehicleMirrorParseBlock";

	}
	else if ( !strcmp( hcsmName, "StaticObjManager" ) ) {

		return "CSobjMngrParseBlock";

	}
	else if ( !strcmp( hcsmName, "TestPriv" ) ) {

		return "CTrajFollowParseBlock";

	}
	else if ( !strcmp( hcsmName, "TrafficData" ) ) {

		return "CTrafficDataParseBlock";

	}
	else if ( !strcmp( hcsmName, "DaqDriver" ) ) {

		return "CDaqDriverParseBlock";

	}
	else if ( ( !strcmp( hcsmName, "TimeTrigger" ) ) ||
			  ( !strcmp( hcsmName, "RoadPadTrigger" ) ) ||
			  ( !strcmp( hcsmName, "ExpressionTrigger" ) ) ||
			  ( !strcmp( hcsmName, "FollowTrigger" ) ) ||
			  ( !strcmp( hcsmName, "TrffcLghtTrigger" ) ) ||
			  ( !strcmp( hcsmName, "TimeToArrvlTrigger" ) ) ||
			  ( !strcmp( hcsmName, "GmtrcPstnTrigger" ) )
			  ) {

		return "CTriggerParseBlock";

	}
	else if ( !strcmp( hcsmName, "CLG" ) ) {

		return "CClgParseBlock";

	}
	else if ( !strcmp( hcsmName, "EnviroInfo" ) ) {

		return "CEnviroInfoParseBlock";

	}
	else if ( !strcmp( hcsmName, "TrafficLightManager" ) ) {

		return "CTrafLghtMngrParseBlock";

	}
	else if ( !strcmp( hcsmName, "TrafficManager" ) ) {

		return "CTrafMngrParseBlock";

	}
	else if ( !strcmp( hcsmName, "TrafficSource" ) ) {

		return "CTrafSrcParseBlock";

	}
	else if ( !strcmp( hcsmName, "VehFail" ) ) {

		return "CVehFailParseBlock";

	}
	else if ( !strcmp( hcsmName, "VirtualObject" ) ) {

		return "CVirtualObjectParseBlock";

	}
	else {

		return NULL;

	}

}
 
 
/******************************************************************************
 *
 * Name:  GenTemplateToClassFunction
 *
 * Generates the function that creates a new class given a HCSM 
 * template name.
 *
 * Inputs:
 *   pFile -- Pointer to the file to write data to.
 *
 */
static void GenTemplateToClassFunction( FILE* pFile  )
{

	static char*   pSnoBlockClassName = "CSnoBlock";
	static char*   pSnoBlockVarName = "snoBlock";
	static char*   pTab = "    ";   /* simulates a tab character            */

	TStateMachine* pSm;             /* pointer to SM on SM list             */

	fprintf( pFile, "#include \"%s\"\n", SM_CLASS_HEADER_FILE );
	fprintf( pFile, "#include \"hcsmcollection.h\"\n" );
	fprintf( pFile, "\n" );

	/*
	 * Generate the inline function.
	 */
	fprintf( pFile, "CHcsm* CHcsmCollection::" );
	fprintf( pFile, "GetClassFromTemplateName(\n" );
	fprintf( pFile, "%s%s%sstring templateName,\n", pTab, pTab, pTab );
	fprintf( pFile, "%s%s%sconst %s& %s\n", pTab, pTab, pTab, 
			 pSnoBlockClassName, pSnoBlockVarName );
	fprintf( pFile, "%s%s%s)\n", pTab, pTab, pTab );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "%sCHcsm* pHcsm;\n", pTab );
	fprintf( pFile, "\n" );

	for ( pSm = m_pIn->sm_list; pSm; pSm = pSm->next ) {

		char* pSnoParserClassName = GetSnoParserClassFromHcsmName( pSm->name );

		fprintf( pFile, "%sif ( templateName == \"%s\" ) {\n", 
						 pTab, pSm->name );
		fprintf( pFile, "\n" );
		fprintf( pFile, "%s%s// EXIT: found class for template\n", pTab, pTab );
		if ( pSnoParserClassName ) {
			fprintf( pFile, "%s%spHcsm = new C%s( this, %s );\n", 
					 pTab, pTab, pSm->name, pSnoBlockVarName );
		}
		else{
			fprintf( pFile, "%s%spHcsm = new C%s( this );\n", 
					 pTab, pTab, pSm->name );
		}
		fprintf( pFile, "%s%sreturn pHcsm;\n", pTab, pTab );
		fprintf( pFile, "\n" );
		fprintf( pFile, "%s}\n", pTab );

	}

	fprintf( pFile, "\n" );
	fprintf( pFile, "%sreturn NULL;", pTab );
	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );

}


/******************************************************************************
 *
 * Description:  Generates the C++ header file for classes derived from
 *   CInputParameter.
 *
 * Remarks:  This function generates the C++ declaration for classes that are
 *   derived from CInputParameter.  A new class should be derived for each
 *   type of input parameter specified in the input file to the parser.
 *
 * Inputs:
 *   pFile      - Pointer to the file to write data to.
 *   pClassType - Type of class to derived from CInputParameter.
 *   pBaseClassName - Pointer to the name of the base class.
 *   pClassNamePrefix - Pointer to the class name's prefix.
 *
 * Returns:
 *
 */
static void GenStorageDerivedClassHeader(
			FILE* pFile, 
			const char* pClassType,
			const char* pBaseClassName,
			const char* pClassNamePrefix
			)
{

	static char*   pTab             = "    ";
	static char*   pValueVarName    = "m_value";

	char           className[128];  /* the derived class' name              */


	/* join the class name prefix with the type to make the name of the new
	 * derived class
	 */
	sprintf( className, "%s%s", pClassNamePrefix, pClassType );

	/*
	 * Generate header.
	 */
	fprintf( pFile, "////////////////////////////////" );
	fprintf( pFile, "//////////////////////////////\n" );
	fprintf( pFile, "// %s\n", className );
	fprintf( pFile, "////////////////////////////////" );
	fprintf( pFile, "//////////////////////////////\n" );
	fprintf( pFile, "\n" );
	
	/* 
	 * Print the class declaration.
	 */
	fprintf( pFile, "class %s : public %s\n", className, pBaseClassName );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "public:\n" );
	
	/* default constructor */
	fprintf( pFile, "%s%s( string );\n", pTab, className );

	/* copy constructor */
	fprintf( pFile, "%s%s( const %s& );\n", pTab, className, className );

	/* assignment operator */
	fprintf( pFile, "%s%s& operator=( const %s& );\n", 
			 pTab, className, className );

	/* destructor */
	fprintf( pFile, "%svirtual ~%s(); \n", pTab, className );

	/* get value function */
	fprintf( pFile, "%s%s GetValue();\n", pTab, pClassType );

	/* set value function */
	fprintf( pFile, "%svoid SetValue( %s );\n", pTab, pClassType );

	fprintf( pFile, "\n" );
	fprintf( pFile, "private:\n" );

	/* the private member that holds the value */
	fprintf( pFile, "%s%s  %s ;\n", pTab, pClassType, pValueVarName );

	fprintf( pFile, "};\n" );
	fprintf( pFile, "\n" );

}


/******************************************************************************
 *
 * Description:  Generates the C++ header file for classes derived from
 *   CInputParameter.
 *
 * Remarks:  This function generates the C++ implementation for classes
 *   that are derived from CInputParameter.  A new class should be derived 
 *   for each type of input parameter specified in the input file to the 
 *   parser.
 *
 * Inputs:
 *   pFile      - Pointer to the file to write data to.
 *   pClassType - Type of class to derived from CInputParameter.
 *   pBaseClassName - Pointer to the name of the base class.
 *   pClassNamePrefix - Pointer to the class name's prefix.
 *
 * Returns:
 *
 */
static void GenStorageDerivedClassImplementation( 
			FILE* pFile, 
			const char* pClassType,
			const char* pBaseClassName,
			const char* pClassNamePrefix
			)
{

	static char*   pObjToCopy       = "objToCopy";
	static char*   pTab             = "    ";
	static char*   pValueVarName    = "m_value";

	char           className[128];  /* the derived class' name              */


	/* join the class name prefix with the type to make the name of the new
	 * derived class
	 */
	sprintf( className, "%s%s", pClassNamePrefix, pClassType );

	/*
	 * Generate header.
	 */
	fprintf( pFile, "////////////////////////////////" );
	fprintf( pFile, "//////////////////////////////\n" );
	fprintf( pFile, "// %s\n", className );
	fprintf( pFile, "////////////////////////////////" );
	fprintf( pFile, "//////////////////////////////\n" );
	fprintf( pFile, "\n" );
	
	/* 
	 * Generate the default constructor.
	 */
	fprintf( pFile, "%s::%s( string name ):\n", className, className );
	fprintf( pFile, "%s%s( name )\n", pTab, pBaseClassName );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/* 
	 * Generate the copy constructor.
	 */
	fprintf( pFile, "%s::%s( const %s& %s ):\n", className, className, 
			 className, pObjToCopy );
	fprintf( pFile, "%s%s( %s.m_name )\n", pTab, pBaseClassName, pObjToCopy );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\n" );

	fprintf( pFile, "%s// call the assignment operator\n", pTab );
	fprintf( pFile, "%s*this = %s;\n", pTab, pObjToCopy );

	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/*
	 * Generate the assignment operator.
	 */
	fprintf( pFile, "%s& %s::operator=(\n", className, className );
	fprintf( pFile, "%s%s%sconst %s& %s\n", pTab, pTab, pTab, className,
			 pObjToCopy );
	fprintf( pFile, "%s%s%s)\n", pTab, pTab, pTab );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\n" );

	fprintf( pFile, "%s// check to see if the object passed in is really me\n",
			 pTab );
	fprintf( pFile, "%sif ( this != &%s ) {\n", pTab, pObjToCopy );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%s%s// make a deep copy\n", pTab, pTab );
	fprintf( pFile, "%s%s%s = %s.m_value;\n", pTab, pTab, pValueVarName, 
			 pObjToCopy );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%s}\n", pTab );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%sreturn *this;\n", pTab );

	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/* 
	 * Generate the destructor.
	 */
	fprintf( pFile, "%s::~%s()\n", className, className );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/*
	 * Generate the GetValue function.
	 */
	fprintf( pFile, "%s %s::GetValue()\n", pClassType, className );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\n" );

	fprintf( pFile, "%s// check to see if the input parameter has a value\n", 
			 pTab );
	fprintf( pFile, "%sif ( !m_hasValue ) {\n", pTab );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%s%scout << MyName() << ", pTab, pTab );
	fprintf( pFile, "\"::GetValue:  input parameter has no value!\";\n" );
	fprintf( pFile, "%s%scout << endl;\n", pTab, pTab );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%s}\n", pTab );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%sreturn %s;\n", pTab, pValueVarName );

	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/*
	 * Generate the SetValue function.
	 */
	fprintf( pFile, "void %s::SetValue( %s value )\n", className, pClassType );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\n" );

	fprintf( pFile, "%s// set the input parameter's value\n", pTab );
	fprintf( pFile, "%s%s = value;\n", pTab, pValueVarName );
	fprintf( pFile, "%sm_hasValue = true;\n", pTab );

	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

}


/******************************************************************************
 *
 * Description:  Generates the C++ header and implementation files for 
 *   classes derived from CHcsmStorage.
 *
 * Remarks:  This function generates the C++ header and implmentation
 *   files for classes that are derived from CHcsmStorage.  It generates
 *   a class for each type of input parameter, local variable and output 
 *   parameter specified in the input file to the parser.
 *
 * Inputs:
 *   pHeaderFile    - Pointer to the header file to write data to.
 *   pImplementFile - Pointer to the implementation file to write data to.
 *
 * Returns:
 *
 */
static void GenStorageClasses( FILE* pHeaderFile, FILE* pImplementFile )
{

	char           modifiedHeaderName[256]; /* holds header name            */
	char*          pC;              /* pointer to character                 */
	TStateMachine* pSm;             /* pointer to SM on SM list             */
	TStringPair*   pNode;           /* pointer to element in a str pair list*/
	TStringPair*   pInput;          /* pointer to input parameter in a SM   */
	TStringPair*   pLocal;          /* pointer to local variable in a SM    */
	TStringPair*   pOutput;         /* pointer to output parameter in a SM  */
	TStringPair*   pUniqueInputType; /* a list of unique types for inputs   */
	TStringPair*   pUniqueLocalType; /* a list of unique types for inputs   */
	TStringPair*   pUniqueOutputType; /* a list of unique types for inputs  */

	/*
	 * Print the preamble.
	 */
	fprintf( pHeaderFile, m_pHeaderPreamble1 );
	fprintf( pImplementFile, m_pHeaderPreamble1 );

	/*
	 * Put #ifndef around the header file to protect from multiple
	 * inclusions.  use _ for any non alphanumeric characters.
	 */
	strcpy( modifiedHeaderName, SM_STORAGE_HEADER_FILE );
	pC = modifiedHeaderName;
	while ( *pC ) {

		if ( ! isalnum( *pC ) )  *pC = '_';
		pC++;

	}
	fprintf( pHeaderFile, "#ifndef __%s_INCLUDED_\n", modifiedHeaderName );
	fprintf( pHeaderFile, "#define __%s_INCLUDED_\n\n", modifiedHeaderName );

	/* 
	 * Include the global header file.
	 */
	fprintf( pHeaderFile, "#include \"%s\"\n", SM_GLOBAL_HEADER_FILE );

	/*
	 * Print the include for the header file.
	 */
	fprintf( pImplementFile, "#include \"%s\"\n", SM_STORAGE_HEADER_FILE );
	fprintf( pImplementFile, "#include <genericinclude.h>\n" );
	fprintf( pImplementFile, "\n" );

	/*
	 * Build a unique list of input parameter types needed from all
	 * of the input parameters specified in all the state machines.
	 */
	pUniqueInputType = NULL;
	for ( pSm = m_pIn->sm_list; pSm; pSm = pSm->next ) {

		for ( pInput = pSm->inputs; pInput; pInput = pInput->pNext ) {

			TStringPair* pUniqueTypeLocator;

			/* find the input parameter type on the unique type list */
			pUniqueTypeLocator = LookupStrPair( pUniqueInputType, pInput->pValue );

			if ( !pUniqueTypeLocator ) {

				/*
				 * input parameter type not found on unique list so
				 * insert it
				 */
				char         inputName[256];
				char         inputType[256];
				TStringPair* pNew;

				pNew = NewStrPair();
				strcpy( inputType, pInput->pValue );   /* value holds type name */
				sprintf( inputName, "%s_input", pInput->pValue );
				pNew->pName = safe_strdup( inputType );
				AppendStrPairToLinkList( &pUniqueInputType, pNew );

			}

		}

	}

	/*
	 * Build a unique list of local variable types needed from all
	 * of the local variables specified in all the state machines.
	 */
	pUniqueLocalType = NULL;
	for ( pSm = m_pIn->sm_list; pSm; pSm = pSm->next ) {

		for ( pLocal = pSm->locals; pLocal; pLocal = pLocal->pNext ) {

			TStringPair* pUniqueTypeLocator;

			/* find the local variable type on the unique type list */
			pUniqueTypeLocator = LookupStrPair( pUniqueLocalType, pLocal->pValue );

			if ( !pUniqueTypeLocator ) {

				/* local variable type not found on unique list so insert it */
				char         localName[256];
				char         localType[256];
				TStringPair* pNew;

				pNew = NewStrPair();
				strcpy( localType, pLocal->pValue );   /* value holds type name */
				sprintf( localName, "%s_input", pLocal->pValue );
				pNew->pName = safe_strdup( localType );
				AppendStrPairToLinkList( &pUniqueLocalType, pNew );

			}

		}

	}

	/*
	 * Build a unique list of output parameter types needed from all
	 * of the output parameters specified in all the state machines.
	 */
	pUniqueOutputType = NULL;
	for ( pSm = m_pIn->sm_list; pSm; pSm = pSm->next ) {

		for ( pOutput = pSm->outputs; pOutput; pOutput = pOutput->pNext ) {

			TStringPair* pUniqueTypeLocator;

			/* find the output parameter type on the unique type list */
			pUniqueTypeLocator = LookupStrPair( pUniqueOutputType, pOutput->pValue );

			if ( !pUniqueTypeLocator ) {

				/* output parameter type not found on unique list so insert it */
				char         outputName[256];
				char         outputType[256];
				TStringPair* pNew;

				pNew = NewStrPair();
				strcpy( outputType, pOutput->pValue );   /* value holds type name */
				sprintf( outputName, "%s_input", pOutput->pValue );
				pNew->pName = safe_strdup( outputType );
				AppendStrPairToLinkList( &pUniqueOutputType, pNew );

			}

		}

	}

	/*
	 * Put in an include statement to for input parameter, local variable
	 * and output parameter base classes if needed in the header file.
	 */
	if ( pUniqueInputType ) {

		fprintf( pHeaderFile, "#include \"inputparameter.h\"\n" );

	}
	if ( pUniqueLocalType ) {

		fprintf( pHeaderFile, "#include \"localvariable.h\"\n" );

	}
	if ( pUniqueOutputType ) {

		fprintf( pHeaderFile, "#include \"outputparameter.h\"\n" );

	}

	/* include standard library stuff in the header file */
	fprintf( pHeaderFile, "#include <string>\n" );
	fprintf( pHeaderFile, "using namespace std;\n" );
	fprintf( pHeaderFile, "\n" );

	/* 
	 * Generate the headers and implementations for classes needed to
	 * represent input parameters.
	 */
	for ( pNode = pUniqueInputType; pNode; pNode = pNode->pNext ) {

		/* generate class declarations for input parameters */
		GenStorageDerivedClassHeader( pHeaderFile, pNode->pName, 
									  "CInputParameter", "CInputPar" );

		/* generate class implementations for input parameters */
		GenStorageDerivedClassImplementation( pImplementFile, pNode->pName, 
											  "CInputParameter", "CInputPar" );

	}

	/* 
	 * Generate the headers and implementations for classes needed to
	 * represent local variables.
	 */
	for ( pNode = pUniqueLocalType; pNode; pNode = pNode->pNext ) {

		/* generate class declarations for local variables */
		GenStorageDerivedClassHeader( pHeaderFile, pNode->pName, 
									  "CLocalVariable", "CLocalVar" );

		/* generate class implementations for local variables */
		GenStorageDerivedClassImplementation( pImplementFile, pNode->pName, 
											  "CLocalVariable", "CLocalVar" );

	}

	/* 
	 * Generate the headers and implementations for classes needed to
	 * represent output parameters.
	 */
	for ( pNode = pUniqueOutputType; pNode; pNode = pNode->pNext ) {

		/* generate class declarations for output parameters */
		GenStorageDerivedClassHeader( pHeaderFile, pNode->pName, 
									  "COutputParameter", "COutputPar" );

		/* generate class implementations for output parameters */
		GenStorageDerivedClassImplementation( pImplementFile, pNode->pName, 
											  "COutputParameter", "COutputPar" );

	}

	/*
	 * End the multiple file inclusion protection for the header file.
	 */
	fprintf( pHeaderFile, "\n\n#endif\n" );

}


/******************************************************************************
 *
 * Description:  Generates the C++ header file for classes derived from CDial.
 *
 * Remarks:  This function generates the C++ declaration for classes that are
 *   derived from CDial.  A new class should be derived for each
 *   type of dial specified in the input file to the parser.
 *
 * Inputs:
 *   pFile            - Pointer to the file to write data to.
 *   pClassType       - Type of class to derived from CDial.
 *   pBaseClassName   - Pointer to the name of the base class.
 *   pClassNamePrefix - Pointer to the class name's prefix.
 *
 * Returns:
 *
 */
static void GenCommunicationDerivedClassHeader(
			FILE* pFile, 
			const char* pClassType,
			const char* pBaseClassName,
			const char* pClassNamePrefix
			)
{

	static char*   pPrevValueVarName = "m_prevValue";
	static char*   pTab              = "    ";

	char           className[128];  /* the derived class' name              */


	/* join the class name prefix with the type to make the name of the new
	 * derived class
	 */
	sprintf( className, "%s%s", pClassNamePrefix, pClassType );

	/*
	 * Generate header.
	 */
	fprintf( pFile, "////////////////////////////////" );
	fprintf( pFile, "//////////////////////////////\n" );
	fprintf( pFile, "// %s\n", className );
	fprintf( pFile, "////////////////////////////////" );
	fprintf( pFile, "//////////////////////////////\n" );
	fprintf( pFile, "\n" );
	
	/* 
	 * Print the class declaration.
	 */
	fprintf( pFile, "class %s : public %s\n", className, pBaseClassName );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "public:\n" );
	
	/* default constructor */
	fprintf( pFile, "%s%s( CHcsmCollection*, string );\n", pTab, className );

	/* copy constructor */
	fprintf( pFile, "%s%s( const %s& );\n", pTab, className, className );

	/* assignment operator */
	fprintf( pFile, "%s%s& operator=( const %s& );\n", 
			 pTab, className, className );

	/* destructor */
	fprintf( pFile, "%svirtual ~%s(); \n", pTab, className );

	/* get value function */
	fprintf( pFile, "%s%s GetValue();\n", pTab, pClassType );

	/* get value string function */
	fprintf( pFile, "%sstring GetValueStr();\n", pTab );

	/* set value function */
	fprintf( pFile, "%svoid SetValue( %s );\n", pTab, pClassType );

	/* set value string function */
	fprintf( pFile, "%svoid SetValueStr(const string &);\n", pTab );

	fprintf( pFile, "\n" );
	fprintf( pFile, "private:\n" );

	/* the private member that holds the value */
	fprintf( pFile, "%s%s %s;\n", pTab, pClassType, pPrevValueVarName );
	fprintf( pFile, "%s%s m_valueA;\n", pTab, pClassType );
	fprintf( pFile, "%s%s m_valueB;\n", pTab, pClassType );

	fprintf( pFile, "};\n" );
	fprintf( pFile, "\n" );

}


/******************************************************************************
 *
 * Description:  Generates the C++ header file for classes derived from CDial.
 *
 * Remarks:  This function generates the C++ implementation for classes
 *   that are derived from CDial.  A new class should be derived 
 *   for each type of dial specified in the input file to the parser.
 *
 * Inputs:
 *   pFile            - Pointer to the file to write data to.
 *   pClassType       - Type of class to derived from CDial.
 *   pBaseClassName   - Pointer to the name of the base class.
 *   pClassNamePrefix - Pointer to the class name's prefix.
 *
 * Returns:
 *
 */
static void GenCommunicationDerivedClassImpementation( 
			FILE* pFile, 
			const char* pClassType,
			const char* pCategory,
			const char* pBaseClassName,
			const char* pClassNamePrefix
			)
{

	static char*   pCollectionVarName = "pRootCollection";
	static char*   pObjToCopy        = "objToCopy";
	static char*   pTab              = "    ";

	char           className[128];  /* the derived class' name              */

	struct categoryInfo {
		char*	category;
		char*	defaultConstructor;
		char*	copyConstructor;
	} categoryInit[] = 
		{ 
			{ "CCvedItem",	
				",\n    m_value( *(pRootCollection->GetCved()) )",
				",\n    m_value( objToCopy.m_value )"},
			{ 0,	"", "" }
		};

	struct conversionInfo {
		char*	type;
		char*	stringToType;
		char*	typeToString;
	} conversion[] = 
		{ {	"int",
				" = atoi(value.c_str())", 
		  		"sprintf(&*strValue.begin(), \"%d\", curValue)" },
		  {	"long",
			  	" = atol(value.c_str())",
		  		"sprintf(&*strValue.begin(), \"%ld\", curValue)" },
		  {	"float",
			  	" = atof(value.c_str())",
		  		"sprintf(&*strValue.begin(), \"%f\", curValue)" },
		  {	"double",
			  	" = atof(value.c_str())",
		  		"sprintf(&*strValue.begin(), \"%lf\", curValue)" },
		  { "string",
			  	" = value",
		  		"strValue = curValue" },
		  {	"char",
			  	" = value[0]",
		  		"strValue = curValue" },
		  { "bool", 
				" = (value == \"true\")",
				"strValue = (curValue? \"true\" : \"false\")" },
		  {	0,
			  	".SetString(value)",
		  		"strValue = curValue.GetString()" }
		};
	int typeIdx;

	/* join the class name prefix with the type to make the name of the new
	 * derived class
	 */
	sprintf( className, "%s%s", pClassNamePrefix, pClassType );

	/*
	 * Generate header.
	 */
	fprintf( pFile, "////////////////////////////////" );
	fprintf( pFile, "//////////////////////////////\n" );
	fprintf( pFile, "// %s\n", className );
	fprintf( pFile, "////////////////////////////////" );
	fprintf( pFile, "//////////////////////////////\n" );
	fprintf( pFile, "\n" );
	
	/* 
	 * Generate the default constructor.
	 */
	fprintf( pFile, "%s::%s( ", className, className );
	fprintf( pFile, "CHcsmCollection* %s, ", pCollectionVarName );
	fprintf( pFile, "string name ):\n" );
	fprintf( pFile, "%s%s", pTab, pBaseClassName );
	fprintf( pFile, "( %s, name )", pCollectionVarName );

	if (pCategory) {
		/* Figure out which category initialization to use */
		typeIdx = 0;
		while ( categoryInit[typeIdx].category ) {
			if ( !strcmp(categoryInit[typeIdx].category, pCategory) )
				break;
			typeIdx++;
		}

		fprintf( pFile, "%s", categoryInit[typeIdx].defaultConstructor );
	}

	fprintf( pFile, "\n{\n" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/* 
	 * Generate the copy constructor.
	 */
	fprintf( 
		pFile, 
		"%s::%s( const %s& %s ):\n", 
		className, 
		className, 
		className, 
		pObjToCopy 
		);
	fprintf( 
		pFile, 
		"%s%s( %s.m_%s, %s.m_name )", 
		pTab, 
		pBaseClassName, 
		pObjToCopy, 
		pCollectionVarName, 
		pObjToCopy 
		);
	if( pCategory ) 
	{
		/* Use same cetegory as found in default constructor */
		fprintf( pFile, "%s", categoryInit[typeIdx].copyConstructor );
	}

	fprintf( pFile, "\n{\n" );
	fprintf( pFile, "\n" );

	fprintf( pFile, "%s// call the assignment operator\n", pTab );
	fprintf( pFile, "%s*this = %s;\n", pTab, pObjToCopy );

	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/*
	 * Generate the assignment operator.
	 */
	fprintf( pFile, "%s& %s::operator=(\n", className, className );
	fprintf( 
		pFile, 
		"%s%s%sconst %s& %s\n", 
		pTab, 
		pTab, 
		pTab, 
		className,
		pObjToCopy 
		);
	fprintf( pFile, "%s%s%s)\n", pTab, pTab, pTab );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\n" );

	fprintf( pFile, "%s// check to see if the object passed in is really me\n",
					 pTab );
	fprintf( pFile, "%sif ( this != &%s ) {\n", pTab, pObjToCopy );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%s%s// make a deep copy\n", pTab, pTab );
	fprintf( pFile, "%s%sm_valueA = %s.m_valueA;\n", pTab, pTab, pObjToCopy );
	fprintf( pFile, "%s%sm_valueB = %s.m_valueB;\n", pTab, pTab, pObjToCopy );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%s}\n", pTab );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%sreturn *this;\n", pTab );

	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/* 
	 * Generate the destructor.
	 */
	fprintf( pFile, "%s::~%s()\n", className, className );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/*
	 * Generate the GetValue function.
	 */
	fprintf( pFile, "%s %s::GetValue()\n", pClassType, className );
	fprintf( pFile, "{\n" );

	fprintf( pFile, "%sbool writtenThisFrame = m_setFrame == GetFrame();\n", pTab );
	fprintf( pFile, "%sif( writtenThisFrame )\n", pTab );
	fprintf( pFile, "%s{\n", pTab );
	fprintf( pFile, "%s%s// make sure that dial has a value\n", pTab, pTab );
	fprintf( pFile, "%s%sif( !m_hasValueB )\n", pTab, pTab );
	fprintf( pFile, "%s%s{\n", pTab, pTab );
	fprintf( 
		pFile, 
		"%s%s%scerr << MyName() << \"::GetValue: dial has no value\" << endl;\n",
		pTab,
		pTab,
		pTab
		);
	fprintf( pFile, "%s%s}\n", pTab, pTab );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%s%sreturn m_valueB;\n", pTab, pTab );
	fprintf( pFile, "%s}\n", pTab );
	fprintf( pFile, "%selse\n", pTab );
	fprintf( pFile, "%s{\n", pTab );
	fprintf( pFile, "%s%s// make sure that dial has a value\n", pTab, pTab );
	fprintf( pFile, "%s%sif( !m_hasValueA )\n", pTab, pTab );
	fprintf( pFile, "%s%s{\n", pTab, pTab );
	fprintf( 
		pFile, 
		"%s%s%scerr << MyName() << \"::GetValue: dial has no value\" << endl;\n",
		pTab,
		pTab,
		pTab
		);
	fprintf( pFile, "%s%s}\n", pTab, pTab );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%s%sreturn m_valueA;\n", pTab, pTab );
	fprintf( pFile, "%s}\n", pTab );

	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/*
	 * Generate the GetValueStr function.
	 */
	fprintf( pFile, "string %s::GetValueStr()\n", className );
	fprintf( pFile, "{\n" );

	fprintf( pFile, "%sstring strValue = \"\";\n", pTab );
	fprintf( pFile, "%s%s curValue;\n\n", pTab, pClassType );
	fprintf( pFile, "\n" );

	fprintf( pFile, "%sbool writtenThisFrame = m_setFrame == GetFrame();\n", pTab );
	fprintf( pFile, "%sif( writtenThisFrame )\n", pTab );
	fprintf( pFile, "%s{\n", pTab );
	fprintf( pFile, "%s%s// make sure that dial has a value\n", pTab, pTab );
	fprintf( pFile, "%s%sif( !m_hasValueB )\n", pTab, pTab );
	fprintf( pFile, "%s%s{\n", pTab, pTab );
	fprintf( 
		pFile, 
		"%s%s%scerr << MyName() << \"::GetValue: dial has no value\" << endl;\n",
		pTab,
		pTab,
		pTab
		);
	fprintf( pFile, "%s%s}\n", pTab, pTab );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%s%scurValue = m_valueB;\n", pTab, pTab );
	fprintf( pFile, "%s}\n", pTab );
	fprintf( pFile, "%selse\n", pTab );
	fprintf( pFile, "%s{\n", pTab );
	fprintf( pFile, "%s%s// make sure that dial has a value\n", pTab, pTab );
	fprintf( pFile, "%s%sif( !m_hasValueA )\n", pTab, pTab );
	fprintf( pFile, "%s%s{\n", pTab, pTab );
	fprintf( 
		pFile, 
		"%s%s%scerr << MyName() << \"::GetValue: dial has no value\" << endl;\n",
		pTab,
		pTab,
		pTab
		);
	fprintf( pFile, "%s%s}\n", pTab, pTab );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%s%scurValue = m_valueA;\n", pTab, pTab );
	fprintf( pFile, "%s}\n", pTab );
	fprintf( pFile, "%s\n", pTab );

	/* Figure out which conversion function to use */
	typeIdx = 0;
	while( conversion[typeIdx].type ) 
	{
		if( !strcmp(conversion[typeIdx].type, pClassType) )	break;
		typeIdx++;
	}
	fprintf( pFile, "%s%s;\n", pTab, conversion[typeIdx].typeToString );
	fprintf( pFile, "%sreturn strValue;\n", pTab );

	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );


	/*
	 * Generate the SetValue function.
	 */
	fprintf( pFile, "void %s::SetValue( %s value )\n", className, pClassType );
	fprintf( pFile, "{\n" );

	fprintf( pFile, "%sbool writtenThisFrame = m_setFrame == GetFrame();\n", pTab );
	fprintf( pFile, "%sif( !writtenThisFrame )\n", pTab );
	fprintf( pFile, "%s{\n", pTab );
	fprintf( pFile, "%s%sm_valueB = m_valueA;\n", pTab, pTab );
	fprintf( pFile, "%s%sm_valueA = value;\n", pTab, pTab );
	fprintf( pFile, "%s}\n", pTab );
	fprintf( pFile, "%s\n", pTab );
	fprintf( pFile, "%s%s::SetValue();\n", pTab, pBaseClassName );

	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/*
	 * Generate the SetValueStr function.
	 */
	fprintf( pFile, "void %s::SetValueStr( const string& value )\n", 
		className );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\n" );

	fprintf( pFile, "%sbool writtenThisFrame = m_setFrame == GetFrame();\n", pTab );
	fprintf( pFile, "%sif( !writtenThisFrame )\n", pTab );
	fprintf( pFile, "%s{\n", pTab );
	fprintf( pFile, "%s%sm_valueB = m_valueA;\n", pTab, pTab );
	fprintf( pFile, "%s%sm_valueA%s;\n", pTab, pTab, conversion[typeIdx].stringToType );
	fprintf( pFile, "%s}\n", pTab );
	fprintf( pFile, "%s\n", pTab );
	fprintf( pFile, "%s%s::SetValue();\n", pTab, pBaseClassName );

	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );	
}


/******************************************************************************
 *
 * Description: Generates the virtual Hcsm class member SetDialByName functions
 *	  for setting dials that are overridden by the Hcsm subclasses.
 *
 * Remarks:  For a given state machine, this function generates the CHcsm 
 *   mutator functions for all of that state machine's dial types.
 *
 * Arugments:
 *   pFile                -- Pointer to the file to write data to.
 *   pUniqueDialTypeList  -- Pointer to the list of unique dial types
 *
 * Returns:
 *
 */
static void 
GenHcsmDial( 
			FILE* pFile, 
			TStringPair* pUniqueDialTypeList 
			)
{

	static char* pTab = "    ";
	static char* pMutatorName = "SetDialByName"; 
	static char* pAccessorStrName = "IsDialActiveByNameStr";
	static char* pMutatorStrName = "SetDialByNameStr";
	static char* pResetMutatorName = "ResetDialByName";

	/*
	 * Print out a header and information about the functions
	 */
	fprintf(
		pFile, 
		"//////////////////////////////////////////////////////////////////\n"
		);
	fprintf( pFile, "//\n" );
	fprintf( 
		pFile, 
		"%s%s",
		"// Description: Virtual methods for dials overidden by CHcsm\n",
		"//  subclasses.\n"
		);
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Remarks: \n" );
	fprintf( 
		pFile, 
		"%s%s%s%s%s%s",
		"//  If the user uses the HCSM system properly, this function should\n",
		"//  never be called because a sub-class should reimplement this\n",
		"//  function if it has dials.  If this function gets called, then\n",
		"//  it is most likely trying to set the dial for an HCSM that has\n",
		"//  no dials defined inside it or has forgotten to define this\n", 
		"//  function inside the class that represents the HCSM.\n"
		);
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Arguments: \n" );
	fprintf( pFile, "// %scDialName - name of the dial\n", pTab );
	fprintf( pFile, "// %svalue - value to which the dial is set\n", pTab );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Returns: false\n" );
	fprintf( pFile, "//\n" );
	fprintf( 
		pFile, 
		"//////////////////////////////////////////////////////////////////\n"
		);

	if( pUniqueDialTypeList ) 
	{
		TStringPair* pNode;

		/* 
		 * Generate a mutator function for each dial type.
		 */
		for( pNode = pUniqueDialTypeList; pNode; pNode = pNode->pNext ) 
		{
			/* 
			 * Generate the mutator function.
			 */
			fprintf( pFile, "inline virtual bool\n" );
			fprintf( 
				pFile, 
				"%s( const string& cDialName, const %s& )\n",
				pMutatorName, 
				pNode->pName 
				);
			fprintf( pFile, "{\n" );
			fprintf( pFile, "\n" );

			fprintf( 
				pFile, 
				"%scout << MyName()\n%s%s << \"::%s has no dial named \"\n%s%s << cDialName << endl;\n", 
				pTab, 
				pTab, 
				pTab, 
				pMutatorName, 
				pTab, 
				pTab
				);

			fprintf( pFile, "%sreturn false;\n", pTab );

			fprintf( pFile, "\n" );
			fprintf( pFile, "}\n" );
			fprintf( pFile, "\n" );
		}
	}

	/* 
	 * Generate a string mutator function.
	 */
	fprintf( pFile, "inline virtual bool\n" );
	fprintf( 
		pFile, 
		"%s( const string& cDialName )\n", 
		pAccessorStrName
		);
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\n" );

	fprintf( pFile, 
		"%scout << MyName()\n%s%s << \"::%s has no dial named \"\n%s%s << cDialName << endl;\n", 
		pTab, 
		pTab, 
		pTab, 
		pAccessorStrName, 
		pTab, 
		pTab
		);

	fprintf( pFile, "%sreturn false;\n", pTab );

	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/* 
	 * Generate a string mutator function.
	 */
	fprintf( pFile, "inline virtual bool\n" );
	fprintf( 
		pFile, 
		"%s( const string& cDialName, const string& )\n", 
		pMutatorStrName
		);
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\n" );

	fprintf( pFile, 
		"%scout << MyName()\n%s%s << \"::%s has no dial named \"\n%s%s << cDialName << endl;\n", 
		pTab, 
		pTab, 
		pTab, 
		pMutatorStrName, 
		pTab, 
		pTab
		);

	fprintf( pFile, "%sreturn false;\n", pTab );

	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );

	/*
	 * Generate dial reset function.
	 */
	fprintf(
		pFile, 
		"//////////////////////////////////////////////////////////////////\n"
		);
	fprintf( pFile, "//\n" );
	fprintf( 
		pFile, 
		"%s%s",
		"// Description: Virtual methods for reseting dials overidden\n",
		"//  by CHcsm subclasses.\n"
		);
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Remarks: \n" );
	fprintf( 
		pFile, 
		"%s%s%s%s%s%s",
		"//  If the user uses the HCSM system properly, this function should\n",
		"//  never be called because a sub-class should reimplement this\n",
		"//  function if it has dials.  If this function gets called, then\n",
		"//  it is most likely trying to reset the dial for an HCSM that has\n",
		"//  no dials defined inside it or has forgotten to define this\n", 
		"//  function inside the class that represents the HCSM.\n"
		);
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Arguments: \n" );
	fprintf( pFile, "// %scDialName - name of the dial\n", pTab );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Returns: nothing\n" );
	fprintf( pFile, "//\n" );
	fprintf( 
		pFile, 
		"//////////////////////////////////////////////////////////////////\n"
		);
	fprintf( pFile, "\n" );

	fprintf( pFile, "inline virtual bool\n" );
	fprintf( pFile, "%s( const string& cDialName )\n", pResetMutatorName );
	fprintf( pFile, "{\n" );
	fprintf( pFile, 
		"%scout << MyName()\n%s%s << \"::%s has no dial named \"\n%s%s << cDialName << endl;\n", 
		pTab, 
		pTab, 
		pTab, 
		pResetMutatorName, 
		pTab, 
		pTab
		);
	fprintf( pFile, "%sreturn false;\n", pTab);
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );
}

/******************************************************************************
 *
 * Description: Generates the virtual Hcsm class member GetMonitorByName 
 *	  functions for getting monitor values that are overridden by the Hcsm 
 *	  subclasses.
 *
 * Remarks:  For a given state machine, this function generates the CHcsm 
 *   accessor functions for all of that state machine's monitor types.
 *
 * Arugments:
 *   pFile                   -- Pointer to the file to write data to.
 *   pUniqueMonitorTypeList  -- Pointer to the list of unique monitor types
 *
 * Returns:
 *
 */
static void 
GenHcsmMonitor( 
			FILE* pFile, 
			TStringPair* pUniqueMonitorTypeList 
			)
{
	static char* pTab = "    ";   
	static char* pAccessorName = "GetMonitorByName"; 
	static char* pAccessorStrName = "GetMonitorByNameStr"; 

	/*
	 * Print out a header and information about the functions
	 */
	fprintf(
		pFile, 
		"//////////////////////////////////////////////////////////////////\n"
		);
	fprintf( pFile, "//\n" );
	fprintf( 
		pFile, 
		"%s%s",
		"// Description: Virtual methods for monitors overidden by CHcsm\n",
		"//  subclasses.\n"
		);
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Remarks: \n" );
	fprintf( 
		pFile, 
		"%s%s%s%s%s%s",
		"//  If the user uses the HCSM system properly, this function should\n",
		"//  never be called because a sub-class should reimplement this\n",
		"//  function if it has dials.  If this function gets called, then\n",
		"//  it is most likely trying to set the dial for an HCSM that has\n",
		"//  no dials defined inside it or has forgotten to define this\n", 
		"//  function inside the class that represents the HCSM.\n"
		);
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Arguments: \n" );
	fprintf( pFile, "// %smonitorName - name of the monitor\n", pTab );
	fprintf( 
		pFile, 
		"// %svalue - place where value of monitor is put\n", 
		pTab
		);
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Returns: false\n" );
	fprintf( pFile, "//\n" );
	fprintf( 
		pFile, 
		"//////////////////////////////////////////////////////////////////\n"
		);

	if( pUniqueMonitorTypeList ) 
	{
		TStringPair* pNode;

		/* 
		 * Generate a accessor function for each monitor type.
		 */
		for( pNode = pUniqueMonitorTypeList; pNode; pNode = pNode->pNext ) 
		{
			/* 
			 * Generate the accessor function.
			 */
			fprintf( pFile, "inline virtual bool\n" );
			fprintf( 
				pFile, 
				"%s( const string& monitorName, %s* )\n", 
				pAccessorName, 
				pNode->pName 
				);
			fprintf( pFile, "{\n" );
			fprintf( pFile, "\n" );

			fprintf( 
				pFile, 
				"%scout << MyName()\n%s%s << \"::%s has no monitor named \"\n%s%s << monitorName << endl;\n", 
				pTab, 
				pTab, 
				pTab, 
				pAccessorName, 
				pTab, 
				pTab
				);
			
			fprintf( pFile, "%sreturn false;\n", pTab );

			fprintf( pFile, "\n" );
			fprintf( pFile, "}\n" );
			fprintf( pFile, "\n" );
		}
	}

	/* 
	 * Generate a string mutator function.
	 */
	fprintf( pFile, "inline virtual bool\n" );
	fprintf( 
		pFile, 
		"%s( const string monitorName, const string* )\n", 
		pAccessorStrName
		);
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\n" );

	fprintf( 
		pFile, 
		"%scout << MyName()\n%s%s << \"::%s has no monitor named \"\n%s%s << monitorName << endl;\n", 
		pTab, 
		pTab, 
		pTab, 
		pAccessorStrName, 
		pTab, 
		pTab
		);
	
	fprintf( pFile, "%sreturn false;\n", pTab);

	fprintf( pFile, "\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );
}


/******************************************************************************
 *
 * Description:  Builds a linked list of unique dial types.
 *
 * Remarks:  This function looks at all the dial name/type string pairs 
 *   and generates a linked list of unique dial types.  The linked list
 *   is terminated by a NULL.
 *
 * Inputs:
 *
 * Returns:  A pointer to the linked list.  The pointer is NULL if the
 *   linked list is empty.
 *
 */
static TStringPair* BuildUniqueDialTypeList( void )
{

	TStateMachine* pSm;             /* pointer to SM on SM list             */
	TStringPair*   pDial;           /* pointer to dial in a SM              */
	TStringPair*   pUniqueDialType; /* a list of unique types for dials     */

	pUniqueDialType = NULL;
	for ( pSm = m_pIn->sm_list; pSm; pSm = pSm->next ) {

		for ( pDial = pSm->dials; pDial; pDial = pDial->pNext ) {

			TStringPair* pUniqueTypeLocator;

			/* find the dial type on the unique type list */
			pUniqueTypeLocator = LookupStrPair( pUniqueDialType, pDial->pValue );

			if ( !pUniqueTypeLocator ) {

				/* dial type not found on unique list so insert it */
				char         dialName[256];
				char         dialType[256];
				char		 dialCat[256];

				TStringPair* pNew;

				pNew = NewStrPair();
					/* value holds type name */
				strcpy( dialType, pDial->pValue );   
					/* category  holds category name */
				sprintf( dialCat, "%s", pDial->pCategory );   
				sprintf( dialName, "%s_dial", pDial->pValue );
				pNew->pName = safe_strdup( dialType );
				pNew->pCategory = safe_strdup( dialCat );
				if (pDial->pDscrptn) pNew->pDscrptn = safe_strdup( pDial->pDscrptn );
				AppendStrPairToLinkList( &pUniqueDialType, pNew );

			}

		}

	}

	return pUniqueDialType;

}

 
/******************************************************************************
 *
 * Description:  Builds a linked list of unique monitor types.
 *
 * Remarks:  This function looks at all the monitor name/type string pairs 
 *   and generates a linked list of unique monitor types.  The linked list
 *   is terminated by a NULL.
 *
 * Inputs:
 *
 * Returns:  A pointer to the linked list.  The pointer is NULL if the
 *   linked list is empty.
 *
 */
static TStringPair* BuildUniqueMonitorTypeList( void )
{

	TStateMachine* pSm;             /* pointer to SM on SM list             */
	TStringPair*   pMonitor;        /* pointer to monitor in a SM           */
	TStringPair*   pUniqueMonitorType; /* a list of unique types for monitor*/

	pUniqueMonitorType = NULL;
	for ( pSm = m_pIn->sm_list; pSm; pSm = pSm->next ) {

		for ( pMonitor = pSm->monitors; pMonitor; pMonitor = pMonitor->pNext ) {

			TStringPair* pUniqueType;

			/* find the dial type on the unique type list */
			pUniqueType = LookupStrPair( pUniqueMonitorType, pMonitor->pValue );

			if ( !pUniqueType ) {

				/* dial type not found on unique list so insert it */
				char         monitorName[256];
				char         monitorType[256];
				TStringPair* pNew;

				pNew = NewStrPair();
				strcpy( monitorType, pMonitor->pValue );   /* value holds type name */
				sprintf( monitorName, "%s_monitor", pMonitor->pValue );
				pNew->pName = safe_strdup( monitorType );
				if ( pMonitor->pDscrptn ) pNew->pDscrptn = safe_strdup( pMonitor->pDscrptn );
				AppendStrPairToLinkList( &pUniqueMonitorType, pNew );

			}

		}

	}

	return pUniqueMonitorType;

}


/******************************************************************************
 *
 * Description:  Generates the C++ header and implementation files for 
 *   classes derived from CHcsmCommunicate.
 *
 * Remarks:  This function generates the C++ header and implmentation
 *   files for classes that are derived from CHcsmCommunicate.  It generates
 *   a class for each type of dial and monitor specified in the input file 
 *   to the parser.
 *
 * Inputs:
 *   pHeaderFile    - Pointer to the header file to write data to.
 *   pImplementFile - Pointer to the implementation file to write data to.
 *
 * Returns:
 *
 */
static void 
GenCommunicationClasses( 
			FILE* pHeaderFile, 
			FILE* pImplementFile, 
			FILE* pHcsmInlFile 
			)
{

	char           modifiedHeaderName[256]; /* holds header name            */
	char*          pC;              /* pointer to character                 */
	TStringPair*   pNode;           /* pointer to element in a str pair list*/
	TStringPair*   pUniqueDialType; /* a list of unique types for dials     */
	TStringPair*   pUniqueMonitorType; /* a list of unique types for monitor*/

	/*
	 * Print the preamble.
	 */
	fprintf( pHeaderFile, m_pHeaderPreamble1 );
	fprintf( pImplementFile, m_pHeaderPreamble1 );

	/*
	 * Put #ifndef around the header file to protect from multiple
	 * inclusions.  use _ for any non alphanumeric characters.
	 */
	strcpy( modifiedHeaderName, SM_COMMUNICATE_HEADER_FILE );
	pC = modifiedHeaderName;
	while ( *pC ) {

		if ( ! isalnum( *pC ) )  *pC = '_';
		pC++;

	}
	fprintf( pHeaderFile, "#ifndef __%s_INCLUDED_\n#define __%s_INCLUDED_\n\n",
			 modifiedHeaderName, modifiedHeaderName );

	/* 
	 * Include the global header file.
	 */
	fprintf( pHeaderFile, "#include \"%s\"\n", SM_GLOBAL_HEADER_FILE );

	/*
	 * Print the include for the header file.
	 */
	fprintf( pImplementFile, "#include \"%s\"\n", SM_COMMUNICATE_HEADER_FILE );
	fprintf( pImplementFile, "#include <genericinclude.h>\n" );
	fprintf( pImplementFile, "#include <hcsmcollection.h>\n" );
	fprintf( pImplementFile, "\n" );

	/*
	 * Build a unique list of dial types needed from all
	 * of the dials specified in all the state machines.
	 */
	pUniqueDialType = BuildUniqueDialTypeList();

	/*
	 * Build a unique list of monitor types needed from all
	 * of the monitors specified in all the state machines.
	 */
	pUniqueMonitorType = BuildUniqueMonitorTypeList();

	/*
	 * Put in an include statement to for dial and monitor base classes 
	 * if needed in the header file.
	 */
	if ( pUniqueDialType ) {

		fprintf( pHeaderFile, "#include \"dial.h\"\n" );

	}
	if ( pUniqueMonitorType ) {

		fprintf( pHeaderFile, "#include \"monitor.h\"\n" );

	}

	/* include standard library stuff in the header file */
	fprintf( pHeaderFile, "#include <string>\n" );
	fprintf( pHeaderFile, "using namespace std;\n" );
	fprintf( pHeaderFile, "\n" );

	/* 
	 * Generate the headers and implementations for classes needed to
	 * represent dials.
	 */
	for ( pNode = pUniqueDialType; pNode; pNode = pNode->pNext ) {

		/* generate class declarations for input parameters */
		GenCommunicationDerivedClassHeader( 
					pHeaderFile, 
					pNode->pName, 
					"CDial", 
					"CDial" 
					);

		/* generate class implementations for input parameters */
		GenCommunicationDerivedClassImpementation(
					pImplementFile, 
					pNode->pName, 
					pNode->pCategory,
					"CDial", 
					"CDial"
					);

	}

	/* 
	 * Generate the headers and implementations for classes needed to
	 * represent monitors.
	 */
	for ( pNode = pUniqueMonitorType; pNode; pNode = pNode->pNext ) {

		/* generate class declarations for input parameters */
		GenCommunicationDerivedClassHeader( 
					pHeaderFile, 
					pNode->pName, 
					"CMonitor", 
					"CMonitor" 
					);

		/* generate class implementations for input parameters */
		GenCommunicationDerivedClassImpementation( 
					pImplementFile, 
					pNode->pName, 
					pNode->pCategory,
					"CMonitor", 
					"CMonitor" 
					);

	}

	/*
	 * End the multiple file inclusion protection for the header file.
	 */
	fprintf( pHeaderFile, "\n\n#endif\n" );

	/* 
	 * Generate CHcsm virtual dial/monitor functions.
	 */
	fprintf( pHcsmInlFile, m_pHeaderPreamble1 );
	GenHcsmDial( pHcsmInlFile, pUniqueDialType );
	GenHcsmMonitor( pHcsmInlFile, pUniqueMonitorType );
}


/******************************************************************************
 *
 * Description: Figures out whether the list of state machines have any
 *   communication mechanisms defined in them.
 *
 * Remarks:  This function takes a pointer to a list of state machines and
 *   then traverses the list to figure if the state machines contain dials
 *   or monitors.
 *
 * Inputs:
 *   pSmList -- Pointer to a list of state machines.
 *
 */
static EBool HasCommunicate( TStateMachine* pSmList )
{

	TStateMachine* pSm;             /* pointer to SM on SM list             */

	for ( pSm = pSmList; pSm; pSm = pSm->next ) {

		if ( pSm->dials || pSm->monitors ) {

			/*
			 * this list of state machines has a reference to
			 * communication mechanisms
			 */
			return eTRUE;

		}

	}

	return eFALSE;

}


/******************************************************************************
 *
 * Description: Figures out whether the list of state machines have any
 *   storage defined in them.
 *
 * Remarks:  This function takes a pointer to a list of state machines and
 *   then traverses the list to figure if the state machines contain input 
 *   parameters, local variables or output parameters.
 *
 * Inputs:
 *   pSmList -- Pointer to a list of state machines.
 *
 */
static EBool HasStorage( TStateMachine* pSmList )
{

	TStateMachine* pSm;             /* pointer to SM on SM list             */

	for ( pSm = pSmList; pSm; pSm = pSm->next ) {

		if ( pSm->inputs || pSm->locals || pSm->outputs ) {

			/* this list of state machines has a reference to storage */
			return eTRUE;

		}

	}

	return eFALSE;

}


/******************************************************************************
 *
 * Description: Generates the state machine c++ global header file.
 *
 * Remarks:  This function generates the global hcsm c++ header file that 
 *   contains declarations for entities that should be available to all
 *   HCSMs.
 *
 * Inputs:
 *   pFile -- Pointer to a file to write data to.
 *
 */
static void GenHcsmGlobalHeader( FILE* pFile )
{

	char*          pC;              /* pointer to character                 */
	char           modifiedHeaderName[256]; /* holds header name            */
	/*
	 * Print the preamble.
	 */
	fprintf( pFile, m_pHeaderPreamble1 );

	/*
	 * Put #ifndef around the header file to protect from multiple
	 * inclusions.  use _ for any non alphanumeric characters.
	 */
	strcpy( modifiedHeaderName, SM_GLOBAL_HEADER_FILE );
	pC = modifiedHeaderName;
	while ( *pC ) {

		if ( ! isalnum( *pC ) )  *pC = '_';
		pC++;

	}
	fprintf( pFile, "#ifndef __%s_INCLUDED_\n#define __%s_INCLUDED_\n\n",
					 modifiedHeaderName, modifiedHeaderName );

	/*
	 * Write the header code into the file.
	 */
	if ( m_pIn->header_code ) {
		
		fprintf( pFile, "%s", m_pIn->header_code );
		fprintf( pFile, "\n" );

	}

	/*
	 * Close the multiple-header inclusion.
	 */
	fprintf( pFile, "\n\n#endif\n" );

}

 
/******************************************************************************
 *
 * Description: Generates the state machine c++ header file.
 *
 * Remarks:  This function generates a c++ header file that contains 
 *   declarations for all classes generated from the data in the parser
 *   structures.
 *
 * Inputs:
 *   pFile -- Pointer to a file to write data to.
 *
 */
static void GenClassHeader( FILE* pFile )
{

	static char*   pConcurrentHeaderName = "hcsmconcurrent.h";
	static char*   pSequentialHeaderName = "hcsmsequential.h";
	static char*   pSnoBlockBaseHeaderName = "snoblock.h";
	static char*   pSnoBlockHeaderName = "hcsmspec.h";
	static char*   pCollectionName = "CHcsmCollection";
	static char*   pConcurrentName = "CHcsmConcurrent";
	static char*   pSequentialName = "CHcsmSequential";
	static char*   pSnoBlockClassName = "CSnoBlock";
	static char*   pTab = "    ";   /* simulates a tab character            */

	char           modifiedHeaderName[256]; /* holds header name            */
	char*          pC;              /* pointer to character                 */
	EBool          includeButton;   /* need to include CHcsmBtn?            */
	EBool          includeCommunicate;/* need to include HcsmCommunicate?   */
	EBool          includeConcurrent; /* need to include HcsmConcurrent?    */
	EBool          includeSequential; /* need to include HcsmSequential?    */
	EBool          includeStorage;  /* include HcsmStorage?                 */
	TStateMachine* pSm;             /* pointer to SM on SM list             */
	TStringNode*   pChild;          /* pointer to child state machine node  */
	TStringPair*   pButton;         /* pointer to button string node        */
	TStringPair*   pDial;           /* pointer to dial str pair             */
	TStringPair*   pInput;          /* pointer to input parameter str pair  */
	TStringPair*   pLocal;          /* pointer to local variable str pair   */
	TStringPair*   pMonitor;        /* pointer to monitor str pair          */
	TStringPair*   pOutput;         /* pointer to output parameter str pair */


	/*
	 * Print the preamble.
	 */
	fprintf( pFile, m_pHeaderPreamble1 );

	/*
	 * Put #ifndef around the header file to protect from multiple
	 * inclusions.  use _ for any non alphanumeric characters.
	 */
	strcpy( modifiedHeaderName, SM_CLASS_HEADER_FILE );
	pC = modifiedHeaderName;
	while ( *pC ) {

		if ( ! isalnum( *pC ) )  *pC = '_';
		pC++;

	}
	fprintf( pFile, "#ifndef __%s_INCLUDED_\n#define __%s_INCLUDED_\n\n",
					 modifiedHeaderName, modifiedHeaderName );

	/* 
	 * Include the global header file.
	 */
	fprintf( pFile, "#include \"%s\"\n", SM_GLOBAL_HEADER_FILE );

	/*
	 * Include the sno parser header files.
	 */
	fprintf( pFile, "#include <%s>\n", pSnoBlockBaseHeaderName );
	fprintf( pFile, "#include <%s>\n", pSnoBlockHeaderName );

	/*
	 * Figure out what needs to be included by going through the list
	 * of state machines and seeing if they sub-class from HcsmConcurrent,
	 * HcsmSequential or both of them.
	 */
	includeConcurrent  = eFALSE;
	includeSequential  = eFALSE;
	includeStorage     = HasStorage( m_pIn->sm_list );
	includeCommunicate = HasCommunicate( m_pIn->sm_list );
	includeButton      = eFALSE;

	for ( pSm = m_pIn->sm_list; pSm; pSm = pSm->next ) {

		/* figure out if this is concurrent or sequential hcsm */
		if ( pSm->trans && !includeSequential) {

			/* sm has transitions and therefore is sequential */
			includeSequential = eTRUE;

		}
		else {

			/* concurrent */
			includeConcurrent = eTRUE;

		}
		
		if ( pSm->buttons && !includeButton )  includeButton = eTRUE;

		if ( includeConcurrent && includeSequential && includeButton )  break;

	}  /* END FOR pSm = m_pIn->sm_list */

	if ( includeConcurrent ) {

		fprintf( pFile, "#include \"%s\"\n", pConcurrentHeaderName );

	}
	if ( includeSequential ) {

		fprintf( pFile, "#include \"%s\"\n", pSequentialHeaderName );

	}
	if ( includeStorage ) {

		fprintf( pFile, "#include \"%s\"\n", SM_STORAGE_HEADER_FILE );

	}
	if ( includeCommunicate ) {

		fprintf( pFile, "#include \"%s\"\n", SM_COMMUNICATE_HEADER_FILE );

	}
	if ( includeButton ) {

		fprintf( pFile, "#include \"button.h\"\n" );

	}
	if ( includeConcurrent || includeSequential || includeStorage ||
		 includeCommunicate || includeButton ) {
		
		fprintf( pFile, "\n" );

	}

	/*
	 * Print the class declarations.
	 */
	for ( pSm = m_pIn->sm_list; pSm; pSm = pSm->next ) {

		char*    pParentName;
		char*    pSnoParserClassName;
		EBool    isConcurrent;
		EBool    printedPrivate = eFALSE;

		/* figure out if this is concurrent or sequential hcsm */
		if ( pSm->trans ) {

			/* sm has transitions and therefore is sequential */
			isConcurrent = eFALSE;
			pParentName  = pSequentialName;

		}
		else {

			/* concurrent */
			isConcurrent = eTRUE;
			pParentName  = pConcurrentName;

		}

		pSnoParserClassName = GetSnoParserClassFromHcsmName( pSm->name );

		fprintf( pFile, "class C%s : public %s\n", pSm->name, pParentName );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "public:\n" );
		if ( pSnoParserClassName ) {
			fprintf( pFile, "%sC%s( %s*, const %s& );\n", pTab, pSm->name, 
					 pCollectionName, pSnoBlockClassName );
		}
		else {
			fprintf( pFile, "%sC%s( %s* );\n", 
					 pTab, pSm->name, pCollectionName );
		}
		fprintf( pFile, "%sC%s( const C%s& );\n", pTab, pSm->name, pSm->name );
		fprintf( pFile, "%sC%s& operator=( const C%s& );\n", pTab, pSm->name,
				 pSm->name );
		fprintf( pFile, "%svirtual ~C%s();\n", pTab, pSm->name );

		/*
		 * Generate public input parameter mutator functions.
		 */
		for ( pInput = pSm->inputs; pInput; pInput = pInput->pNext ) {

			fprintf( pFile, "%svoid SetInput%s( %s );\n", pTab, 
					 pInput->pName, pInput->pValue );

		}

		/*
		 * Generate public output parameter accessor functions.  Also
		 * generate associated HasValue functions.
		 */
		for ( pOutput = pSm->outputs; pOutput; pOutput = pOutput->pNext ) {

			fprintf( pFile, "%s%s GetOutput%s();\n", pTab, pOutput->pValue,
					 pOutput->pName );
			fprintf( pFile, "%sbool HasValueOutput%s();\n", pTab, 
					 pOutput->pName );

		}

		/*
		 * Generate public dial mutator functions.
		 */
		for ( pDial = pSm->dials; pDial; pDial = pDial->pNext ) {

			fprintf( pFile, "%svoid SetDial%s( %s );\n", pTab, 
					 pDial->pName, pDial->pValue );
			fprintf( pFile, "%svoid SetDial%sNoValue();\n", 
					 pTab, pDial->pName );

		}

		/*
		 * Generate public monitor accessor functions.
		 */
		for ( pMonitor = pSm->monitors; pMonitor; pMonitor = pMonitor->pNext ) {

			fprintf( pFile, "%s%s GetMonitor%s();\n", pTab, pMonitor->pValue,
					 pMonitor->pName );

		}

		/*
		 * Generate public button mutator function.
		 */
		if ( pSm->buttons ) {
			
			fprintf( pFile, "%svirtual bool SetButtonByName", pTab );
			fprintf( pFile, "( const string& );\n" );

		}

		/*
		 * Generate public dial mutator functions.
		 */
		if ( pSm->dials ) {
			
			TStringPair *pNode;
			TStringPair *pUniqueDialTypeList = BuildUniqueDialTypeList();

			/* 
			 * Generate a mutator function for each dial type.
			 */
			for ( pNode = pUniqueDialTypeList; pNode; pNode = pNode->pNext ) {

				fprintf( pFile, "%sbool SetDialByName", pTab );
				fprintf( pFile, "( const string&, const %s& );\n", pNode->pName );

			}
			/* 
			 * Generate a mutator function that takes a string parameter
			 */
			fprintf( pFile, "%sbool SetDialByNameStr", pTab );
			fprintf( pFile, "( const string&, const string& );\n" );
			/* 
			 * Generate a mutator function that takes a string parameter
			 */
			fprintf( pFile, "%sbool IsDialActiveByNameStr", pTab );
			fprintf( pFile, "( const string& );\n" );
			/*
			 * Generator a function that reset the value of the dial.
			 */
			fprintf( pFile, "%sbool ResetDialByName", pTab );
			fprintf( pFile, "( const string& );\n" );
		}

		/*
		 * Generate public dial mutator functions.
		 */
		if ( pSm->monitors ) {
			
			TStringPair *pNode;
			TStringPair *pUniqueMonitorTypeList = BuildUniqueMonitorTypeList();

			/* 
			 * Generate an accessor function for each monitor type.
			 */
			for ( pNode = pUniqueMonitorTypeList; pNode; pNode = pNode->pNext ) {

				fprintf( pFile, "%sbool GetMonitorByName", pTab );
				fprintf( pFile, "( const string&, %s* );\n", pNode->pName );

			}

		}

		/*************************************
		 *
		 * Declare private members.
		 *
		 */
		if ( !isConcurrent ) {

			if ( !printedPrivate ) {
				
				fprintf( pFile, "\n" );
				fprintf( pFile, "private:\n" );
				printedPrivate = eTRUE;

			}

			fprintf( pFile, "%svirtual void ExecuteTransitions();\n", pTab );

		}

		/*
		 * Build the ExecutePredicate() prototype.
		 */
		if ( pSm->pred ) {
			TPredicate* pPred;

			/* this hcsm has a transition originating from it so we have to
			 * build the ExecutePredicate() member function
			 */
			if ( !printedPrivate ) {

				fprintf( pFile, "\n" );
				fprintf( pFile, "private:\n" );
				printedPrivate = eTRUE;

			}

			fprintf( pFile, "%svirtual bool ExecutePredicate( int );\n", pTab );

			/* now print prototypes for all the predicate functions */
			for ( pPred = pSm->pred; pPred; pPred = pPred->pNext ) {

				fprintf( pFile, "%sbool %s();\n", pTab, pPred->pName );

			}

		}

		/*
		 * Build the Creation, Deletion, Pre-Activity and Post-Activity,
		 * and Private function prototypes.
		 */
		if ( pSm->create_cb || pSm->delete_cb || pSm->pre_activity || 
			 pSm->post_activity || pSm->priv_user_func ) {

			/* print the private keyword if it already hasn't been printed */
			if ( !printedPrivate ) {

				fprintf( pFile, "\n" );
				fprintf( pFile, "private:\n" );
				printedPrivate = eTRUE;

			}

			if ( pSm->create_cb ) {
				
				fprintf( pFile, "%svirtual void Creation", pTab );
				if ( pSnoParserClassName ) {
					fprintf( pFile, "( const %s* );\n", pSnoBlockClassName );
				}
				else {
					fprintf( pFile, "();\n" );
				}

			}

			if ( pSm->delete_cb ) {
				
				fprintf( pFile, "%svirtual void Deletion", pTab );
				if ( pSnoParserClassName ) {
					fprintf( pFile, "( const %s* );\n", pSnoBlockClassName );
				}
				else {
					fprintf( pFile, "();\n" );
				}

			}

			if ( pSm->pre_activity ) {
				
				fprintf( pFile, "%svirtual void PreActivity", pTab );
				if ( pSnoParserClassName ) {
					fprintf( pFile, "( const %s* );\n", pSnoBlockClassName );
				}
				else {
					fprintf( pFile, "();\n" );
				}

			}

			if ( pSm->post_activity ) {
				
				fprintf( pFile, "%svirtual void PostActivity", pTab );
				if ( pSnoParserClassName ) {
					fprintf( pFile, "( const %s* );\n", pSnoBlockClassName );
				}
				else {
					fprintf( pFile, "();\n" );
				}

			}

			if ( pSm->priv_user_func ) {
				
				TPrivUser* pTmp;
				for( pTmp = pSm->priv_user_func; pTmp; pTmp = pTmp->pNext ) {
					
					/* The code generator expects the parser to put the
					 * semi-colon and end of line character in the declaration
					 * string.
					 */
					fprintf( pFile, "%s%s", pTab, pTmp->pDec );
					
				}

			}

		}  /* END IF pSm->create_cb... */

		/*
		 * Generate input parameter member variables and accessor functions.
		 * Also generate the associated HasValue functions.
		 */
		for ( pInput = pSm->inputs; pInput; pInput = pInput->pNext ) {

			/* print the private keyword if it already hasn't been printed */
			if ( !printedPrivate ) {

				fprintf( pFile, "\n" );
				fprintf( pFile, "private:\n" );
				printedPrivate = eTRUE;

			}

			fprintf( pFile, "%sCInputPar%s m_input%s;\n", pTab, 
					 pInput->pValue, pInput->pName );
			fprintf( pFile, "%s%s GetInput%s();\n", pTab, pInput->pValue,
					 pInput->pName );
			fprintf( pFile, "%sbool HasValueInput%s();\n", pTab, 
					 pInput->pName );

		}

		/*
		 * Generate local variable member variables.
		 */
		for ( pLocal = pSm->locals; pLocal; pLocal = pLocal->pNext ) {

			/* print the private keyword if it already hasn't been printed */
			if ( !printedPrivate ) {

				fprintf( pFile, "\n" );
				fprintf( pFile, "private:\n" );
				printedPrivate = eTRUE;

			}

			fprintf( pFile, "%sCLocalVar%s m_local%s;\n", pTab, 
					 pLocal->pValue, pLocal->pName );
			fprintf( pFile, "%s%s GetLocal%s();\n", pTab, pLocal->pValue,
					 pLocal->pName );
			fprintf( pFile, "%svoid SetLocal%s( %s );\n", pTab, pLocal->pName,
					 pLocal->pValue );
			
		}

		/*
		 * Generate output parameter member variables and mutator functions.
		 */
		for ( pOutput = pSm->outputs; pOutput; pOutput = pOutput->pNext ) {

			/* print the private keyword if it already hasn't been printed */
			if ( !printedPrivate ) {

				fprintf( pFile, "\n" );
				fprintf( pFile, "private:\n" );
				printedPrivate = eTRUE;

			}

			fprintf( pFile, "%sCOutputPar%s m_output%s;\n", pTab, 
					 pOutput->pValue, pOutput->pName );
			fprintf( pFile, "%svoid SetOutput%s( %s );\n", pTab, 
					 pOutput->pName, pOutput->pValue );
			fprintf( pFile, "%svoid SetOutput%sNoValue();\n", 
					 pTab, pOutput->pName );

		}

		/* 
		 * Generate mutator functions for each child's input parameters.
		 * The mutator function has the form:  SetInputXxxForYyy where 
		 * Xxx is the input's name and Yyy is the child's name which 
		 * contains the input parameter.
		 *
		 * Generate accessor functions for each child's output parameters.
		 * The accessor funtion has the form:  GetOutputXxxFromYyy where
		 * Xxx is the output's name and Yyy is the child's name which
		 * contains the output parameter.
		 */
		for ( pChild = pSm->children; pChild; pChild = pChild->pNext ) {

			TStateMachine* pChildSm;  /* pointer to child state machine */
			TStringPair*   pIn;       /* pointer to input parameter     */
			TStringPair*   pOut;      /* pointer to output parameter    */

			/* print the private keyword if it already hasn't been printed */
			if ( !printedPrivate ) {

				fprintf( pFile, "\n" );
				fprintf( pFile, "private:\n" );
				printedPrivate = eTRUE;

			}

			pChildSm = LookupSm( m_pIn->sm_list, pChild->pName );

			for ( pIn = pChildSm->inputs; pIn; pIn = pIn->pNext ) {

				fprintf( pFile, "%svoid SetInput%sFor%s( %s );\n",  pTab, 
						 pIn->pName, pChildSm->name, pIn->pValue );

			}

			for ( pOut = pChildSm->outputs; pOut; pOut = pOut->pNext ) {

				fprintf( pFile, "%s%s GetOutput%sFrom%s();\n",  pTab, 
						 pOut->pValue, pOut->pName, pChildSm->name );
				fprintf( pFile, "%sbool HasValueOutput%sFrom%s();\n", pTab,
						 pOut->pName, pChildSm->name );

			}

		}

		/*
		 * Generate button member variables and accessor functions.
		 */
		for ( pButton = pSm->buttons; pButton; pButton = pButton->pNext ) {

			/* print the private keyword if it already hasn't been printed */
			if ( !printedPrivate ) {

				fprintf( pFile, "\n" );
				fprintf( pFile, "private:\n" );
				printedPrivate = eTRUE;

			}

			fprintf( pFile, "%sCHcsmBtn m_button%s;\n", pTab, pButton->pName );
			fprintf( pFile, "%sbool GetButton%s();\n", pTab, pButton->pName );

		}

		/*
		 * Generate dial member variables and accessor functions.
		 */
		for ( pDial = pSm->dials; pDial; pDial = pDial->pNext ) {

			/* print the private keyword if it already hasn't been printed */
			if ( !printedPrivate ) {

				fprintf( pFile, "\n" );
				fprintf( pFile, "private:\n" );
				printedPrivate = eTRUE;

			}

			fprintf( pFile, "%sCDial%s m_dial%s;\n", pTab, 
					 pDial->pValue, pDial->pName );
			fprintf( pFile, "%s%s GetDial%s();\n", pTab, pDial->pValue,
					 pDial->pName );

		}

		/*
		 * Generate monitor member variables and mutator functions.
		 */
		for ( pMonitor = pSm->monitors; pMonitor; pMonitor = pMonitor->pNext ) {

			/* print the private keyword if it already hasn't been printed */
			if ( !printedPrivate ) {

				fprintf( pFile, "\n" );
				fprintf( pFile, "private:\n" );
				printedPrivate = eTRUE;

			}

			fprintf( pFile, "%sCMonitor%s m_monitor%s;\n", pTab, 
					 pMonitor->pValue, pMonitor->pName );
			fprintf( pFile, "%svoid SetMonitor%s( %s );\n", pTab, 
					 pMonitor->pName, pMonitor->pValue );
			fprintf( pFile, "%svoid SetMonitor%sNoValue();\n", pTab, 
					 pMonitor->pName );

		}

		fprintf( pFile, "};\n\n" );

	} /* END FOR pSm = m_pIn->sm_list... */

	fprintf( pFile, "\n\n#endif\n" );
	
}


/******************************************************************************
 *
 * Name:  GenClassConstructor
 *
 * Generates the class constructor.
 *
 * Inputs:
 *   pFile                -- Pointer to the file to write data to.
 *   pParentClassName     -- The parent class' name.
 *   pCollectionClassName -- The collection class' name.
 *   pSm                  -- Pointer to SM on SM list in parser data 
 *                           structures.
 *
 */
static void GenClassConstructor(
			FILE* pFile, 
			char* pParentClassName, 
			char* pCollectionClassName,
			TStateMachine* pSm,
			char* pSnoBlockClassName,
			char* pSnoBlockMemberVarName
			)
{

	static char*   pCollectionVarName = "pRootCollection";
	static char*   pSnoBlockBaseClassName = "CSnoBlock";
	static char*   pSnoBlockVarName   = "snoBlock";
	static char*   pTab = "    ";   /* simulates a tab character            */

	TStringPair*   pButton;         /* pointer to button string node        */
	TStringPair*   pDial;           /* pointer to dial str pair             */
	TStringPair*   pInput;          /* pointer to input parameter str pair  */
	TStringPair*   pLocal;          /* pointer to local variable str pair   */
	TStringPair*   pMonitor;        /* pointer to monitor str pair          */
	TStringPair*   pOutput;         /* pointer to output parameter str pair */

	/*
	 * Print the constructor prototype.
	 */
	fprintf( pFile, "C%s::C%s(\n", pSm->name, pSm->name );
	fprintf( pFile, "%s%s%s%s* %s", pTab, pTab, pTab,
			 pCollectionClassName, pCollectionVarName );
	if ( pSnoBlockClassName ) {
		fprintf( pFile, ",\n" );
		fprintf( pFile, "%s%s%sconst %s& %s\n", pTab, pTab, pTab,
				 pSnoBlockBaseClassName, pSnoBlockVarName );
	}
	else {
		fprintf( pFile, "\n" );
	}
	fprintf( pFile, "%s%s%s):\n", pTab, pTab, pTab );
	fprintf( pFile, "%s%s(\n", pTab, pParentClassName );
	fprintf( pFile, "%s%s%s%s,\n", pTab, pTab, pTab, pCollectionVarName );
	if ( pSnoBlockClassName ) {
		fprintf( pFile, "%s%s%snew %s( %s ),\n", pTab, pTab, pTab, 
				 pSnoBlockClassName, pSnoBlockVarName );
	}
	fprintf( pFile, "%s%s%s\"%s\",\n", pTab, pTab, pTab, pSm->name );
	fprintf( pFile, "%s%s%s%s,\n", pTab, pTab, pTab, pSm->isRoot ? "true" : "false" );
	fprintf( pFile, "%s%s%s%d\n", pTab, pTab, pTab, pSm->id );
	fprintf( pFile, "%s%s%s)\n", pTab, pTab, pTab );

	/*
	 * Generate input parameter initializations.
	 */
	for ( pInput = pSm->inputs; pInput; pInput = pInput->pNext ) {

		/* put a comma for continuation from previous line */
		fprintf( pFile, ",\n" );

		fprintf( pFile, "%sm_input%s( \"%s\" )", pTab, pInput->pName, 
				 pInput->pName );

	}

	/*
	 * Generate local variable initializations.
	 */
	for ( pLocal = pSm->locals; pLocal; pLocal = pLocal->pNext ) {

		/* put a comma for continuation from previous line */
		fprintf( pFile, ",\n" );

		fprintf( pFile, "%sm_local%s( \"%s\" )", pTab, pLocal->pName, 
				 pLocal->pName );

	}

	/*
	 * Generate output parameter initializations.
	 */
	for ( pOutput = pSm->outputs; pOutput; pOutput = pOutput->pNext ) {

		/* put a comma for continuation from previous line */
		fprintf( pFile, ",\n" );

		fprintf( pFile, "%sm_output%s( \"%s\" )", pTab, pOutput->pName, 
				 pOutput->pName );

	}

	/*
	 * Generate button initializations.
	 */
	for ( pButton = pSm->buttons; pButton; pButton = pButton->pNext ) {

		/* put a comma for continuation from previous line */
		fprintf( pFile, ",\n" );

		fprintf( pFile, "%sm_button%s( pRootCollection, \"%s\" )", 
				 pTab, pButton->pName, pButton->pName );

	}

	/*
	 * Generate dial initializations.
	 */
	for ( pDial = pSm->dials; pDial; pDial = pDial->pNext ) {

		/* put a comma for continuation from previous line */
		fprintf( pFile, ",\n" );

		fprintf( pFile, "%sm_dial%s( pRootCollection, \"%s\" )", 
				 pTab, pDial->pName, pDial->pName );

	}

	/*
	 * Generate monitor initializations.
	 */
	for ( pMonitor = pSm->monitors; pMonitor; pMonitor = pMonitor->pNext ) {

		/* put a comma for continuation from previous line */
		fprintf( pFile, ",\n" );

		fprintf( pFile, "%sm_monitor%s( pRootCollection, \"%s\" )", 
				 pTab, pMonitor->pName, pMonitor->pName );

	}

	fprintf( pFile, "\n" );
	fprintf( pFile, "{\n\n" );
	
	/*
	 * If the HCSM has children then print AddChild for each child.
	 */
	if ( pSm->children ) {

		TStringNode*   pChild;      /* pointer to a child sm node           */
		TStateMachine* pChildSm;    /* pointer to a child sm                */

		fprintf( pFile, "%s// add my children\n", pTab );

		for ( pChild = pSm->children; pChild; pChild = pChild->pNext ) {

			char* pChildSnoParserName;

			/* find the child in the main parser structure */
			pChildSm = LookupSm( m_pIn->sm_list, pChild->pName );

			pChildSnoParserName = GetSnoParserClassFromHcsmName( pChildSm->name );

			if ( pChildSnoParserName ) {
				fprintf( pFile, "%sAddChild( new C%s( %s, %s ) );\n", 
						 pTab, pChildSm->name, pCollectionVarName,
						 pSnoBlockVarName );
			}
			else {
				fprintf( pFile, "%sAddChild( new C%s( %s ) );\n", 
						 pTab, pChildSm->name, pCollectionVarName );
			}
		}

		fprintf( pFile, "\n" );

		/*
		 * Initialize local members for sequential HCSMs
		 */
		if ( pSm->trans ) {

			fprintf( pFile, "%sm_activeChild = m_children[0];\n", pTab );
			fprintf( pFile, "%sm_defaultActiveChild = m_children[0];\n", pTab );
			fprintf( pFile, "\n" );

		}

	}

#if 0
	/*
	 * Print call to Creation function.
	 */
	fprintf( pFile, "%s// call creation function\n", pTab );
	fprintf( pFile, "%sCreation( %s );\n", pTab, pSnoBlockMemberVarName );
#endif

	fprintf( pFile, "\n}\n" );

}


/******************************************************************************
 *
 * Name:  GenClassCopyConstructor
 *
 * Generates the class copy constructor.
 *
 * Inputs:
 *   pFile            -- Pointer to the file to write data to.
 *   pSm              -- Pointer to SM on SM list in parser data structures.
 *   pParentClassName -- The parent class' name.
 *
 */
static void GenClassCopyConstructor(
			FILE*  pFile, 
			TStateMachine* pSm,
			char* pParentClassName,
			char* pSnoBlockClassName,
			char* pSnoBlockMemberVarName
			)
{

	static char*   pObjToCopy = "objToCopy";
	static char*   pTab = "    ";   /* simulates a tab character            */

	TStringPair*   pButton;         /* pointer to button string node        */
	TStringPair*   pDial;           /* pointer to dial str pair             */
	TStringPair*   pInput;          /* pointer to input parameter str pair  */
	TStringPair*   pLocal;          /* pointer to local variable str pair   */
	TStringPair*   pMonitor;        /* pointer to monitor str pair          */
	TStringPair*   pOutput;         /* pointer to output parameter str pair */

	/*
	 * Print the copy constructor prototype.
	 */
	fprintf( pFile, "C%s::C%s( const C%s& %s ):\n", pSm->name, pSm->name,
			 pSm->name, pObjToCopy );
	fprintf( pFile, "%s%s(\n", pTab, pParentClassName );
	fprintf( pFile, "%s%s%s%s.m_pRootCollection,\n", pTab, pTab, pTab,
			 pObjToCopy );
	if ( pSnoBlockClassName ) {
		fprintf( pFile, "%s%s%s%s.%s,\n", pTab, pTab, pTab, pObjToCopy, 
				 pSnoBlockMemberVarName );
	}
	fprintf( pFile, "%s%s%s%s.m_name,\n", pTab, pTab, pTab, pObjToCopy );
	fprintf( pFile, "%s%s%s%s.m_root\n", pTab, pTab, pTab, pObjToCopy );
	fprintf( pFile, "%s%s%s)", pTab, pTab, pTab );

	/*
	 * Generate input parameter initializations.
	 */
	for ( pInput = pSm->inputs; pInput; pInput = pInput->pNext ) {

		/* put a comma for continuation from previous line */
		fprintf( pFile, ",\n" );

		fprintf( pFile, "%sm_input%s( %s.m_input%s.GetName() )", pTab, 
				 pInput->pName, pObjToCopy, pInput->pName );

	}

	/*
	 * Generate local variable initializations.
	 */
	for ( pLocal = pSm->locals; pLocal; pLocal = pLocal->pNext ) {

		/* put a comma for continuation from previous line */
		fprintf( pFile, ",\n" );

		fprintf( pFile, "%sm_local%s( %s.m_local%s.GetName() )", pTab, 
				 pLocal->pName, pObjToCopy, pLocal->pName );
	}

	/*
	 * Generate output parameter initializations.
	 */
	for ( pOutput = pSm->outputs; pOutput; pOutput = pOutput->pNext ) {

		/* put a comma for continuation from previous line */
		fprintf( pFile, ",\n" );

		fprintf( pFile, "%sm_output%s( %s.m_output%s.GetName() )", pTab, 
				 pOutput->pName, pObjToCopy, pOutput->pName );

	}

	/*
	 * Generate button initializations.
	 */
	for ( pButton = pSm->buttons; pButton; pButton = pButton->pNext ) {

		/* put a comma for continuation from previous line */
		fprintf( pFile, ",\n" );

		fprintf( pFile, "%sm_button%s( %s.m_pRootCollection, %s.m_button%s.GetName() )", 
				 pTab, pButton->pName, pObjToCopy, pObjToCopy, pButton->pName );

	}

	/*
	 * Generate dial initializations.
	 */
	for ( pDial = pSm->dials; pDial; pDial = pDial->pNext ) {

		/* put a comma for continuation from previous line */
		fprintf( pFile, ",\n" );

		fprintf( pFile, "%sm_dial%s( %s.m_pRootCollection, %s.m_dial%s.GetName() )", 
				 pTab, pDial->pName, pObjToCopy, pObjToCopy, pDial->pName );

	}

	/*
	 * Generate monitor initializations.
	 */
	for ( pMonitor = pSm->monitors; pMonitor; pMonitor = pMonitor->pNext ) {

		/* put a comma for continuation from previous line */
		fprintf( pFile, ",\n" );

		fprintf( pFile, "%sm_monitor%s( %s.m_pRootCollection, %s.m_monitor%s.GetName() )", 
				 pTab, pMonitor->pName, pObjToCopy, pObjToCopy, pMonitor->pName );

	}

	fprintf( pFile, "\n" );
	
	fprintf( pFile, "{\n\n" );
	
	/*
	 * Print the copy constructor body.
	 */
	fprintf( pFile, "%s// call the assignment operator\n", pTab );
	fprintf( pFile, "%s*this = %s;\n", pTab, pObjToCopy );


	fprintf( pFile, "\n}\n" );

}


/******************************************************************************
 *
 * Name:  GenClassAssignmentOperator
 *
 * Generates the class assignment operator.
 *
 * Inputs:
 *   pFile            -- Pointer to the file to write data to.
 *   pHcsmName        -- The HCSM template's name.
 *
 */
static void GenClassAssignmentOperator( FILE* pFile, char*  pHcsmName )
{

	static char*   pObjToCopy = "objToCopy";
	static char*   pTab = "    ";   /* simulates a tab character            */

	/*
	 * Print the assignment operator prototype.
	 */
	fprintf( pFile, "C%s& C%s::operator=(\n", pHcsmName, pHcsmName );
	fprintf( pFile, "%s%s%sconst C%s& %s\n", pTab, pTab, pTab, pHcsmName,
			 pObjToCopy );
	fprintf( pFile, "%s%s%s)\n", pTab, pTab, pTab );
	fprintf( pFile, "{\n\n" );
	
	/*
	 * Print the assignment operator body.
	 */
	fprintf( pFile, "%s// check to see if the object passed in is really me\n",
			 pTab );
	fprintf( pFile, "%sif ( this != &%s ) {\n", pTab, pObjToCopy );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%s%s// make a deep copy\n", pTab, pTab );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%s}\n", pTab );
	fprintf( pFile, "\n" );
	fprintf( pFile, "%sreturn *this;\n", pTab );

	fprintf( pFile, "\n}\n" );

}


/******************************************************************************
 *
 * Name:  GenClassDestructor
 *
 * Generates the class destructor.
 *
 * Inputs:
 *   pFile            -- Pointer to the file to write data to.
 *   pHcsmName        -- The HCSM template's name.
 *
 */
static void GenClassDestructor( 
			FILE* pFile, 
			char* pHcsmName,
			char* pSnoBlockClassName,
			char* pSnoBlockMemberVarName
			)
{

	static char*   pTab = "    ";   /* simulates a tab character            */

	/*
	 * Print the destructor prototype.
	 */
	fprintf( pFile, "C%s::~C%s()\n", pHcsmName, pHcsmName );
	fprintf( pFile, "{\n\n" );
	
	/*
	 * Print the destructor body.
	 */
	fprintf( pFile, "%s// call the deletion function\n", pTab );
	if ( pSnoBlockClassName ) {
		fprintf( pFile, "%sDeletion( %s );\n", pTab, pSnoBlockMemberVarName );
	}
	else {
		fprintf( pFile, "%sDeletion();\n", pTab );
	}

	fprintf( pFile, "\n}\n" );

}


/******************************************************************************
 *
 * Description:  Generates the Creation(), Deletion(), PreActivity() and 
 *   PostActivity(), and all Private User functions.
 *
 * Remarks:  This function writes the Creation(), Deletion(), PreActivity()
 *   and PostActivity() functions to the file sent as an argument.
 *
 * Inputs:
 *   pFile - Pointer to the file to write data to.
 *   pSm   - Pointer to the state machine information from which to generate
 *           the description.
 *   pBaseSnoBlockClassName - Name of the base sno block class.
 *   pSnoBlockClassName     - Name of the sno block class for this HCSM.
 *
 * Returns:
 *
 */
static void GenClassFunctions(
			FILE* pFile, 
			TStateMachine* pSm, 
			char* pBaseSnoBlockClassName,
			char* pSnoBlockClassName
			)
{

	static char* pBaseSnoBlockVarName = "pBaseSnoBlock";
	static char* pTab = "    ";      /* simulates a tab character            */
	static char* pSnoBlockVarName = "pSnoBlock";

	/*
	 * Print the Creation function.
	 */
	if ( pSm->create_cb ) {

		TStringPair* pFunc;

		if ( pSnoBlockClassName ) {
			fprintf( pFile, "void C%s::Creation( const %s* %s )\n", 
					 pSm->name, pBaseSnoBlockClassName, pBaseSnoBlockVarName );
		}
		else {
			fprintf( pFile, "void C%s::Creation()\n", pSm->name );
		}
		fprintf( pFile, "{\n\n" );

		if ( pSnoBlockClassName ) {
			/*
			 * Generate dynamic cast from general to specific sno block.
			 */
			fprintf( pFile, "%sconst %s* ", pTab, pSnoBlockClassName );
			fprintf( pFile, "%s = dynamic_cast",  pSnoBlockVarName );
			fprintf( pFile, "<const %s*>", pSnoBlockClassName );
			fprintf( pFile, "(%s);\n", pBaseSnoBlockVarName );
		}

		pFunc = LookupStrPair( m_pIn->crcb_list, pSm->create_cb );
		if ( !pFunc )  INT_ERROR( pSm->name );

		fprintf( pFile, "%s", pFunc->pValue );

		fprintf( pFile, "\n}\n" );
		fprintf( pFile, "\n" );

	}

	/*
	 * Print the Deletion function.
	 */
	if ( pSm->delete_cb ) {

		TStringPair* pFunc;

		if ( pSnoBlockClassName ) {
			fprintf( pFile, "void C%s::Deletion( const %s* %s )\n", 
					 pSm->name, pBaseSnoBlockClassName, pBaseSnoBlockVarName );
		}
		else {
			fprintf( pFile, "void C%s::Deletion()\n", pSm->name );
		}
		fprintf( pFile, "{\n\n" );

		if ( pSnoBlockClassName ) {		
			/*
			 * Generate dynamic cast from general to specific sno block.
			 */
			fprintf( pFile, "%sconst %s* ", pTab, pSnoBlockClassName );
			fprintf( pFile, "%s = dynamic_cast",  pSnoBlockVarName );
			fprintf( pFile, "<const %s*>", pSnoBlockClassName );
			fprintf( pFile, "(%s);\n", pBaseSnoBlockVarName );
		}

		pFunc = LookupStrPair( m_pIn->decb_list, pSm->delete_cb );
		if ( !pFunc )  INT_ERROR( pSm->name );

		fprintf( pFile, "%s", pFunc->pValue );

		fprintf( pFile, "\n}\n" );
		fprintf( pFile, "\n" );

	}

	/*
	 * Print the PreActivity function.
	 */
	if ( pSm->pre_activity ) {

		TStringPair* pFunc;

		if ( pSnoBlockClassName ) {
			fprintf( pFile, "void C%s::PreActivity( const %s* %s )\n", 
					 pSm->name, pBaseSnoBlockClassName, pBaseSnoBlockVarName );
		}
		else {
			fprintf( pFile, "void C%s::PreActivity()\n", pSm->name );
		}
		fprintf( pFile, "{\n\n" );

		if ( pSnoBlockClassName ) {
			/*
			 * Generate dynamic cast from general to specific sno block.
			 */
			fprintf( pFile, "%sconst %s* ", pTab, pSnoBlockClassName );
			fprintf( pFile, "%s = dynamic_cast",  pSnoBlockVarName );
			fprintf( pFile, "<const %s*>", pSnoBlockClassName );
			fprintf( pFile, "(%s);\n", pBaseSnoBlockVarName );
		}

		pFunc = LookupStrPair( m_pIn->pre_actv_list, pSm->pre_activity );
		if ( !pFunc )  INT_ERROR( pSm->name );

		fprintf( pFile, "%s", pFunc->pValue );

		fprintf( pFile, "\n}\n" );
		fprintf( pFile, "\n" );

	}

	/*
	 * Print the PostActivity function.
	 */
	if ( pSm->post_activity ) {

		TStringPair* pFunc;

		if ( pSnoBlockClassName ) {
		fprintf( pFile, "void C%s::PostActivity( const %s* %s )\n", 
				 pSm->name, pBaseSnoBlockClassName, pBaseSnoBlockVarName );
		}
		else {
			fprintf( pFile, "void C%s::PostActivity()\n", pSm->name );
		}
		fprintf( pFile, "{\n\n" );

		if ( pSnoBlockClassName ) {
			/*
			 * Generate dynamic cast from general to specific sno block.
			 */
			fprintf( pFile, "%sconst %s* ", pTab, pSnoBlockClassName );
			fprintf( pFile, "%s = dynamic_cast",  pSnoBlockVarName );
			fprintf( pFile, "<const %s*>", pSnoBlockClassName );
			fprintf( pFile, "(%s);\n", pBaseSnoBlockVarName );
		}

		pFunc = LookupStrPair( m_pIn->post_actv_list, pSm->post_activity );
		if ( !pFunc )  INT_ERROR( pSm->name );

		fprintf( pFile, "%s", pFunc->pValue );

		fprintf( pFile, "\n}\n" );
		fprintf( pFile, "\n" );

	}

}


/******************************************************************************
 *
 * Name:  GenExecuteTransitions
 *
 * Generates the ExecutePredicates function.
 *
 * Inputs:
 *   pFile     -- Pointer to the file to write data to.
 *   pSm       -- Pointer to SM on SM list in parser data structures.
 *
 */
static void GenExecuteTransitions( 
			FILE*  pFile, 
			TStateMachine*  pSm
			)
{

	static char*   pActiveChildVarName = "m_activeChild";
	static char*   pChildrenArrName = "m_children";
	static char*   pTab = "    ";   /* simulates a tab character            */

	TTransition*   pTrans;          /* pointer to an hcsm's transitions     */

	/*
	 * Print the function prototype.
	 */
	fprintf( pFile, "void C%s::ExecuteTransitions()\n", pSm->name );
	fprintf( pFile, "{\n\n" );
	
	/*
	 * Print the function body.
	 */
	for ( pTrans = pSm->trans; pTrans; pTrans = pTrans->pNext ) {

		int             headHcsmPosition;
		int             tailHcsmPosition;
		TPredicate*     pPredFunc;
		TStateMachine*  pHeadHcsm;
		TStateMachine*  pTailHcsm;

		/* find the position of the head hcsm in the children list */
		pHeadHcsm = LookupSm( m_pIn->sm_list, pTrans->pHeadName );
		if ( pHeadHcsm == NULL )  INT_ERROR( pTrans->pHeadName );
		headHcsmPosition = LookupSmPos( pSm->children, pTrans->pHeadName );
		if ( headHcsmPosition < 0 )  INT_ERROR( pTrans->pHeadName );

		/* find the position of the tail hcsm in the children list */
		pTailHcsm = LookupSm( m_pIn->sm_list, pTrans->pTailName );
		if ( pTailHcsm == NULL )  INT_ERROR( pTrans->pTailName );
		tailHcsmPosition = LookupSmPos( pSm->children, pTrans->pTailName );
		if ( tailHcsmPosition < 0 )  INT_ERROR( pTrans->pTailName );

		/* find the predicate function id in the head hcsm's predicate list */
		pPredFunc = LookupPred( pHeadHcsm->pred, pTrans->pPredName );
		if ( pPredFunc == NULL )  INT_ERROR( pTrans->pPredName );

		/* print clause with the transition */
		fprintf( pFile, "%s// from \"%s\" to \"%s\"\n", pTab, pHeadHcsm->name,
				 pTailHcsm->name );
		fprintf( pFile, "%sif ( %s == %s[%d] && ", pTab, pActiveChildVarName, 
				 pChildrenArrName, headHcsmPosition );
		fprintf( pFile, "%s[%d]->ExecutePredicate( %d ) ) {\n", pChildrenArrName,
				 headHcsmPosition, pPredFunc->id );
		fprintf( pFile, "%s%s\n", pTab, pTab );
		fprintf( pFile, "%s%s%s = %s[%d];\n", pTab, pTab, pActiveChildVarName,
				 pChildrenArrName, tailHcsmPosition );
		fprintf( pFile, "%s%sreturn;\n", pTab, pTab );
		fprintf( pFile, "%s%s\n", pTab, pTab );
		fprintf( pFile, "%s}\n", pTab );
		fprintf( pFile, "\n" );

	}

	fprintf( pFile, "}\n" );

}


/******************************************************************************
 *
 * Name:  GenExecutePredicate
 *
 * Generates the ExecutePredicate function.
 *
 * Inputs:
 *   pFile     -- Pointer to the file to write data to.
 *   pHcsmName -- The HCSM template's name.
 *   pPred     -- Pointer to predicate function list.
 *
 */
static void GenExecutePredicate( 
			FILE*  pFile, 
			char* pHcsmName, 
			TPredicate* pPred 
			)
{

	static char*   pInputArgName = "functionId";
	static char*   pTab = "    ";   /* simulates a tab character            */

	/*
	 * Print the function prototype.
	 */
	fprintf( pFile, "bool C%s::ExecutePredicate( int %s )\n", 
			 pHcsmName, pInputArgName );
	fprintf( pFile, "{\n\n" );
	
	/*
	 * Print the function body.
	 */
	if ( pPred ) {

		/* print clause associated with first predicate on list */
		fprintf( pFile, "%sif ( %s == %d ) {\n", pTab, pInputArgName, 
				 pPred->id );
		fprintf( pFile, "%s%s\n", pTab, pTab );
		fprintf( pFile, "%s%sreturn %s();\n", pTab, pTab, pPred->pName );
		fprintf( pFile, "%s%s\n", pTab, pTab );
		fprintf( pFile, "%s}\n", pTab );

		/* print clauses associated with second thru last predicates on list */
		for ( pPred = pPred->pNext; pPred; pPred = pPred->pNext ) {

			fprintf( pFile, "%selse if ( %s == %d ) {\n", pTab, pInputArgName, 
					 pPred->id );
			fprintf( pFile, "%s%s\n", pTab, pTab );
			fprintf( pFile, "%s%sreturn %s();\n", pTab, pTab, pPred->pName );
			fprintf( pFile, "%s%s\n", pTab, pTab );
			fprintf( pFile, "%s}\n", pTab );
			
		}

		/* print the else clause for protection */
		fprintf( pFile, "%selse {\n", pTab );
		fprintf( pFile, "%s%s\n", pTab, pTab );
		fprintf( pFile, "%s%s// unknown function id\n", pTab, pTab );
		fprintf( pFile, "%s%sreturn false;\n", pTab, pTab ); 
		fprintf( pFile, "%s%s\n", pTab, pTab );
		fprintf( pFile, "%s}\n", pTab );

	}

	fprintf( pFile, "\n}\n" );

}


/******************************************************************************
 *
 * Name:  GenPredicateFunctions
 *
 * Generates the predicate function(s).
 *
 * Inputs:
 *   pFile     -- Pointer to the file to write data to.
 *   pHcsmName -- The HCSM template's name.
 *   pPred     -- Pointer to predicate function list.
 *
 */
static void GenPredicateFunctions( 
			FILE*  pFile, 
			char* pHcsmName, 
			TPredicate* pPred 
			)
{

	/*
	 * Parse through the list and generate zero or predicate functions
	 * for this class.
	 */
	for (  ; pPred; pPred = pPred->pNext ) {
		
		TStringPair* pPredPair;

		pPredPair = LookupStrPair( m_pIn->pred_list, pPred->pName );
		if ( !pPredPair )  INT_ERROR( pPred->pName );

		/*
		 * Print the function prototype.
		 */
		fprintf( pFile, "bool C%s::%s()\n", pHcsmName, pPred->pName );
		fprintf( pFile, "{\n\n" );
	
		/*
		 * Print the function body.
		 */
		fprintf( pFile, "%s", pPredPair->pValue );

		fprintf( pFile, "\n}\n" );

	}

}


/******************************************************************************
 *
 * Description: Generates the class member functions that set and get 
 *   HCSM input parameters.
 *
 * Remarks:  For a given state machine, this function generates the accessor
 *   functions for all of that state machine's input parameters.
 *
 * Arugments:
 *   pFile                -- Pointer to the file to write data to.
 *   pSm                  -- Pointer to SM on SM list in parser data 
 *                           structures.
 *
 * Returns:
 *
 */
static void GenClassInputParameter( FILE* pFile, TStateMachine* pSm )
{

	static char*   pTab = "    ";   /* simulates a tab character            */
	static char*   pAccessorName = "GetInput"; /* the accessor func's name  */
	static char*   pMutatorName  = "SetInput"; /* the mutator func's name   */

	int            childIndex;      /* index of child in children array     */
	TStringNode*   pNode;           /* pointer to child state machine node  */
	TStringPair*   pInput;          /* pointer to input parameter str pair  */

	/*
	 * For all the input parameters in this state machine, generate
	 * the GetLocalXxx accessor functions Xxx represents the input
	 * parameter's name.  Generate the associated HasValue functions
	 * also.
	 */
	for ( pInput = pSm->inputs; pInput; pInput = pInput->pNext ) {

		/* 
		 * Generate the accessor function.
		 */
		fprintf( pFile, "%s C%s::%s%s()\n", pInput->pValue,
				 pSm->name, pAccessorName, pInput->pName );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sreturn m_input%s.GetValue();\n", pTab,
				 pInput->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

		/* 
		 * Generate the HasValue function.
		 */
		fprintf( pFile, "bool C%s::HasValueInput%s()\n", 
				 pSm->name, pInput->pName );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sreturn m_input%s.HasValue();\n", pTab,
				 pInput->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

		/* 
		 * Generate the mutator function.
		 */
		fprintf( pFile, "void C%s::%s%s( %s value )\n",  pSm->name,
				 pMutatorName, pInput->pName, pInput->pValue );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sm_input%s.SetValue( value );\n", pTab,
				 pInput->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

	}

	/* 
	 * Generate mutator functions for each child's input parameters.
	 * The mutator function has the form:  SetInputXxxForYyy where 
	 * Xxx is the input's name and Yyy is the child's name which 
	 * contains the input parameter.
	 */
	childIndex = 0;
	for ( pNode = pSm->children; pNode; pNode = pNode->pNext ) {

		TStateMachine* pChildSm;  /* pointer to child state machine */

		pChildSm = LookupSm( m_pIn->sm_list, pNode->pName );

		for ( pInput = pChildSm->inputs; pInput; pInput = pInput->pNext ) {

			fprintf( pFile, "void C%s::%s%sFor%s( %s value )\n",  pSm->name,
					 pMutatorName, pInput->pName, pChildSm->name, 
					 pInput->pValue );
			fprintf( pFile, "{\n" );
			fprintf( pFile, "\n" );

			fprintf( pFile, "%s( dynamic_cast<C%s*>(m_children[%d]) )", pTab,
					 pChildSm->name, childIndex );
			fprintf( pFile, "->SetInput%s( value );\n", pInput->pName );

			fprintf( pFile, "\n" );
			fprintf( pFile, "}\n" );
			fprintf( pFile, "\n" );

		}

		childIndex++;

	}

}


/******************************************************************************
 *
 * Description: Generates the class member functions that set and get 
 *   HCSM local variables.
 *
 * Remarks:  For a given state machine, this function generates the accessor
 *   and mutator functions for all of that state machine's local variables.
 *
 * Arugments:
 *   pFile                -- Pointer to the file to write data to.
 *   pSm                  -- Pointer to SM on SM list in parser data 
 *                           structures.
 *
 * Returns:
 *
 */
static void GenClassLocalVariable( FILE* pFile, TStateMachine* pSm )
{

	static char*   pTab = "    ";   /* simulates a tab character            */
	static char*   pAccessorName = "GetLocal"; /* the accessor func's name  */
	static char*   pMutatorName  = "SetLocal"; /* the mutator func's name   */

	TStringPair*   pLocal;          /* pointer to local variable str pair   */

	/*
	 * For all the local variables in this state machine, generate
	 * the GetLocalXxx and SetLocalXxx functions where Xxx represents
	 * the local variable's name.
	 */
	for ( pLocal = pSm->locals; pLocal; pLocal = pLocal->pNext ) {

		/* 
		 * Generate the accessor function.
		 */
		fprintf( pFile, "%s C%s::%s%s()\n", pLocal->pValue,
				 pSm->name, pAccessorName, pLocal->pName );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sreturn m_local%s.GetValue();\n", pTab,
				 pLocal->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

		/* 
		 * Generate the mutator function.
		 */
		fprintf( pFile, "void C%s::%s%s( %s value )\n",  pSm->name,
				 pMutatorName, pLocal->pName, pLocal->pValue );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sm_local%s.SetValue( value );\n", pTab,
				 pLocal->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

	}

}


/******************************************************************************
 *
 * Description: Generates the class member functions that set HCSM 
 *   output parameters.
 *
 * Remarks:  For a given state machine, this function generates the mutator
 *   functions for that state machine's output parameters.
 *
 * Arugments:
 *   pFile                -- Pointer to the file to write data to.
 *   pSm                  -- Pointer to SM on SM list in parser data 
 *                           structures.
 *
 * Returns:
 *
 */
static void GenClassOutputParameter( FILE* pFile, TStateMachine* pSm )
{

	static char*   pTab = "    ";   /* simulates a tab character            */
	static char*   pAccessorName = "GetOutput"; /* the accessor func's name */
	static char*   pMutatorName  = "SetOutput"; /* the mutator func's name  */

	int            childIndex;      /* index of child in children array     */
	TStringNode*   pNode;           /* pointer to child state machine node  */
	TStringPair*   pOutput;         /* pointer to output parameter str pair  */

	/*
	 * For all the output parameters in this state machine, generate
	 * the SetOutputXxx functions where Xxx represents the output
	 * parameter's name.  Generate associated HasValue functions also.
	 */
	for ( pOutput = pSm->outputs; pOutput; pOutput = pOutput->pNext ) {

		/* 
		 * Generate the accessor function.
		 */
		fprintf( pFile, "%s C%s::%s%s()\n", pOutput->pValue,
				 pSm->name, pAccessorName, pOutput->pName );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sreturn m_output%s.GetValue();\n", pTab,
				 pOutput->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

		/* 
		 * Generate the HasValue function.
		 */
		fprintf( pFile, "bool C%s::HasValueOutput%s()\n", 
				 pSm->name, pOutput->pName );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sreturn m_output%s.HasValue();\n", pTab,
				 pOutput->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

		/* 
		 * Generate the mutator function.
		 */
		fprintf( pFile, "void C%s::%s%s( %s value )\n",  pSm->name,
				 pMutatorName, pOutput->pName, pOutput->pValue );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sm_output%s.SetValue( value );\n", pTab,
				 pOutput->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

		/* 
		 * Generate the mutator SetNoValue function.
		 */
		fprintf( pFile, "void C%s::%s%sNoValue()\n", pSm->name,
				 pMutatorName, pOutput->pName );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sm_output%s.SetNoValue();\n", 
				 pTab, pOutput->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

	}

	/* 
	 * Generate accessor functions for each child's output parameters.
	 * The accessor function has the form:  GetOutputXxxFromYyy where 
	 * Xxx is the output's name and Yyy is the child's name which 
	 * contains the output parameter.
	 *
	 * Also generate a function that indicates whether the child's 
	 * output parameter has a valid value.  This function will have 
	 * the form: HasValueOutputXxxFromYyy.
	 */
	childIndex = 0;
	for ( pNode = pSm->children; pNode; pNode = pNode->pNext ) {

		TStateMachine* pChildSm;  /* pointer to child state machine */

		pChildSm = LookupSm( m_pIn->sm_list, pNode->pName );

		for ( pOutput = pChildSm->outputs; pOutput; pOutput = pOutput->pNext ) {

			/*
			 * Generating accessor function.
			 */
			fprintf( pFile, "%s C%s::%s%sFrom%s()\n", 
					 pOutput->pValue, pSm->name, pAccessorName, pOutput->pName, 
					 pChildSm->name );
			fprintf( pFile, "{\n" );
			fprintf( pFile, "\n" );

			fprintf( pFile, "%sreturn ( dynamic_cast<C%s*>(m_children[%d]) )", pTab,
					 pChildSm->name, childIndex );
			fprintf( pFile, "->GetOutput%s();\n", pOutput->pName );

			fprintf( pFile, "\n" );
			fprintf( pFile, "}\n" );
			fprintf( pFile, "\n" );

			/*
			 * Generating has value function.
			 */
			fprintf( pFile, "bool C%s::HasValueOutput%sFrom%s()\n", 
					 pSm->name, pOutput->pName, pChildSm->name );
			fprintf( pFile, "{\n" );
			fprintf( pFile, "\n" );

			fprintf( pFile, "%sreturn ( dynamic_cast<C%s*>(m_children[%d]) )", pTab,
					 pChildSm->name, childIndex );
			fprintf( pFile, "->HasValueOutput%s();\n", pOutput->pName );

			fprintf( pFile, "\n" );
			fprintf( pFile, "}\n" );
			fprintf( pFile, "\n" );

		}

		childIndex++;

	}

}


/******************************************************************************
 *
 * Description: Generates the class member functions that set and get 
 *   HCSM buttons.
 *
 * Remarks:  For a given state machine, this function generates the accessor
 *   and mutator functions for all of that state machine's buttons.
 *
 * Arugments:
 *   pFile                -- Pointer to the file to write data to.
 *   pSm                  -- Pointer to SM on SM list in parser data 
 *                           structures.
 *
 * Returns:
 *
 */
static void GenClassButton( FILE* pFile, TStateMachine* pSm )
{

	static char*   pTab = "    ";   /* simulates a tab character            */
	static char*   pAccessorName = "GetButton"; /* the accessor func's name */

	TStringPair*   pButton;         /* pointer to button string node        */

	/*
	 * For all the buttons in this state machine, generate the 
	 * GetButtonXxx and SetButtonXxx functions where Xxx represents
	 * the button's name.
	 */
	for ( pButton = pSm->buttons; pButton; pButton = pButton->pNext ) {

		/* 
		 * Generate the accessor function.
		 */
		fprintf( pFile, "bool C%s::%s%s()\n", pSm->name, 
				 pAccessorName, pButton->pName );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sreturn m_button%s.IsButtonPressed();\n", pTab,
				 pButton->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

	}

	/*
	 * Generate the mutator function to enable button sets if this class
	 * contains buttons.
	 */
	if ( pSm->buttons ) {

		fprintf( pFile, "bool C%s::SetButtonByName", pSm->name );
		fprintf( pFile, "( const string& buttonName )\n" );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		for ( pButton = pSm->buttons; pButton; pButton = pButton->pNext ) {

			fprintf( pFile, "%sif ( buttonName == m_button", pTab );
			fprintf( pFile, "%s.GetName() ) {\n", pButton->pName );
			fprintf( pFile, "%s%s\n", pTab, pTab );
			fprintf( pFile, "%s%sm_button%s.PressButton();\n", pTab, pTab,
					 pButton->pName );
			fprintf( pFile, "%s%sreturn true;\n", pTab, pTab );
			fprintf( pFile, "%s%s\n", pTab, pTab );
			fprintf( pFile, "%s}\n", pTab );

			fprintf( pFile, "%s\n", pTab );

		}

		fprintf( pFile, "%sreturn false;\n", pTab );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

	
	}
}


/******************************************************************************
 *
 * Description: Generates the class member functions that set and get 
 *   HCSM dials.
 *
 * Remarks:  For a given state machine, this function generates the accessor
 *   and mutator functions for all of that state machine's dials.
 *
 * Arugments:
 *   pFile                -- Pointer to the file to write data to.
 *   pSm                  -- Pointer to SM on SM list in parser data 
 *                           structures.
 *
 * Returns:
 *
 */
static void GenClassDial( FILE* pFile, TStateMachine* pSm )
{

	static char*   pTab = "    ";   /* simulates a tab character            */
	static char*   pAccessorName = "GetDial"; /* the accessor func's name   */
	static char*   pMutatorName  = "SetDial"; /* the mutator func's name    */

	TStringPair*   pDial;          /* pointer to dial string pair           */
	TStringPair *pNode;
	TStringPair *pUniqueDialTypeList = BuildUniqueDialTypeList();

	/*
	 * For all the dials in this state machine, generate the 
	 * GetDialXxx and SetDialXxx functions where Xxx represents
	 * the dial's name.
	 */
	for ( pDial = pSm->dials; pDial; pDial = pDial->pNext ) {

		/* 
		 * Generate the accessor function.
		 */
		fprintf( pFile, "%s C%s::%s%s()\n", pDial->pValue,
				 pSm->name, pAccessorName, pDial->pName );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sreturn m_dial%s.GetValue();\n", pTab,
				 pDial->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

		/* 
		 * Generate the mutator function.
		 */
		fprintf( pFile, "void C%s::%s%s( %s value )\n",  pSm->name,
				 pMutatorName, pDial->pName, pDial->pValue );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sm_dial%s.SetValue( value );\n", pTab,
				 pDial->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

		/* 
		 * Generate the SetNoValue function.
		 */
		fprintf( pFile, "void C%s::%s%sNoValue()\n",  pSm->name,
				 pMutatorName, pDial->pName );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sm_dial%s.SetNoValue();\n", 
				 pTab, pDial->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

	}

	
	if ( pSm->dials ) {


		/* 
		 * Generate a mutator function for each dial type.
		 */
		for ( pNode = pUniqueDialTypeList; pNode; pNode = pNode->pNext ) {

			fprintf( pFile, "bool C%s::SetDialByName", pSm->name );
			fprintf( pFile, "( const string& dialName, " );
			fprintf( pFile, "const %s& value )\n", pNode->pName );
			fprintf( pFile, "{\n" );
			fprintf( pFile, "\n" );

			for ( pDial = pSm->dials; pDial; pDial = pDial->pNext ) {

				/*
				 * Only check for dials that have the same type as the
				 * type that this generated function accepts.
				 */
				if ( !strcmp( pDial->pValue, pNode->pName ) ) {

					fprintf( pFile, "%sif ( dialName == m_dial", pTab );
					fprintf( pFile, "%s.GetName() ) {\n", pDial->pName );
					fprintf( pFile, "%s%s\n", pTab, pTab );
					fprintf( pFile, "%s%sm_dial%s.SetValue( value );\n", 
						pTab, pTab, pDial->pName );
					fprintf( pFile, "%s%sreturn true;\n", pTab, pTab );
					fprintf( pFile, "%s%s\n", pTab, pTab );
					fprintf( pFile, "%s}\n", pTab );

				}

			}

			fprintf( pFile, "%s\n", pTab );
			fprintf( pFile, "%sreturn false;\n", pTab );

			fprintf( pFile, "\n" );
			fprintf( pFile, "}\n" );
			fprintf( pFile, "\n" );

		}

		/* 
		 * Generate a mutator function that takes a string parameter
		 */
		fprintf( pFile, "bool C%s::SetDialByNameStr", pSm->name );
		fprintf( pFile, "( const string& dialName, " );
		fprintf( pFile, "const string& value )\n" );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		for ( pDial = pSm->dials; pDial; pDial = pDial->pNext ) {

			fprintf( pFile, "%sif ( dialName == m_dial", pTab );
			fprintf( pFile, "%s.GetName() ) {\n", pDial->pName );
			fprintf( pFile, "%s%s\n", pTab, pTab );
			fprintf( pFile, "%s%sm_dial%s.SetValueStr( value );\n", 
				pTab, pTab, pDial->pName );
			fprintf( pFile, "%s%sreturn true;\n", pTab, pTab );
			fprintf( pFile, "%s%s\n", pTab, pTab );
			fprintf( pFile, "%s}\n", pTab );

		}

		fprintf( pFile, "%s\n", pTab );
		fprintf( pFile, "%sreturn false;\n", pTab );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

		/* 
		 * Generate a mutator function that takes a string parameter
		 */
		fprintf( pFile, "bool C%s::IsDialActiveByNameStr", pSm->name );
		fprintf( pFile, "( const string& dialName )\n" );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		for ( pDial = pSm->dials; pDial; pDial = pDial->pNext ) {

			fprintf( pFile, "%sif ( dialName == m_dial", pTab );
			fprintf( pFile, "%s.GetName() ) {\n", pDial->pName );
			fprintf( pFile, "%s%s\n", pTab, pTab );
			fprintf( pFile, "%s%sreturn m_dial%s.HasValue();\n", 
				pTab, pTab, pDial->pName );
			fprintf( pFile, "%s%s\n", pTab, pTab );
			fprintf( pFile, "%s}\n", pTab );

		}

		fprintf( pFile, "%s\n", pTab );
		fprintf( pFile, "%sreturn false;\n", pTab );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

		/*
		 * Generate a function that resets the dial.
		 */
		fprintf( pFile, "bool C%s::ResetDialByName", pSm->name );
		fprintf( pFile, "( const string& dialName )\n" );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		for ( pDial = pSm->dials; pDial; pDial = pDial->pNext ) {

			fprintf( pFile, "%sif ( dialName == m_dial", pTab );
			fprintf( pFile, "%s.GetName() ) {\n", pDial->pName );
			fprintf( pFile, "%s%s\n", pTab, pTab );
			fprintf( pFile, "%s%sm_dial%s.Reset();\n", pTab, pTab, pDial->pName );
			fprintf( pFile, "%s%sreturn true;\n", pTab, pTab );
			fprintf( pFile, "%s%s\n", pTab, pTab );
			fprintf( pFile, "%s}\n", pTab );

		}

		fprintf( pFile, "%s\n", pTab );
		fprintf( pFile, "%sreturn false;\n", pTab );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );
	}
}


/******************************************************************************
 *
 * Description: Generates the class member functions that set and get 
 *   HCSM monitors.
 *
 * Remarks:  For a given state machine, this function generates the accessor
 *   and mutator functions for all of that state machine's monitors.
 *
 * Arugments:
 *   pFile                -- Pointer to the file to write data to.
 *   pSm                  -- Pointer to SM on SM list in parser data 
 *                           structures.
 *
 * Returns:
 *
 */
static void GenClassMonitor( FILE* pFile, TStateMachine* pSm )
{

	static char*   pTab = "    ";   /* simulates a tab character            */
	static char*   pAccessorName = "GetMonitor"; /* the accessor func's name*/
	static char*   pMutatorName  = "SetMonitor"; /* the mutator func's name */

	TStringPair*   pMonitor;       /* pointer to monitor str pair           */

	/*
	 * For all the monitors in this state machine, generate the 
	 * GetMonitorXxx and SetMonitorXxx functions where Xxx represents
	 * the monitor's name.
	 */
	for ( pMonitor = pSm->monitors; pMonitor; pMonitor = pMonitor->pNext ) {

		/* 
		 * Generate the accessor function.
		 */
		fprintf( pFile, "%s C%s::%s%s()\n", pMonitor->pValue,
				 pSm->name, pAccessorName, pMonitor->pName );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sreturn m_monitor%s.GetValue();\n", pTab,
				 pMonitor->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

		/* 
		 * Generate the mutator function.
		 */
		fprintf( pFile, "void C%s::%s%s( %s value )\n",  pSm->name,
				 pMutatorName, pMonitor->pName, pMonitor->pValue );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sm_monitor%s.SetValue( value );\n", pTab,
				 pMonitor->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

		/* 
		 * Generate the mutator no value function.
		 */
		fprintf( pFile, "void C%s::%s%sNoValue()\n",  pSm->name,
				 pMutatorName, pMonitor->pName );
		fprintf( pFile, "{\n" );
		fprintf( pFile, "\n" );

		fprintf( pFile, "%sm_monitor%s.SetNoValue();\n", pTab,
				 pMonitor->pName );

		fprintf( pFile, "\n" );
		fprintf( pFile, "}\n" );
		fprintf( pFile, "\n" );

	}

	if ( pSm->monitors ) {

		TStringPair *pNode;
		TStringPair *pUniqueMonitorTypeList = BuildUniqueMonitorTypeList();

		/* 
		 * Generate an accessor function for each monitor type.
		 */
		for ( pNode = pUniqueMonitorTypeList; pNode; pNode = pNode->pNext ) {

			fprintf( pFile, "bool C%s::GetMonitorByName", pSm->name );
			fprintf( pFile, "( const string& monitorName, " );
			fprintf( pFile, "%s* pValue )\n", pNode->pName );
			fprintf( pFile, "{\n" );
			fprintf( pFile, "\n" );

			for ( pMonitor = pSm->monitors; pMonitor; pMonitor = pMonitor->pNext ) {

				/*
				 * Only check for monitors that have the same type as the
				 * type that this generated function accepts.
				 */
				if ( !strcmp( pMonitor->pValue, pNode->pName ) ) {

					fprintf( pFile, "%sif ( monitorName == m_monitor", pTab );
					fprintf( pFile, "%s.GetName() ) {\n", pMonitor->pName );
					fprintf( pFile, "%s%s\n", pTab, pTab );
					fprintf( pFile, "%s%sbool retVal = m_monitor%s.HasValue();\n",
							 pTab, pTab, pMonitor->pName );
					fprintf( pFile, "%s%sif ( retVal ) {\n", pTab, pTab );
					fprintf( pFile, "%s%s%s*pValue = m_monitor%s.GetValue();\n", 
							 pTab, pTab, pTab, pMonitor->pName );
					fprintf( pFile, "%s%s}\n", pTab, pTab );
					fprintf( pFile, "%s%s\n", pTab, pTab );
					fprintf( pFile, "%s%sreturn retVal;\n", pTab, pTab );
					fprintf( pFile, "%s%s\n", pTab, pTab );
					fprintf( pFile, "%s}\n", pTab );

					fprintf( pFile, "%s\n", pTab );

				}

			}

			fprintf( pFile, "%sreturn false;\n", pTab );

			fprintf( pFile, "\n" );
			fprintf( pFile, "}\n" );
			fprintf( pFile, "\n" );
		}


	}

}


/******************************************************************************
 *
 * Name:  GenClassImplementation
 *
 * Generates the state machine c++ implementation file.  The implementation 
 * file contains class implementations.
 *
 * Inputs:
 *   pFile -- Pointer to the file to write data to.
 *
 */
static void GenClassImplementation( FILE* pFile )
{

	static char*   pCollectionName = "CHcsmCollection";
	static char*   pConcurrentName = "CHcsmConcurrent";
	static char*   pSequentialName = "CHcsmSequential";
	static char*   pSnoBlockClassName = "CSnoBlock";
	static char*   pSnoBlockMemberVarName = "m_pSnoBlock";

	TStateMachine* pSm;             /* pointer to SM on SM list             */


	/*
	 * Print the preamble.
	 */
	fprintf( pFile, m_pHeaderPreamble1 );

	/*
	 * Print the include for the header file.
	 */
	fprintf( pFile, "#include \"%s\"\n", SM_CLASS_HEADER_FILE );
	fprintf( pFile, "\n" );

	/*
	 * Print the class implementations.
	 */
	for ( pSm = m_pIn->sm_list; pSm; pSm = pSm->next ) {

		char*   pSnoParserClassName;
		char*   pParentName;
		EBool   isConcurrent;

		pSnoParserClassName = GetSnoParserClassFromHcsmName( pSm->name );
		
		/* figure out if this is concurrent or sequential hcsm */
		if ( pSm->trans ) {

			/* sm has transitions and therefore is sequential */
			isConcurrent = eFALSE;
			pParentName  = pSequentialName;

		}
		else {

			/* concurrent */
			isConcurrent = eTRUE;
			pParentName  = pConcurrentName;

		}

		/*
		 * Print the main constructor.
		 */
		GenClassConstructor( 
					pFile, 
					pParentName, 
					pCollectionName, 
					pSm,
					pSnoParserClassName, 
					pSnoBlockMemberVarName 
					);
		fprintf( pFile, "\n" );

		/*
		 * Print the copy constructor.
		 */
		GenClassCopyConstructor( 
					pFile, 
					pSm, 
					pParentName, 
					pSnoParserClassName, 
					pSnoBlockMemberVarName 
					);
		fprintf( pFile, "\n" );

		/*
		 * Print the assignment operator.
		 */
		GenClassAssignmentOperator( pFile, pSm->name );
		fprintf( pFile, "\n" );

		/*
		 * Print the destructor.
		 */
		GenClassDestructor( 
					pFile, 
					pSm->name, 
					pSnoParserClassName, 
					pSnoBlockMemberVarName 
					);
		fprintf( pFile, "\n" );

		/*
		 * Print the Creation, Deletion, PreActivity and PostActivity functions.
		 */
		GenClassFunctions( pFile, pSm, pSnoBlockClassName, pSnoParserClassName );

		/*
		 * Print the ExecuteTransitions() memeber.
		 */
		if ( !isConcurrent ) {

			GenExecuteTransitions( pFile, pSm );
			fprintf( pFile, "\n" );

		}

		/*
		 * Print the ExecutePredicate() member.
		 */
		if ( pSm->pred ) {
			
			GenExecutePredicate( pFile, pSm->name, pSm->pred );
			fprintf( pFile, "\n" );
			GenPredicateFunctions( pFile, pSm->name, pSm->pred );
			fprintf( pFile, "\n" );

		}

		/*
		 * Print the accessor and mutator functions for input parameters.
		 */
		GenClassInputParameter( pFile, pSm );

		/*
		 * Print the accessor and mutator functions for local variables.
		 */
		GenClassLocalVariable( pFile, pSm );

		/*
		 * Print the accessor and mutator functions for output parameters.
		 */
		GenClassOutputParameter( pFile, pSm );

		/*
		 * Print the accessor and mutator functions for buttons.
		 */
		GenClassButton( pFile, pSm );

		/*
		 * Print the accessor and mutator functions for dials.
		 */
		GenClassDial( pFile, pSm );

		/*
		 * Print the accessor and mutator functions for monitors.
		 */
		GenClassMonitor( pFile, pSm );
	}


}


/******************************************************************************
 *
 * Name:  GenerateButtonDialHeader
 *
 * Generates button dial header information.
 *
 * Inputs:
 *   pGenButtonDialHeaderFile - The header file.
 *
 */
static void GenButtonDialHeader( FILE* pFile )
{
	fprintf( pFile, m_pHeaderPreamble1 );
	fprintf( pFile, "#ifndef __BUTTON_DIAL_INFO_H_\n" );
	fprintf( pFile, "#define __BUTTON_DIAL_INFO_H_\n\n" );
	fprintf( pFile, "#include <string>\n" );
	fprintf( pFile, "#include <vector>\n" );
	fprintf( pFile, "using namespace std;\n" );
	fprintf( pFile, "\n" );

	fprintf( pFile, "typedef struct TDialParam\n" );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\tstring m_name;\n" );
	fprintf( pFile, "\tstring m_dataType;\n" );
	fprintf( pFile, "\tstring m_units;\n" );
	fprintf( pFile, "\tstring m_defValue;\n" );
	fprintf( pFile, "\tstring m_comment;\n" );
	fprintf( pFile, "\tbool   m_optional;\n" );
	fprintf( pFile, "} TDialParam;\n" );
	fprintf( pFile, "\n" );

	fprintf( pFile, "typedef struct TButtonDialInfo\n" );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\tstring m_hcsmName;\n" );
	fprintf( pFile, "\tstring m_name;\n" );
	fprintf( pFile, "\tstring m_comment;\n" );
	fprintf( pFile, "\tbool   m_isDial;\n" );
	fprintf( pFile, "\tvector<TDialParam> m_params;\n" );
	fprintf( pFile, "} TButtonDialInfo;\n" );
	fprintf( pFile, "\n" );

	fprintf( pFile, "class CButtonDialInfo\n" );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "public:\n" );
	fprintf( pFile, "\tCButtonDialInfo();\n" );
	fprintf( pFile, "\t~CButtonDialInfo();\n" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "\tvoid GetButtonInfo( const string& cHcsmName, vector<TButtonDialInfo>& output );\n" );
	fprintf( pFile, "\tvoid GetDialInfo( const string& cHcsmName, vector<TButtonDialInfo>& output );\n" );
	fprintf( pFile, "\tvoid GetButtonDialInfo( vector<TButtonDialInfo>& output );\n" );

	fprintf( pFile, "\n" );
	fprintf( pFile, "private:\n" );
	fprintf( pFile, "\tvector<TButtonDialInfo> m_buttonDialInfo;\n" );
	fprintf( pFile, "};\n" );

	fprintf( pFile, "\n" );
	fprintf( pFile, "#endif // __BUTTON_DIAL_INFO_H_\n\n" );
}

/******************************************************************************
 *
 * Name:  GenerateButtonDialImplementation
 *
 * Generates button dial implementation information.
 *
 * Inputs:
 *   pFile - The implementation file.
 *
 */
static void GenButtonDialImplementation( FILE* pFile )
{
	TStateMachine* pSm;            /* pointer to SM on SM list              */
	TStringPair*   pDial;          /* pointer to dial string pair           */
	TStringPair*   pButton;        /* pointer to button string pair         */
	TDialParam*    pParam;         /* pointer to dial parameter             */

	fprintf( pFile, m_pHeaderPreamble1 );
	fprintf( pFile, "#include \"genbuttondialinfo.h\"\n" );

	/*
	 * Generate the constructor.
	 */
	fprintf( pFile, "CButtonDialInfo::CButtonDialInfo()\n" );
	fprintf( pFile, "{\n" );
	for( pSm = m_pIn->sm_list; pSm; pSm = pSm->next ) 
	{
		for( pDial = pSm->dials; pDial; pDial = pDial->pNext ) 
		{
			/* skip all dials marked private */
			if( pDial->pDscrptn && !strcmp( pDial->pDscrptn, "private" ) )  continue;

			fprintf( pFile, "\t{\n" );
			fprintf( pFile, "\t\tTButtonDialInfo node;\n" );
			fprintf( pFile, "\t\tnode.m_hcsmName = \"%s\";\n", pSm->name );
			fprintf( pFile, "\t\tnode.m_name = \"%s\";\n", pDial->pName );
			if( pDial->pDscrptn )
			{
				fprintf( pFile, "\t\tnode.m_comment = \"%s\";\n", pDial->pDscrptn );
			}
			fprintf( pFile, "\t\tnode.m_isDial = true;\n" );
			for( pParam = pSm->dialParams; pParam; pParam = pParam->pNext )
			{
				if( !strcmp( pParam->pDialName, pDial->pName ) )
				{
					fprintf( pFile, "\t\t{\n" );
					fprintf( pFile, "\t\t\tTDialParam node2;\n" );
					fprintf( pFile, "\t\t\tnode2.m_name = \"%s\";\n", pParam->pName );
					fprintf( pFile, "\t\t\tnode2.m_dataType = \"%s\";\n", pParam->pType );
					fprintf( pFile, "\t\t\tnode2.m_units = \"%s\";\n", pParam->pUnits );
					fprintf( pFile, "\t\t\tnode2.m_defValue = \"%s\";\n", pParam->pDefValue );
					if( pParam->optional == 0 )
					{
						fprintf( pFile, "\t\t\tnode2.m_optional = false;\n" );
					}
					else
					{
						fprintf( pFile, "\t\t\tnode2.m_optional = false;\n" );
					}
					fprintf( pFile, "\t\t\tnode2.m_comment = \"%s\";\n", pParam->pComment );
					fprintf( pFile, "\t\t\tnode.m_params.push_back( node2 );\n" );
					fprintf( pFile, "\t\t}\n" );
				}
			}

			fprintf( pFile, "\n" );
			fprintf( pFile, "\t\tm_buttonDialInfo.push_back( node );\n" );
			fprintf( pFile, "\t}\n" );
		}

		for( pButton = pSm->buttons; pButton; pButton = pButton->pNext )
		{
			fprintf( pFile, "\t{\n" );
			fprintf( pFile, "\t\tTButtonDialInfo node;\n" );
			fprintf( pFile, "\t\tnode.m_hcsmName = \"%s\";\n", pSm->name );
			fprintf( pFile, "\t\tnode.m_name = \"%s\";\n", pButton->pName );
			if( pButton->pName )
			{
				fprintf( pFile, "\t\tnode.m_comment = \"%s\";\n", pButton->pDscrptn );
			}
			fprintf( pFile, "\t\tnode.m_isDial = false;\n" );
			fprintf( pFile, "\n" );
			fprintf( pFile, "\t\tm_buttonDialInfo.push_back( node );\n" );
			fprintf( pFile, "\t}\n" );
		}
	}
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );	
	fprintf( pFile, "\n" );

	fprintf( pFile, "CButtonDialInfo::~CButtonDialInfo()\n" );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );	
	fprintf( pFile, "\n" );

	/*
	 * Generate the GetDialInfo function.
	 */
	fprintf( pFile, "//////////////////////////////////////////////////////////////////////////////\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Description: Returns all dial parameter info for a given HCSM.\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Remarks: If the given HCSM is not found then nothing is added to the\n" );
	fprintf( pFile, "//  output vector.  This function does not clear the output vector before\n" );
	fprintf( pFile, "//  writing to it.\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Arguments:\n" );
	fprintf( pFile, "//  cHcsmName - The HCSM for which parameter information is needed.\n" );
	fprintf( pFile, "//  output - (output) The output parameter vector.\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Returns:\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "//////////////////////////////////////////////////////////////////////////////\n" );
	fprintf( pFile, "void " );
	fprintf( pFile, "CButtonDialInfo::GetDialInfo(\n" );
	fprintf( pFile, "\t\t\tconst string& cHcsmName,\n" );
	fprintf( pFile, "\t\t\tvector<TButtonDialInfo>& output\n" );
	fprintf( pFile, "\t\t\t)\n" );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\tvector<TButtonDialInfo>::iterator i;\n" );
	fprintf( pFile, "\tfor( i = m_buttonDialInfo.begin(); i != m_buttonDialInfo.end(); i++ )\n" );
	fprintf( pFile, "\t{\n" );
	fprintf( pFile, "\t\tif( i->m_isDial && cHcsmName == i->m_hcsmName )\n" );
	fprintf( pFile, "\t\t{\n" );
	fprintf( pFile, "\t\t\toutput.push_back( *i );\n" );
	fprintf( pFile, "\t\t}\n" );
	fprintf( pFile, "\t}\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "\n" );

	/*
	 * Generate the GetButtonInfo function.
	 */
	fprintf( pFile, "//////////////////////////////////////////////////////////////////////////////\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Description: Returns all button parameter info for a given HCSM.\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Remarks: If the given HCSM is not found then nothing is added to the\n" );
	fprintf( pFile, "//  output vector.  This function does not clear the output vector before\n" );
	fprintf( pFile, "//  writing to it.\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Arguments:\n" );
	fprintf( pFile, "//  cHcsmName - The HCSM for which parameter information is needed.\n" );
	fprintf( pFile, "//  output - (output) The output parameter vector.\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Returns:\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "//////////////////////////////////////////////////////////////////////////////\n" );
	fprintf( pFile, "void " );
	fprintf( pFile, "CButtonDialInfo::GetButtonInfo(\n" );
	fprintf( pFile, "\t\t\tconst string& cHcsmName,\n" );
	fprintf( pFile, "\t\t\tvector<TButtonDialInfo>& output\n" );
	fprintf( pFile, "\t\t\t)\n" );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\tvector<TButtonDialInfo>::iterator i;\n" );
	fprintf( pFile, "\tfor( i = m_buttonDialInfo.begin(); i != m_buttonDialInfo.end(); i++ )\n" );
	fprintf( pFile, "\t{\n" );
	fprintf( pFile, "\t\tif( !(i->m_isDial) && cHcsmName == i->m_hcsmName )\n" );
	fprintf( pFile, "\t\t{\n" );
	fprintf( pFile, "\t\t\toutput.push_back( *i );\n" );
	fprintf( pFile, "\t\t}\n" );
	fprintf( pFile, "\t}\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "\n" );

	/*
	 * Generate the GetButtonDialInfo function.
	 */
	fprintf( pFile, "//////////////////////////////////////////////////////////////////////////////\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Description: Returns all parameter info for all HCSMs.\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Remarks: This function does not clear the output vector before\n" );
	fprintf( pFile, "//  writing to it.\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Arguments:\n" );
	fprintf( pFile, "//  output - (output) The output parameter vector.\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "// Returns:\n" );
	fprintf( pFile, "//\n" );
	fprintf( pFile, "//////////////////////////////////////////////////////////////////////////////\n" );
	fprintf( pFile, "void " );
	fprintf( pFile, "CButtonDialInfo::GetButtonDialInfo( vector<TButtonDialInfo>& output )\n" );
	fprintf( pFile, "{\n" );
	fprintf( pFile, "\tvector<TButtonDialInfo>::iterator i;\n" );
	fprintf( pFile, "\tfor( i = m_buttonDialInfo.begin(); i != m_buttonDialInfo.end(); i++ )\n" );
	fprintf( pFile, "\t{\n" );
	fprintf( pFile, "\t\toutput.push_back( *i );\n" );
	fprintf( pFile, "\t}\n" );
	fprintf( pFile, "}\n" );
	fprintf( pFile, "\n" );
	fprintf( pFile, "\n" );

#if 0
	for( pSm = m_pIn->sm_list; pSm; pSm = pSm->next ) 
	{
		for( pDial = pSm->dials; pDial; pDial = pDial->pNext ) 
		{
			/* skip all dials marked private */
			if( pDial->pDscrptn && !strcmp( pDial->pDscrptn, "private" ) )  continue;

			fprintf( pFile, "\t{\n" );
			fprintf( pFile, "\t\tTButtonDialInfo node;\n" );
			fprintf( pFile, "\t\tnode.m_hcsmName = \"%s\";\n", pSm->name );
			fprintf( pFile, "\t\tnode.m_name     = \"%s\";\n", pDial->pName );
			if( pDial->pValue )
			{
				fprintf( pFile, "\t\tnode.m_dataType = \"%s\";\n", pDial->pValue );
			}
			if( pDial->pUnits )
			{
				fprintf( pFile, "\t\tnode.m_units    = \"%s\";\n", pDial->pUnits );
			}
			if( pDial->pDefValue )
			{
				fprintf( pFile, "\t\tnode.m_defValue = \"%s\";\n", pDial->pDefValue );
			}
			if( pDial->pDscrptn )
			{
				fprintf( pFile, "\t\tnode.m_comment  = \"%s\";\n", pDial->pDscrptn );
			}
			fprintf( pFile, "\t\tnode.m_isDial   = true;\n" );
			fprintf( pFile, "\t\toutput.push_back( node );\n" );
			fprintf( pFile, "\t}\n" );
		}

		for( pButton = pSm->buttons; pButton; pButton = pButton->pNext )
		{
			fprintf( pFile, "\t{\n" );
			fprintf( pFile, "\t\tTButtonDialInfo node;\n" );
			fprintf( pFile, "\t\tnode.m_hcsmName = \"%s\";\n", pSm->name );
			fprintf( pFile, "\t\tnode.m_name     = \"%s\";\n", pButton->pName );
			fprintf( pFile, "\t\tnode.m_isDial   = false;\n" );
			fprintf( pFile, "\t\toutput.push_back( node );\n" );
			fprintf( pFile, "\t}\n" );
		}
	}
#endif
}


/******************************************************************************
 *
 * Name:  GenerateCode
 *
 * Generates code based upon information from the structures that contain
 * information about what has been parsed.
 *
 * Inputs:
 *   pParserInfo -- Pointer to the parse information structure.
 *
 */
void GenerateCode( THcsmParserInfo *pParserInfo )
{

	int            lastBtnId = 1;
	int            lastDialId = 1;
	int            lastMonitorId = 1;
	int            lastParId = 1;
	int            lastVarId = 1;
	FILE*          pClassHeaderFile;   /* contains class decelarations       */
	FILE*          pClassImplementFile;/* contains class implementations     */
	FILE*          pCommunicateHeaderFile; /* contains hcsm communicate decls*/
	FILE*          pCommunicateImplementFile; /* contains communicate implemn*/
	FILE*          pGlobalHeaderFile;  /* contain global header information  */
	FILE*          pStorageHeaderFile; /* contains hcsm storage declarations */
	FILE*          pStorageImplementFile; /* contains storage implementations*/
	FILE*          pTemplateToClassFile;/* contains template to class mapping*/
	FILE*          pHcsmDialMonitorInlFile;/* contains virtual dial and 
										* monitor funcs in the CHcsm class   */
	FILE*          pGenButtonDialHeaderFile;/* contains button dial info     */
	FILE*          pGenButtonDialImplementFile;/* contains button dial info  */

	TStateMachine* pSm;                /* ptr to an sm inside the parsed info*/

	m_pIn = pParserInfo;

	pTemplateToClassFile = (FILE *) fopen( SM_TARGET_DIR SM_TEMPLATE_TO_CLASS_FILE, "w" );
	if ( pTemplateToClassFile == NULL ) {

		fprintf( stderr, "Can't open '%s' for output", SM_TARGET_DIR SM_TEMPLATE_TO_CLASS_FILE );
		perror("");
		exit(-1);

	}
	pGlobalHeaderFile = (FILE *) fopen( SM_TARGET_DIR SM_GLOBAL_HEADER_FILE, "w" );
	if ( pGlobalHeaderFile == NULL ) {

		fprintf( stderr, "Can't open '%s' for output", SM_TARGET_DIR SM_GLOBAL_HEADER_FILE );
		perror("");
		exit(-1);

	}
	pClassHeaderFile = (FILE *) fopen( SM_TARGET_DIR SM_CLASS_HEADER_FILE, "w" );
	if ( pClassHeaderFile == NULL ) {

		fprintf( stderr, "Can't open '%s' for output", SM_TARGET_DIR SM_CLASS_HEADER_FILE );
		perror("");
		exit(-1);

	}
	pClassImplementFile = (FILE *) fopen( SM_TARGET_DIR SM_CLASS_IMPLEMENT_FILE, "w" );
	if ( pClassImplementFile == NULL ) {

		fprintf( stderr, "Can't open '%s' for output", SM_TARGET_DIR SM_CLASS_IMPLEMENT_FILE );
		perror("");
		exit(-1);

	}
	pCommunicateHeaderFile = (FILE *) fopen( SM_TARGET_DIR SM_COMMUNICATE_HEADER_FILE, "w" );
	if ( pCommunicateHeaderFile == NULL ) {

		fprintf( stderr, "Can't open '%s' for output", SM_TARGET_DIR SM_COMMUNICATE_HEADER_FILE );
		perror("");
		exit(-1);

	}
	pCommunicateImplementFile = (FILE *) fopen( SM_TARGET_DIR SM_COMMUNICATE_IMPLEMENT_FILE, "w" );
	if ( pCommunicateImplementFile == NULL ) {

		fprintf( stderr, "Can't open '%s' for output", SM_TARGET_DIR SM_COMMUNICATE_IMPLEMENT_FILE );
		perror("");
		exit(-1);

	}
	pStorageHeaderFile = (FILE *) fopen( SM_TARGET_DIR SM_STORAGE_HEADER_FILE, "w" );
	if ( pStorageHeaderFile == NULL ) {

		fprintf( stderr, "Can't open '%s' for output", SM_TARGET_DIR SM_STORAGE_HEADER_FILE );
		perror("");
		exit(-1);

	}
	pStorageImplementFile = (FILE *) fopen( SM_TARGET_DIR SM_STORAGE_IMPLEMENT_FILE, "w" );
	if ( pStorageImplementFile == NULL ) {

		fprintf( stderr, "Can't open '%s' for output", SM_TARGET_DIR SM_STORAGE_IMPLEMENT_FILE );
		perror("");
		exit(-1);

	}

	pHcsmDialMonitorInlFile = (FILE *) fopen( SM_TARGET_DIR SM_HCSM_DIAL_MONITOR_INL_FILE, "w" );
	if ( pHcsmDialMonitorInlFile == NULL ) {

		fprintf( stderr, "Can't open '%s' for output", SM_TARGET_DIR SM_HCSM_DIAL_MONITOR_INL_FILE );
		perror("");
		exit(-1);

	}

	pGenButtonDialHeaderFile = (FILE *) fopen( SM_TARGET_DIR SM_GEN_BUTTON_DIAL_HEADER_FILE, "w" );
	if ( pGenButtonDialHeaderFile == NULL ) {

		fprintf( stderr, "Can't open '%s' for output", SM_TARGET_DIR SM_GEN_BUTTON_DIAL_HEADER_FILE );
		perror("");
		exit(-1);

	}

	pGenButtonDialImplementFile = (FILE *) fopen( SM_TARGET_DIR SM_GEN_BUTTON_DIAL_IMPLEMENT_FILE, "w" );
	if ( pGenButtonDialImplementFile == NULL ) {

		fprintf( stderr, "Can't open '%s' for output", SM_TARGET_DIR SM_GEN_BUTTON_DIAL_IMPLEMENT_FILE );
		perror("");
		exit(-1);

	}

	/*
	 * Assign unique identifiers to the various objects.
	 * 
	 * Each of the function lists (activity, predicate etc.) gets their 
	 * own index stream, meaning that within activity functions, identifiers
	 * go 1 ... number of activity functions.  Similarly for state
	 * machines, children, transitions, buttons, dials and monitors.
	 *
	 * Input, output, and local variables share the same stream within
	 * each state machine, meaning that identifiers for output variables
	 * follow the identifiers of input vars.  The order that these
	 * three variables are assigned identifiers is important, it
	 * goes  Locals, Inputs, Outputs.  Generally, the smaller the identifer
	 * the faster it is to access when using linear searches.
	 *
	 */
	AssignIdsToStrPairList( m_pIn->pre_actv_list, 1 );
	AssignIdsToStrPairList( m_pIn->post_actv_list, 1 );
	AssignIdsToStrPairList( m_pIn->pred_list, 1 );
	AssignIdsToStrPairList( m_pIn->crcb_list, 1 );
	AssignIdsToStrPairList( m_pIn->decb_list, 1 );
	AssignIdsToStrPairList( m_pIn->glob_list, 1 );

	for ( pSm = m_pIn->sm_list; pSm; pSm = pSm->next ) {

		/* unique streams */
		AssignIdsToStrNodeList( pSm->children, 1 );
		AssignIdsToTransList( pSm->trans, 1 );

		/* buttons, dials and monitors */
		lastBtnId = AssignUniqueIdsToStrPairList( pSm->buttons, lastBtnId, 6 );
		lastDialId = AssignUniqueIdsToStrPairList( pSm->dials, lastDialId, 0 );
		lastMonitorId = AssignUniqueIdsToStrPairList( pSm->monitors, 
													  lastMonitorId, 5 );

		/* local */
		lastVarId = AssignUniqueIdsToStrPairList( pSm->locals, lastVarId, 3 );

		/* inputs and outputs */
		lastParId = AssignUniqueIdsToStrPairList( pSm->inputs, lastParId, 1 );
		lastParId = AssignUniqueIdsToStrPairList( pSm->outputs, lastParId, 2 );

	}

	/*
	 * Generate in-line function into CHcsmCollection that maps template
	 * names to classes.
	 */
	GenTemplateToClassFunction( pTemplateToClassFile );
	fclose( pTemplateToClassFile );

	/*
	 * Generate the HCSM global header file.
	 */
	GenHcsmGlobalHeader( pGlobalHeaderFile );
	fclose( pGlobalHeaderFile );

	/*
	 * Generate storage class declarations.
	 */
	GenStorageClasses( pStorageHeaderFile, pStorageImplementFile );
	fclose( pStorageHeaderFile );
	fclose( pStorageImplementFile );

	/*
	 * Generate communicate class declarations.
	 */
	GenCommunicationClasses( 
				pCommunicateHeaderFile, 
				pCommunicateImplementFile,
				pHcsmDialMonitorInlFile 
				);
	fclose( pCommunicateHeaderFile );
	fclose( pCommunicateImplementFile );
	fclose( pHcsmDialMonitorInlFile );

	/* 
	 * Generate class declarations.
	 */
	GenClassHeader( pClassHeaderFile );
	fclose( pClassHeaderFile );

	/* 
	 * Generate class implementations.
	 */
	GenClassImplementation( pClassImplementFile );
	fclose( pClassImplementFile );

	GenButtonDialHeader( pGenButtonDialHeaderFile );
	fclose( pGenButtonDialHeaderFile );

	GenButtonDialImplementation( pGenButtonDialImplementFile );
	fclose( pGenButtonDialImplementFile );
}
