/*****************************************************************************
 *
 *  (C) Copyright 1998 by National Advanced Driving Simulator and
 *  Simulation Center, the University of Iowa and The University
 *  of Iowa. All rights reserved.
 *
 *  This file has been generated by the hcsm code generator.
 *  ### DO NOT EDIT DIRECTLY ###
 *
 */


#ifndef __genhcsm_h_INCLUDED_
#define __genhcsm_h_INCLUDED_

#include "genhcsmglobal.h"
#include <snoblock.h>
#include <hcsmspec.h>
#include "hcsmconcurrent.h"
#include "hcsmsequential.h"
#include "genstorage.h"
#include "gencommunicate.h"
#include "button.h"

class CDdo : public CHcsmConcurrent
{
public:
    CDdo( CHcsmCollection*, const CSnoBlock& );
    CDdo( const CDdo& );
    CDdo& operator=( const CDdo& );
    virtual ~CDdo();
    void SetDialAudioState( int );
    void SetDialAudioStateNoValue();
    void SetDialVisualState( int );
    void SetDialVisualStateNoValue();
    void SetDialMode( int );
    void SetDialModeNoValue();
    void SetDialDependent( int );
    void SetDialDependentNoValue();
    void SetDialSpeedOverRide( double );
    void SetDialSpeedOverRideNoValue();
    void SetDialDiGuyAction( string );
    void SetDialDiGuyActionNoValue();
    void SetDialDiGuyJointOverride( string );
    void SetDialDiGuyJointOverrideNoValue();
    CRoadPos GetMonitorRoadPos();
    virtual bool SetButtonByName( const string& );
    bool SetDialByName( const string&, const int& );
    bool SetDialByName( const string&, const double& );
    bool SetDialByName( const string&, const string& );
    bool SetDialByName( const string&, const float& );
    bool SetDialByName( const string&, const bool& );
    bool SetDialByNameStr( const string&, const string& );
    bool IsDialActiveByNameStr( const string& );
    bool ResetDialByName( const string& );
    bool GetMonitorByName( const string&, CRoadPos* );
    bool GetMonitorByName( const string&, float* );
    bool GetMonitorByName( const string&, CCrdr* );
    bool GetMonitorByName( const string&, int* );
    bool GetMonitorByName( const string&, bool* );
    bool GetMonitorByName( const string&, string* );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CDdoParseBlock* );
           void UserActivity( const CDdoParseBlock* );
           void UserDeletion( const CDdoParseBlock* );
           EInitCond m_lastState;
           bool m_quitAtEnd;
           CPoint3D m_last3DPos;
           CVector2D m_lastDirection;
           CVector2D m_lastOrientation;
           int m_dependent;
           bool m_isDiGuy;
           double m_speedOveride;
           bool m_doOverideSpeed;
           bool m_takeAccelIntoAccount;
           CPoint3D m_referencePoint;
           int m_target;
           CPoint3D m_vehicleReferencePoint;
           CObjectInitCond m_initConditions;
           CCubicSplinePos m_lastSplinePos;
           CSplineHermiteNonNorm m_spline;
           CVED::CTrajFollowerObj* m_pDdo;
           vector <double> m_velocityVector;
           vector <double> m_delayVector;
           vector <double> m_orientVector;
           bool m_trajIsGlobal;
           string m_parentName;
           int m_curModeDialVal;
           CVector3D m_initPosOffset;
           int m_useInitVel;
           bool m_enableAni;
           float m_currentVel;
           float m_maxAccel_fps2;
           float m_maxDecel_fps2;
           bool m_isAnimationOn;
           bool m_isFirstRun;
           FILE* m_debugPointsFile;
           long m_prevRoadPosFrame;
           CRoadPos m_currRoadPos;
           void CreateCvedObject( const CDdoParseBlock*, const CPoint3D&, const CVector3D& );
           void SetControlInputs(const CPoint3D&);
           string m_currDiGuyActionDialString;
    		void HandleDials( void );
    CHcsmBtn m_buttonTurnOnAnimation;
    bool GetButtonTurnOnAnimation();
    CHcsmBtn m_buttonTurnOffAnimation;
    bool GetButtonTurnOffAnimation();
    CDialint m_dialAudioState;
    int GetDialAudioState();
    CDialint m_dialVisualState;
    int GetDialVisualState();
    CDialint m_dialMode;
    int GetDialMode();
    CDialint m_dialDependent;
    int GetDialDependent();
    CDialdouble m_dialSpeedOverRide;
    double GetDialSpeedOverRide();
    CDialstring m_dialDiGuyAction;
    string GetDialDiGuyAction();
    CDialstring m_dialDiGuyJointOverride;
    string GetDialDiGuyJointOverride();
    CMonitorCRoadPos m_monitorRoadPos;
    void SetMonitorRoadPos( CRoadPos );
    void SetMonitorRoadPosNoValue();
};

class CVirtualObject : public CHcsmConcurrent
{
public:
    CVirtualObject( CHcsmCollection*, const CSnoBlock& );
    CVirtualObject( const CVirtualObject& );
    CVirtualObject& operator=( const CVirtualObject& );
    virtual ~CVirtualObject();
    void SetDialSetAnimation( string );
    void SetDialSetAnimationNoValue();
    void SetDialSetRotation( float );
    void SetDialSetRotationNoValue();
    void SetDialSetPosition( string );
    void SetDialSetPositionNoValue();
    void SetDialSetStateIndex( string );
    void SetDialSetStateIndexNoValue();
    void SetDialSetDrawType( int );
    void SetDialSetDrawTypeNoValue();
    void SetDialAttachToObject( string );
    void SetDialAttachToObjectNoValue();
    void SetDialAttachToLight( int );
    void SetDialAttachToLightNoValue();
    virtual bool SetButtonByName( const string& );
    bool SetDialByName( const string&, const int& );
    bool SetDialByName( const string&, const double& );
    bool SetDialByName( const string&, const string& );
    bool SetDialByName( const string&, const float& );
    bool SetDialByName( const string&, const bool& );
    bool SetDialByNameStr( const string&, const string& );
    bool IsDialActiveByNameStr( const string& );
    bool ResetDialByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
    		CObjectInitCond  m_initCondition;
           void UserCreation( const CVirtualObjectParseBlock* );
           void UserActivity( const CVirtualObjectParseBlock* );
           void UserDeletion( const CVirtualObjectParseBlock* );
           void UserPostActivity( const CVirtualObjectParseBlock* );
           EInitCond m_lastState;
           CPoint3D m_last3DPos;
           CPoint3D m_referencePoint;
           CPoint3D m_OverLayPosition;
    		CPoint3D m_rotation;
    		CPoint2D m_size;
    		int m_drawType;
    		int m_drawScreen;
    		int m_stateIndex;
    		float m_initBoarderColor[4];
    		float m_initFillColor[4]; 
    		int	m_startAnimationFrame;
    		int m_periodFrames;
    		int m_flashOnFrames;
           CObjectInitCond m_initConditions;
           string m_parentName;
           bool m_isAnimationOn;
    		bool m_isBlinking;
    		bool m_isMoving;
    		bool m_isRotating;
    		float m_rotateRate;
    		float m_degreesPerSec;
    		CPoint3D m_targetPos;
    		float m_unitsPerSecMov;
           CRoadPos m_currRoadPos;
    		CVED::CVisualObjectObj*    m_pVisualObject;
    		void HandleDials( void );
    		void SetBoarderColor(float,float,float,float);
    		void SetDrawPosition(float,float,float);
    		void SetRoatation(float,float,float);
    		void SetColor(float,float,float,float);
    CHcsmBtn m_buttonTurnOnAnimation;
    bool GetButtonTurnOnAnimation();
    CHcsmBtn m_buttonTurnOffAnimation;
    bool GetButtonTurnOffAnimation();
    CDialstring m_dialSetAnimation;
    string GetDialSetAnimation();
    CDialfloat m_dialSetRotation;
    float GetDialSetRotation();
    CDialstring m_dialSetPosition;
    string GetDialSetPosition();
    CDialstring m_dialSetStateIndex;
    string GetDialSetStateIndex();
    CDialint m_dialSetDrawType;
    int GetDialSetDrawType();
    CDialstring m_dialAttachToObject;
    string GetDialAttachToObject();
    CDialint m_dialAttachToLight;
    int GetDialAttachToLight();
};

class CTimeTrigger : public CHcsmConcurrent
{
public:
    CTimeTrigger( CHcsmCollection*, const CSnoBlock& );
    CTimeTrigger( const CTimeTrigger& );
    CTimeTrigger& operator=( const CTimeTrigger& );
    virtual ~CTimeTrigger();
    virtual bool SetButtonByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CTriggerParseBlock* );
           void UserActivity( const CTriggerParseBlock* );
           void UserDeletion( const CTriggerParseBlock* );
    		bool Evaluate( void );
    		void ExecuteConcurrentActions();
           void InitializeSequentialActions();
    		void ExecuteSequentialActions();
           void SetTriggerFireLog( CAction::TActionIterator& aI );
    		CObjectInitCond                 m_initCondition;
    		CTriggerFireCond                m_fireCondition;
    		CPoint3D                        m_prevPosition;
    		EInitCond                       m_prevState;
    		CVED::CCoordinatorObjectObj*    m_pTrigger;
    		CAction::TActionVec             m_pActionVector;
           CAction::TActionIterator        m_pCurrentAction;
           bool                            m_sequentialActions;
           int                             m_delayFrameCount;
           bool                            m_waitingForAction;
    		double                           m_time;
    CHcsmBtn m_buttonFireTrigger;
    bool GetButtonFireTrigger();
};

class CGmtrcPstnTrigger : public CHcsmConcurrent
{
public:
    CGmtrcPstnTrigger( CHcsmCollection*, const CSnoBlock& );
    CGmtrcPstnTrigger( const CGmtrcPstnTrigger& );
    CGmtrcPstnTrigger& operator=( const CGmtrcPstnTrigger& );
    virtual ~CGmtrcPstnTrigger();
    virtual bool SetButtonByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CTriggerParseBlock* );
           void UserActivity( const CTriggerParseBlock* );
           void UserDeletion( const CTriggerParseBlock* );
    		void InitCandidates( const CTriggerParseBlock* );
    		bool Evaluate( void );
    		void ExecuteConcurrentActions();
           void InitializeSequentialActions();
    		void ExecuteSequentialActions();
    		CObjectInitCond                 m_initCondition;
    		CTriggerFireCond                m_fireCondition;
    		CPoint3D                        m_prevPosition;
    		EInitCond                       m_prevState;
    		CVED::CCoordinatorObjectObj*    m_pTrigger;
    		CAction::TActionVec             m_pActionVector;
           CAction::TActionIterator        m_pCurrentAction;
           bool                            m_sequentialActions;
           int                             m_delayFrameCount;
           bool                            m_waitingForAction;
    		CCandidateSet                   m_candidateSet;
    		set<CCandidate>                 m_instigatorSet;
    		CPoint3D                        m_firePosition;
    		double                           m_radius;
    CHcsmBtn m_buttonFireTrigger;
    bool GetButtonFireTrigger();
};

class CTrffcLghtTrigger : public CHcsmConcurrent
{
public:
    CTrffcLghtTrigger( CHcsmCollection*, const CSnoBlock& );
    CTrffcLghtTrigger( const CTrffcLghtTrigger& );
    CTrffcLghtTrigger& operator=( const CTrffcLghtTrigger& );
    virtual ~CTrffcLghtTrigger();
    virtual bool SetButtonByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CTriggerParseBlock* );
           void UserActivity( const CTriggerParseBlock* );
           void UserDeletion( const CTriggerParseBlock* );
    		void InitCandidates( const CTriggerParseBlock* );
    		bool Evaluate( void );
    		void ExecuteConcurrentActions();
           void InitializeSequentialActions();
    		void ExecuteSequentialActions();
    		CObjectInitCond                 m_initCondition;
    		CTriggerFireCond                m_fireCondition;
    		CPoint3D                        m_prevPosition;
    		EInitCond                       m_prevState;
    		CVED::CCoordinatorObjectObj*    m_pTrigger;
    		CAction::TActionVec             m_pActionVector;
           CAction::TActionIterator        m_pCurrentAction;
           bool                            m_sequentialActions;
           int                             m_delayFrameCount;
           bool                            m_waitingForAction;
    		CCandidateSet                   m_candidateSet;
    		set<CCandidate>                 m_instigatorSet;
    		vector<string>                  m_byNameSet;
    		eCVTrafficLightState            m_state;
    CHcsmBtn m_buttonFireTrigger;
    bool GetButtonFireTrigger();
};

class CRoadPadTrigger : public CHcsmConcurrent
{
public:
    CRoadPadTrigger( CHcsmCollection*, const CSnoBlock& );
    CRoadPadTrigger( const CRoadPadTrigger& );
    CRoadPadTrigger& operator=( const CRoadPadTrigger& );
    virtual ~CRoadPadTrigger();
    virtual bool SetButtonByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CTriggerParseBlock* );
           void UserActivity( const CTriggerParseBlock* );
           void UserDeletion( const CTriggerParseBlock* );
    		void InitCandidates( const CTriggerParseBlock* );
    		bool Evaluate( void );
    		void ExecuteConcurrentActions();
           void InitializeSequentialActions();
    		void ExecuteSequentialActions();
           void SetTriggerFireLog( CAction::TActionIterator& aI );
    		CObjectInitCond                 m_initCondition;
    		CTriggerFireCond                m_fireCondition;
    		CPoint3D                        m_prevPosition;
    		EInitCond                       m_prevState;
    		CVED::CCoordinatorObjectObj*    m_pTrigger;
    		CAction::TActionVec             m_pActionVector;
           CAction::TActionIterator        m_pCurrentAction;
           bool                            m_sequentialActions;
           int                             m_delayFrameCount;
           bool                            m_waitingForAction;
    		CCandidateSet                   m_candidateSet;
    		set<CCandidate>                 m_instigatorSet;
    		CPath                           m_path;
    		int                             m_nthFromStart;
    		int                             m_nthFromEnd;
    		int                             m_nAhead;
    		int                             m_nBehind;
           bool                            m_debug;
    CHcsmBtn m_buttonFireTrigger;
    bool GetButtonFireTrigger();
};

class CExpressionTrigger : public CHcsmConcurrent
{
public:
    CExpressionTrigger( CHcsmCollection*, const CSnoBlock& );
    CExpressionTrigger( const CExpressionTrigger& );
    CExpressionTrigger& operator=( const CExpressionTrigger& );
    virtual ~CExpressionTrigger();
    virtual bool SetButtonByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CTriggerParseBlock* );
           void UserActivity( const CTriggerParseBlock* );
           void UserDeletion( const CTriggerParseBlock* );
    		void InitCandidates( const CTriggerParseBlock* );
    		bool Evaluate( void );
    		void ExecuteConcurrentActions();
           void InitializeSequentialActions();
    		void ExecuteSequentialActions();
           void SetTriggerFireLog( CAction::TActionIterator& aI );
    		CObjectInitCond                 m_initCondition;
    		CTriggerFireCond                m_fireCondition;
    		CPoint3D                        m_prevPosition;
    		EInitCond                       m_prevState;
    		CVED::CCoordinatorObjectObj*    m_pTrigger;
    		CAction::TActionVec             m_pActionVector;
           CAction::TActionIterator        m_pCurrentAction;
           bool                            m_sequentialActions;
           int                             m_delayFrameCount;
           bool                            m_waitingForAction;
    		CCandidateSet                   m_candidateSet;
    		set<CCandidate>                 m_instigatorSet;
           CExpEval                        m_expEval;
    		string                          m_expression;
           string                          m_parsedExpression;
    		int                             m_nthFromStart;
    		int                             m_nthFromEnd;
    		int                             m_nAhead;
    		int                             m_nBehind;
           bool                            m_debug;
    CHcsmBtn m_buttonFireTrigger;
    bool GetButtonFireTrigger();
};

class CFollowTrigger : public CHcsmConcurrent
{
public:
    CFollowTrigger( CHcsmCollection*, const CSnoBlock& );
    CFollowTrigger( const CFollowTrigger& );
    CFollowTrigger& operator=( const CFollowTrigger& );
    virtual ~CFollowTrigger();
    virtual bool SetButtonByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CTriggerParseBlock* );
           void UserActivity( const CTriggerParseBlock* );
           void UserDeletion( const CTriggerParseBlock* );
    		void InitCandidates( const CTriggerParseBlock* );
    		bool Evaluate( void );
    		void ExecuteConcurrentActions();
           void InitializeSequentialActions();
    		void ExecuteSequentialActions();	
    		CObjectInitCond                 m_initCondition;
    		CTriggerFireCond                m_fireCondition;
    		CPoint3D                        m_prevPosition;
    		EInitCond                       m_prevState;
    		CVED::CCoordinatorObjectObj*    m_pTrigger;
    		CAction::TActionVec             m_pActionVector;
           CAction::TActionIterator        m_pCurrentAction;
           bool                            m_sequentialActions;
           int                             m_delayFrameCount;
           bool                            m_waitingForAction;
    		CCandidateSet                   m_candidateSet;
    		set<CCandidate>                 m_instigatorSet;
    		CPath                           m_path;
           CTriggerParseBlock::TFollowInfo m_leaderInfo;
           CTriggerParseBlock::TFollowInfo m_followerInfo;
           bool                             m_isExpression;
           bool                             m_isFollowTime;
           double                           m_followTime;
           double                           m_followDist;
           double                           m_toleranceMinus;
           double                           m_tolerancePlus;
           double                           m_minDuration;
           double                           m_percentSpeedMatch;
           int                              m_framesInRange;
           bool                             m_requireSameLane;
           std::string                      m_expression;
           CExpEval                         m_exprEval;
    CHcsmBtn m_buttonFireTrigger;
    bool GetButtonFireTrigger();
};

class CTimeToArrvlTrigger : public CHcsmConcurrent
{
public:
    CTimeToArrvlTrigger( CHcsmCollection*, const CSnoBlock& );
    CTimeToArrvlTrigger( const CTimeToArrvlTrigger& );
    CTimeToArrvlTrigger& operator=( const CTimeToArrvlTrigger& );
    virtual ~CTimeToArrvlTrigger();
    virtual bool SetButtonByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CTriggerParseBlock* );
           void UserActivity( const CTriggerParseBlock* );
           void UserDeletion( const CTriggerParseBlock* );
    		void InitCandidates( const CTriggerParseBlock* );
    		bool Evaluate( void );
    		void ExecuteConcurrentActions();
           void InitializeSequentialActions();
    		void ExecuteSequentialActions();
    		double GetTimeToArrival(const CCandidate&, const CPoint3D&);
    		double MySin( int argC, const CExprParser::CStrNum args[] );
    		double MyCos( int argC, const CExprParser::CStrNum args[] );
    		double ReadCell( int argC, const CExprParser::CStrNum args[] );
    		double CellEquals( int argC, const CExprParser::CStrNum args[] );
    		double ReadVar( int argC, const CExprParser::CStrNum args[] );
    		double GetObjVel( int argC, const CExprParser::CStrNum args[] );
    		double GetObjTtcToOv( int argC, const CExprParser::CStrNum args[] );
    		double GetOvTtcToObj( int argC, const CExprParser::CStrNum args[] );
    		double GetObjDistPow( int argC, const CExprParser::CStrNum args[] );
    		double MyAbs( int argC, const CExprParser::CStrNum args[] );
    		double GetDistToTarg( int argC, const CExprParser::CStrNum args[] );
    		CObjectInitCond                 m_initCondition;
    		CTriggerFireCond                m_fireCondition;
    		CPoint3D                        m_prevPosition;
    		EInitCond                       m_prevState;
    		CVED::CCoordinatorObjectObj*    m_pTrigger;
    		CAction::TActionVec             m_pActionVector;
           CAction::TActionIterator        m_pCurrentAction;
           bool                            m_sequentialActions;
           int                             m_delayFrameCount;
           bool                            m_waitingForAction;
    		CCandidateSet                   m_candidateSet;
    		set<CCandidate>                 m_instigatorSet;
    		CPath                           m_path;
    		CPoint3D                        m_firePosition;
    		double                          m_time;
    		bool                            m_secondOrder;
           double                          m_boundSpeed;
           CExpEvalTTA                     m_expEval;
    		string                          m_expression;
    		CCandidate						m_currCandidate;
    		int								m_activationTime;
    		double							m_currTimeToArrival;
    		bool							m_logTTA;
    		int  							m_logTTANum;
    CHcsmBtn m_buttonFireTrigger;
    bool GetButtonFireTrigger();
};

class CGateway : public CHcsmConcurrent
{
public:
    CGateway( CHcsmCollection*, const CSnoBlock& );
    CGateway( const CGateway& );
    CGateway& operator=( const CGateway& );
    virtual ~CGateway();

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    		void CreateWorker (const CGatewayParseBlock* pBlock );
    		void DeleteWorker (const CGatewayParseBlock* pBlock );
    		void Worker(void);
    		void DispatchMessage(int sock);
    		void HandleGetDynaObjsMsg(int sock, TMsgHeader &head);
    		void HandleGetInstObjsMsg(int sock, TMsgHeader &head);
    		void HandleTakeObjControlMsg(int sock, TMsgHeader &head);
    		void HandleControlObjMsg(int sock, TMsgHeader &head);
    		void HandleReleaseObjCntrlMsg(int sock, TMsgHeader &head, const TUDPMsgHeader&);
    		void DispatchUdpMessage(TMessage &incommingMsg, const TUDPMsgHeader&);
    		void HandleGetDynaObjsMsg(TMessage &incommingMsg, const TUDPMsgHeader&);
    		void HandleGetInstObjsMsg(TMessage &incommingMsg, const TUDPMsgHeader&);
    		void HandleTakeObjControlMsg(TMessage &incommingMsg, const TUDPMsgHeader&);
    		void HandleControlObjMsg(TMessage &incommingMsg, const TUDPMsgHeader&);
    		void HandleReleaseObjCntrlMsg(TMessage &incommingMsg, const TUDPMsgHeader&);
    		void HandleSetDailMsg(TMessage &incommingMsg, const TUDPMsgHeader&);
    		void HandleResetDailMsg(TMessage &incommingMsg, const TUDPMsgHeader&);
           TUdpThreadPtr m_udpWorker;
           CUdpSender::TRef m_udpSender;
};

class CAdo : public CHcsmSequential
{
public:
    CAdo( CHcsmCollection*, const CSnoBlock& );
    CAdo( const CAdo& );
    CAdo& operator=( const CAdo& );
    virtual ~CAdo();
    void SetDialAudioState( string );
    void SetDialAudioStateNoValue();
    void SetDialForcedLaneOffset( string );
    void SetDialForcedLaneOffsetNoValue();
    void SetDialForcedVelocity( string );
    void SetDialForcedVelocityNoValue();
    void SetDialForcedSteeringAngle( string );
    void SetDialForcedSteeringAngleNoValue();
    void SetDialImStop( double );
    void SetDialImStopNoValue();
    void SetDialInhibitLaneChange( double );
    void SetDialInhibitLaneChangeNoValue();
    void SetDialLaneChange( string );
    void SetDialLaneChangeNoValue();
    void SetDialLaneChangeStatus( string );
    void SetDialLaneChangeStatusNoValue();
    void SetDialMaintainGap( string );
    void SetDialMaintainGapNoValue();
    void SetDialTargetVelocity( string );
    void SetDialTargetVelocityNoValue();
    void SetDialVisualState( string );
    void SetDialVisualStateNoValue();
    CRoadPos GetMonitorRoadPos();
    float GetMonitorDistanceToNextHldOffset();
    CCrdr GetMonitorTargCrdr();
    int GetMonitorStoppedBehindObj();
    bool GetMonitorHasStopSignTarget();
    string GetMonitorImTargCrdrs();
    int GetMonitorStoppedAtStopSignFrame();
    virtual bool SetButtonByName( const string& );
    bool SetDialByName( const string&, const int& );
    bool SetDialByName( const string&, const double& );
    bool SetDialByName( const string&, const string& );
    bool SetDialByName( const string&, const float& );
    bool SetDialByName( const string&, const bool& );
    bool SetDialByNameStr( const string&, const string& );
    bool IsDialActiveByNameStr( const string& );
    bool ResetDialByName( const string& );
    bool GetMonitorByName( const string&, CRoadPos* );
    bool GetMonitorByName( const string&, float* );
    bool GetMonitorByName( const string&, CCrdr* );
    bool GetMonitorByName( const string&, int* );
    bool GetMonitorByName( const string&, bool* );
    bool GetMonitorByName( const string&, string* );

private:
    virtual void ExecuteTransitions();
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CAdoParseBlock* );
           void UserPreActivity( const CAdoParseBlock* );
           void UserPostActivity( const CAdoParseBlock* );
           void UserDeletion( const CAdoParseBlock* );
           CObjectInitCond m_initConditions;
           CAdoInfoPtr m_pI;
           CCrdr m_crdr;
    		double GetObjDistPow2( int argC, const CExprParser::CStrNum args[] );
    		double GetObjVel( int argC, const CExprParser::CStrNum args[] );
    		double MySin( int argC, const CExprParser::CStrNum args[] );
    		double FadeIn( int argC, const CExprParser::CStrNum args[] );
    		double FadeOut( int argC, const CExprParser::CStrNum args[] );
    		double GetOvVel( int argC, const CExprParser::CStrNum args[] );
    		double ReadCell( int argC, const CExprParser::CStrNum args[] );
    		double ReadVar( int argC, const CExprParser::CStrNum args[] );
    		double GetObjAccel( int argC, const CExprParser::CStrNum args[] );
    		double MySinGap( int argC, const CExprParser::CStrNum args[] );
    		double FadeInGap( int argC, const CExprParser::CStrNum args[] );
    		double FadeOutGap( int argC, const CExprParser::CStrNum args[] );
           void DumpSnoBlock( const CAdoParseBlock* );
           bool CreateCvedObject( const CAdoParseBlock* );
           CRoadPos GetRoadposForRelCreate( const CAdoParseBlock* cpSnoBlock);
           void Activated( const CAdoParseBlock* );
           CAdoInfo::ERunMode GetRunMode( const string& );
           EDynaFidelity GetDynModel( const string& );
           void PreActivityProcessButtonsAndDials( const double& cInitVel );
           void PostActivityProcessButtonsAndDials();
           void ParseTargetVelocityDial();
           void ParseMaintainGapDial();
           void ParseLaneChangeDial();
           void ParseLaneChangeStatusDial();
           void ParseAudioStateDial();
           void ParseVisualStateDial();
    		void ParseForcedLaneOffset();
    		void ParseForcedSteeringAngle();
           bool ParseForcedVelocityDial( const double &cv, double& targVel, bool& haveAccel, double& targAccel );
           void ClearTurnSignals();
           void SetTurnSignals();
           void ComputeIntersectionTurnSignal();
           void BuildPath( const CLane& );
           void InitializeDynamicsVars( const CSolObj*, CVehicleObj* );
           void DisplayDebugInfo();
           FILE* m_debugFile;
           double m_currForcedLaneOffset;   // current offset
           double m_currForcedLaneOffsetUrgency;   // current offset Urgency (default .5)
           double m_prevForcedLaneDialVal;  // previous dial setting
    		CExpEvalAdo m_exprEval; //<Forced Vel Expr Parser
    		CExpEvalAdo m_exprGapDisEvtal; //< Gap Distatnce Expr Parser
    		CExpEvalAdo m_exprMinSpeedEvtal; //< Gap Distatnce Expr Parser
    		CExpEvalAdo m_exprMaxSpeedEvtal; //< Gap Distatnce Expr Parser	
    		CExpEvalAdo m_exprMaxAccelEvtal; //< Gap Distatnce Expr Parser
    		CExpEvalAdo m_exprMinAccelEvtal; //< Gap Distatnce Expr Parser
    void SetInputpIForAutonomous( CAdoInfoPtr );
    void SetInputpIForRemoteControl( CAdoInfoPtr );
    CPoint3D GetOutputTargPosFromRemoteControl();
    bool HasValueOutputTargPosFromRemoteControl();
    double GetOutputTargSteerFromRemoteControl();
    bool HasValueOutputTargSteerFromRemoteControl();
    double GetOutputTargAccelFromRemoteControl();
    bool HasValueOutputTargAccelFromRemoteControl();
    string GetOutputImTargCrdrsFromRemoteControl();
    bool HasValueOutputImTargCrdrsFromRemoteControl();
    bool GetOutputHasStopSignTargetFromRemoteControl();
    bool HasValueOutputHasStopSignTargetFromRemoteControl();
    int GetOutputStoppedAtStopSignFrameFromRemoteControl();
    bool HasValueOutputStoppedAtStopSignFrameFromRemoteControl();
    double GetOutputMaxSteerFromRemoteControl();
    bool HasValueOutputMaxSteerFromRemoteControl();
    CHcsmBtn m_buttonChangeLaneLeft;
    bool GetButtonChangeLaneLeft();
    CHcsmBtn m_buttonChangeLaneRight;
    bool GetButtonChangeLaneRight();
    CHcsmBtn m_buttonTurnLeft;
    bool GetButtonTurnLeft();
    CHcsmBtn m_buttonTurnRight;
    bool GetButtonTurnRight();
    CHcsmBtn m_buttonProjectAndResetLaneOffset;
    bool GetButtonProjectAndResetLaneOffset();
    CHcsmBtn m_buttonAutoControlBrakeLightsOn;
    bool GetButtonAutoControlBrakeLightsOn();
    CHcsmBtn m_buttonAutoControlBrakeLightsOff;
    bool GetButtonAutoControlBrakeLightsOff();
    CHcsmBtn m_buttonInhibitLaneChangeOn;
    bool GetButtonInhibitLaneChangeOn();
    CHcsmBtn m_buttonInhibitLaneChangeOff;
    bool GetButtonInhibitLaneChangeOff();
    CDialstring m_dialAudioState;
    string GetDialAudioState();
    CDialstring m_dialForcedLaneOffset;
    string GetDialForcedLaneOffset();
    CDialstring m_dialForcedVelocity;
    string GetDialForcedVelocity();
    CDialstring m_dialForcedSteeringAngle;
    string GetDialForcedSteeringAngle();
    CDialdouble m_dialImStop;
    double GetDialImStop();
    CDialdouble m_dialInhibitLaneChange;
    double GetDialInhibitLaneChange();
    CDialstring m_dialLaneChange;
    string GetDialLaneChange();
    CDialstring m_dialLaneChangeStatus;
    string GetDialLaneChangeStatus();
    CDialstring m_dialMaintainGap;
    string GetDialMaintainGap();
    CDialstring m_dialTargetVelocity;
    string GetDialTargetVelocity();
    CDialstring m_dialVisualState;
    string GetDialVisualState();
    CMonitorCRoadPos m_monitorRoadPos;
    void SetMonitorRoadPos( CRoadPos );
    void SetMonitorRoadPosNoValue();
    CMonitorfloat m_monitorDistanceToNextHldOffset;
    void SetMonitorDistanceToNextHldOffset( float );
    void SetMonitorDistanceToNextHldOffsetNoValue();
    CMonitorCCrdr m_monitorTargCrdr;
    void SetMonitorTargCrdr( CCrdr );
    void SetMonitorTargCrdrNoValue();
    CMonitorint m_monitorStoppedBehindObj;
    void SetMonitorStoppedBehindObj( int );
    void SetMonitorStoppedBehindObjNoValue();
    CMonitorbool m_monitorHasStopSignTarget;
    void SetMonitorHasStopSignTarget( bool );
    void SetMonitorHasStopSignTargetNoValue();
    CMonitorstring m_monitorImTargCrdrs;
    void SetMonitorImTargCrdrs( string );
    void SetMonitorImTargCrdrsNoValue();
    CMonitorint m_monitorStoppedAtStopSignFrame;
    void SetMonitorStoppedAtStopSignFrame( int );
    void SetMonitorStoppedAtStopSignFrameNoValue();
};

class CAutonomous : public CHcsmConcurrent
{
public:
    CAutonomous( CHcsmCollection*, const CSnoBlock& );
    CAutonomous( const CAutonomous& );
    CAutonomous& operator=( const CAutonomous& );
    virtual ~CAutonomous();
    void SetInputpI( CAdoInfoPtr );

private:
    virtual bool ExecutePredicate( int );
    bool AdoAutoRemotePredicate();
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void AutonomousPreActivity();
           void AutonomousPostActivity();
           bool AutoRemotePredicate();
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
};

class CRemoteControl : public CHcsmConcurrent
{
public:
    CRemoteControl( CHcsmCollection*, const CSnoBlock& );
    CRemoteControl( const CRemoteControl& );
    CRemoteControl& operator=( const CRemoteControl& );
    virtual ~CRemoteControl();
    void SetInputpI( CAdoInfoPtr );
    CPoint3D GetOutputTargPos();
    bool HasValueOutputTargPos();
    double GetOutputTargSteer();
    bool HasValueOutputTargSteer();
    double GetOutputTargAccel();
    bool HasValueOutputTargAccel();
    string GetOutputImTargCrdrs();
    bool HasValueOutputImTargCrdrs();
    bool GetOutputHasStopSignTarget();
    bool HasValueOutputHasStopSignTarget();
    int GetOutputStoppedAtStopSignFrame();
    bool HasValueOutputStoppedAtStopSignFrame();
    double GetOutputMaxSteer();
    bool HasValueOutputMaxSteer();

private:
    virtual bool ExecutePredicate( int );
    bool AdoRemoteAutoPredicate();
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void RemoteControlPreActivity();
           void RemoteControlPostActivity();
           bool RemoteAutoPredicate();
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    COutputParCPoint3D m_outputTargPos;
    void SetOutputTargPos( CPoint3D );
    void SetOutputTargPosNoValue();
    COutputPardouble m_outputTargSteer;
    void SetOutputTargSteer( double );
    void SetOutputTargSteerNoValue();
    COutputPardouble m_outputTargAccel;
    void SetOutputTargAccel( double );
    void SetOutputTargAccelNoValue();
    COutputParstring m_outputImTargCrdrs;
    void SetOutputImTargCrdrs( string );
    void SetOutputImTargCrdrsNoValue();
    COutputParbool m_outputHasStopSignTarget;
    void SetOutputHasStopSignTarget( bool );
    void SetOutputHasStopSignTargetNoValue();
    COutputParint m_outputStoppedAtStopSignFrame;
    void SetOutputStoppedAtStopSignFrame( int );
    void SetOutputStoppedAtStopSignFrameNoValue();
    COutputPardouble m_outputMaxSteer;
    void SetOutputMaxSteer( double );
    void SetOutputMaxSteerNoValue();
    void SetInputpIForFreeDrive( CAdoInfoPtr );
    CPoint3D GetOutputTargPosFromFreeDrive();
    bool HasValueOutputTargPosFromFreeDrive();
    double GetOutputTargVelFromFreeDrive();
    bool HasValueOutputTargVelFromFreeDrive();
    double GetOutputTargSteerFromFreeDrive();
    bool HasValueOutputTargSteerFromFreeDrive();
    double GetOutputTargAccelFromFreeDrive();
    bool HasValueOutputTargAccelFromFreeDrive();
    double GetOutputMaxSteerFromFreeDrive();
    bool HasValueOutputMaxSteerFromFreeDrive();
    void SetInputpIForFollow( CAdoInfoPtr );
    double GetOutputTargAccelFromFollow();
    bool HasValueOutputTargAccelFromFollow();
    void SetInputpIForLaneChange( CAdoInfoPtr );
    void SetInputFreeDriveTargVelForLaneChange( double );
    double GetOutputTargAccelFromLaneChange();
    bool HasValueOutputTargAccelFromLaneChange();
    CPoint3D GetOutputTargPosFromLaneChange();
    bool HasValueOutputTargPosFromLaneChange();
    double GetOutputMaxSteerFromLaneChange();
    bool HasValueOutputMaxSteerFromLaneChange();
    void SetInputpIForNavigateIntrsctn( CAdoInfoPtr );
    double GetOutputTargAccelFromNavigateIntrsctn();
    bool HasValueOutputTargAccelFromNavigateIntrsctn();
    string GetOutputImTargCrdrsFromNavigateIntrsctn();
    bool HasValueOutputImTargCrdrsFromNavigateIntrsctn();
    bool GetOutputHasStopSignTargetFromNavigateIntrsctn();
    bool HasValueOutputHasStopSignTargetFromNavigateIntrsctn();
    int GetOutputStoppedAtStopSignFrameFromNavigateIntrsctn();
    bool HasValueOutputStoppedAtStopSignFrameFromNavigateIntrsctn();
    void SetInputpIForMerge( CAdoInfoPtr );
    double GetOutputTargAccelFromMerge();
    bool HasValueOutputTargAccelFromMerge();
};

class CFreeDrive : public CHcsmConcurrent
{
public:
    CFreeDrive( CHcsmCollection*, const CSnoBlock& );
    CFreeDrive( const CFreeDrive& );
    CFreeDrive& operator=( const CFreeDrive& );
    virtual ~CFreeDrive();
    void SetInputpI( CAdoInfoPtr );
    CPoint3D GetOutputTargPos();
    bool HasValueOutputTargPos();
    double GetOutputTargVel();
    bool HasValueOutputTargVel();
    double GetOutputTargSteer();
    bool HasValueOutputTargSteer();
    double GetOutputTargAccel();
    bool HasValueOutputTargAccel();
    double GetOutputMaxSteer();
    bool HasValueOutputMaxSteer();

private:
    virtual void Creation( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void Creation();
           void PreActivity();
           void PostActivity();
           double GetSpeedLimit( const CRoadPos& );
           CRoadPos m_targDistRoadPos;
           double m_prevTargAccel;
           double ComputeOffRoadDistForTargPos( CAdoInfoPtr pI );
           void GetSpeedLimitTargAccel( CAdoInfoPtr pI, double& targAccel, double& targVel );
           void GetMaintainGapTargAccel( CAdoInfoPtr pI, double& targAccel, double& targVel );
           bool GetCurvatureTargAccel( CAdoInfoPtr pI, double& targAccel, double& targVel );
           void AdjustTargRoadPosForCurves( CAdoInfoPtr pI, CRoadPos& targRoadPos );
           void AdjustTargRoadPosForForcedOffset( CAdoInfoPtr pI, CRoadPos& targRoadPos, double &MaxSteerRateAdjustment );
           void AdjustTargRoadPosForLaneDevVariance( CAdoInfoPtr pI, CRoadPos& targRoadPos );
           CVehDynCommand::TVehDynCommand m_command;
           bool m_listeningToCurvature;
           int m_waitTimeFrame;
           long m_laneOffsetPrevFrame;
           double m_laneOffsetPrev;
           CVector3D m_curveOffsetPrev;
           CVector3D m_tangentPrev;
           long m_currFollEngTime;
           double m_initFollDist;
           int  m_lastMaintainGapId;
           double m_maintainGapPrevActualDist;
           TFollowParams m_mgParams;
           int m_maintainGapDurationCounter;
           int m_maintainGapCounter;
           double m_prevDistToCurv;
           double m_lastDistanceLookAhead;
           long m_refreshSpeedRandomizationFrame;
           double m_speedRandomization;
           double RandomizeVelocity( CAdoInfoPtr pI, const double, int );
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    COutputParCPoint3D m_outputTargPos;
    void SetOutputTargPos( CPoint3D );
    void SetOutputTargPosNoValue();
    COutputPardouble m_outputTargVel;
    void SetOutputTargVel( double );
    void SetOutputTargVelNoValue();
    COutputPardouble m_outputTargSteer;
    void SetOutputTargSteer( double );
    void SetOutputTargSteerNoValue();
    COutputPardouble m_outputTargAccel;
    void SetOutputTargAccel( double );
    void SetOutputTargAccelNoValue();
    COutputPardouble m_outputMaxSteer;
    void SetOutputMaxSteer( double );
    void SetOutputMaxSteerNoValue();
};

class CFollow : public CHcsmConcurrent
{
public:
    CFollow( CHcsmCollection*, const CSnoBlock& );
    CFollow( const CFollow& );
    CFollow& operator=( const CFollow& );
    virtual ~CFollow();
    void SetInputpI( CAdoInfoPtr );
    double GetOutputTargAccel();
    bool HasValueOutputTargAccel();

private:
    virtual void Creation( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void Creation();
           void PreActivity();
           void PostActivity();
           int m_ownVehicleRefreshFrame;
           CRoadPos m_ownVehicleRoadPos;
           double m_followRandomization;
           long m_currFollEngTime;
           double m_initFollDist;
           int  m_lastLeadId;
           double m_prevFollowActualDist;
           bool GetLeadObjectId( CAdoInfoPtr, const vector<int>& , int& );
           double ComputeDistToOwnVehicle( CAdoInfoPtr, const CDynObj* );
           double ComputeFollowDist( CAdoInfoPtr, double );
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    COutputPardouble m_outputTargAccel;
    void SetOutputTargAccel( double );
    void SetOutputTargAccelNoValue();
};

class CLaneChange : public CHcsmSequential
{
public:
    CLaneChange( CHcsmCollection*, const CSnoBlock& );
    CLaneChange( const CLaneChange& );
    CLaneChange& operator=( const CLaneChange& );
    virtual ~CLaneChange();
    void SetInputpI( CAdoInfoPtr );
    void SetInputFreeDriveTargVel( double );
    double GetOutputTargAccel();
    bool HasValueOutputTargAccel();
    CPoint3D GetOutputTargPos();
    bool HasValueOutputTargPos();
    double GetOutputMaxSteer();
    bool HasValueOutputMaxSteer();

private:
    virtual void ExecuteTransitions();
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void Creation();
           void PreActivity();
           void PostActivity();
           void Deletion();
           void NullifyOutputs();
           CLaneChangeConds m_conditions;
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    CInputPardouble m_inputFreeDriveTargVel;
    double GetInputFreeDriveTargVel();
    bool HasValueInputFreeDriveTargVel();
    COutputPardouble m_outputTargAccel;
    void SetOutputTargAccel( double );
    void SetOutputTargAccelNoValue();
    COutputParCPoint3D m_outputTargPos;
    void SetOutputTargPos( CPoint3D );
    void SetOutputTargPosNoValue();
    COutputPardouble m_outputMaxSteer;
    void SetOutputMaxSteer( double );
    void SetOutputMaxSteerNoValue();
    void SetInputpIForLcMonitor( CAdoInfoPtr );
    void SetInputpCondForLcMonitor( CLcCondsPtr );
    void SetInputFreeDriveTargVelForLcMonitor( double );
    void SetInputpIForLcSignal( CAdoInfoPtr );
    void SetInputpCondForLcSignal( CLcCondsPtr );
    void SetInputpIForLcExecute( CAdoInfoPtr );
    void SetInputpCondForLcExecute( CLcCondsPtr );
    double GetOutputTargAccelFromLcExecute();
    bool HasValueOutputTargAccelFromLcExecute();
    CPoint3D GetOutputTargPosFromLcExecute();
    bool HasValueOutputTargPosFromLcExecute();
    void SetInputpIForLcAbort( CAdoInfoPtr );
    void SetInputpCondForLcAbort( CLcCondsPtr );
};

class CLcMonitor : public CHcsmConcurrent
{
public:
    CLcMonitor( CHcsmCollection*, const CSnoBlock& );
    CLcMonitor( const CLcMonitor& );
    CLcMonitor& operator=( const CLcMonitor& );
    virtual ~CLcMonitor();
    void SetInputpI( CAdoInfoPtr );
    void SetInputpCond( CLcCondsPtr );
    void SetInputFreeDriveTargVel( double );

private:
    virtual bool ExecutePredicate( int );
    bool AdoLcMonitorLcExecutePredicate();
    bool AdoLcMonitorLcSignalPredicate();
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void PreActivity();
           void PostActivity();
           bool LcMonitorLcSignalPredicate();
           bool LcMonitorLcExecutePredicate();
           void CheckPathGuidance( CAdoInfoPtr, CLaneChangeCond& );
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    CInputParCLcCondsPtr m_inputpCond;
    CLcCondsPtr GetInputpCond();
    bool HasValueInputpCond();
    CInputPardouble m_inputFreeDriveTargVel;
    double GetInputFreeDriveTargVel();
    bool HasValueInputFreeDriveTargVel();
};

class CLcSignal : public CHcsmConcurrent
{
public:
    CLcSignal( CHcsmCollection*, const CSnoBlock& );
    CLcSignal( const CLcSignal& );
    CLcSignal& operator=( const CLcSignal& );
    virtual ~CLcSignal();
    void SetInputpI( CAdoInfoPtr );
    void SetInputpCond( CLcCondsPtr );

private:
    virtual bool ExecutePredicate( int );
    bool AdoLcSignalLcExecutePredicate();
    bool AdoLcSignalLcAbortPredicate();
    virtual void Creation( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void Creation();
           void PreActivity();
           void PostActivity();
           bool LcSignalLcExecutePredicate();
           bool LcSignalLcAbortPredicate();
           int m_signalFrame;
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    CInputParCLcCondsPtr m_inputpCond;
    CLcCondsPtr GetInputpCond();
    bool HasValueInputpCond();
};

class CLcExecute : public CHcsmSequential
{
public:
    CLcExecute( CHcsmCollection*, const CSnoBlock& );
    CLcExecute( const CLcExecute& );
    CLcExecute& operator=( const CLcExecute& );
    virtual ~CLcExecute();
    void SetInputpI( CAdoInfoPtr );
    void SetInputpCond( CLcCondsPtr );
    double GetOutputTargAccel();
    bool HasValueOutputTargAccel();
    CPoint3D GetOutputTargPos();
    bool HasValueOutputTargPos();

private:
    virtual void ExecuteTransitions();
    virtual bool ExecutePredicate( int );
    bool AdoLcExecuteLcAbortPredicate();
    bool AdoLcExecuteLcMonitorPredicate();
    virtual void Creation( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void Creation();
           void PreActivity();
           void PostActivity();
           bool LcExecuteLcAbortPredicate();
           bool LcExecuteLcMonitorPredicate();
           void CalcTargRoadPos( CAdoInfoPtr&, CRoadPos& );
           double CalcTotalLatDist( CAdoInfoPtr&, const CRoadPos&, bool isAdoPos );
           double CalcTargOffset( CAdoInfoPtr&, double );
    		bool m_firstFrame;
    		bool m_startLcFrame;
           CRoadPos m_targRoadPos;
    		deque<double> m_storeRoadAngle;
    		double m_maxRoadAngle;
    		double m_lastTargetOffset;
    		double m_currLookAheadTime;
           bool m_overShotLc; 
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    CInputParCLcCondsPtr m_inputpCond;
    CLcCondsPtr GetInputpCond();
    bool HasValueInputpCond();
    COutputPardouble m_outputTargAccel;
    void SetOutputTargAccel( double );
    void SetOutputTargAccelNoValue();
    COutputParCPoint3D m_outputTargPos;
    void SetOutputTargPos( CPoint3D );
    void SetOutputTargPosNoValue();
    void SetInputpIForLcExecuteNeutralize( CAdoInfoPtr );
    void SetInputpCondForLcExecuteNeutralize( CLcCondsPtr );
    double GetOutputTargOffsetFromLcExecuteNeutralize();
    bool HasValueOutputTargOffsetFromLcExecuteNeutralize();
    void SetInputpIForLcExecuteIncrement( CAdoInfoPtr );
    void SetInputpCondForLcExecuteIncrement( CLcCondsPtr );
    double GetOutputTargOffsetFromLcExecuteIncrement();
    bool HasValueOutputTargOffsetFromLcExecuteIncrement();
    double GetOutputTargLookAheadFromLcExecuteIncrement();
    bool HasValueOutputTargLookAheadFromLcExecuteIncrement();
    void SetInputpIForLcExecuteSteady( CAdoInfoPtr );
    void SetInputpCondForLcExecuteSteady( CLcCondsPtr );
    double GetOutputTargOffsetFromLcExecuteSteady();
    bool HasValueOutputTargOffsetFromLcExecuteSteady();
    double GetOutputTargLookAheadFromLcExecuteSteady();
    bool HasValueOutputTargLookAheadFromLcExecuteSteady();
    void SetInputpIForLcExecuteDecrement( CAdoInfoPtr );
    void SetInputpCondForLcExecuteDecrement( CLcCondsPtr );
    double GetOutputTargOffsetFromLcExecuteDecrement();
    bool HasValueOutputTargOffsetFromLcExecuteDecrement();
    double GetOutputTargLookAheadFromLcExecuteDecrement();
    bool HasValueOutputTargLookAheadFromLcExecuteDecrement();
};

class CLcAbort : public CHcsmConcurrent
{
public:
    CLcAbort( CHcsmCollection*, const CSnoBlock& );
    CLcAbort( const CLcAbort& );
    CLcAbort& operator=( const CLcAbort& );
    virtual ~CLcAbort();
    void SetInputpI( CAdoInfoPtr );
    void SetInputpCond( CLcCondsPtr );

private:
    virtual bool ExecutePredicate( int );
    bool AdoLcAbortLcMonitorPredicate();
    virtual void Creation( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void PreActivity();
           void PostActivity();
           bool LcAbortLcMonitorPredicate();
           void Creation();
           bool m_scenarioTriggeredAbort;
    		bool m_firstFrame;
           int m_abortCount;
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    CInputParCLcCondsPtr m_inputpCond;
    CLcCondsPtr GetInputpCond();
    bool HasValueInputpCond();
};

class CLcExecuteNeutralize : public CHcsmConcurrent
{
public:
    CLcExecuteNeutralize( CHcsmCollection* );
    CLcExecuteNeutralize( const CLcExecuteNeutralize& );
    CLcExecuteNeutralize& operator=( const CLcExecuteNeutralize& );
    virtual ~CLcExecuteNeutralize();
    void SetInputpI( CAdoInfoPtr );
    void SetInputpCond( CLcCondsPtr );
    double GetOutputTargOffset();
    bool HasValueOutputTargOffset();

private:
    virtual bool ExecutePredicate( int );
    bool ExecuteLcNeutralizeLcIncrementPredicate();
    virtual void PostActivity();
           void UserPostActivity();
           bool LcNeutralizeIncrementPredicate();
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    CInputParCLcCondsPtr m_inputpCond;
    CLcCondsPtr GetInputpCond();
    bool HasValueInputpCond();
    COutputPardouble m_outputTargOffset;
    void SetOutputTargOffset( double );
    void SetOutputTargOffsetNoValue();
};

class CLcExecuteIncrement : public CHcsmConcurrent
{
public:
    CLcExecuteIncrement( CHcsmCollection* );
    CLcExecuteIncrement( const CLcExecuteIncrement& );
    CLcExecuteIncrement& operator=( const CLcExecuteIncrement& );
    virtual ~CLcExecuteIncrement();
    void SetInputpI( CAdoInfoPtr );
    void SetInputpCond( CLcCondsPtr );
    double GetOutputTargOffset();
    bool HasValueOutputTargOffset();
    double GetOutputTargLookAhead();
    bool HasValueOutputTargLookAhead();

private:
    virtual bool ExecutePredicate( int );
    bool ExecuteLcIncrementLcSteadyPredicate();
    bool ExecuteLcIncrementLcAbortPredicate();
    virtual void PostActivity();
           void UserPostActivity();
           bool LcIncrementSteadyPredicate();
           bool LcIncrementDecrementPredicate();
           bool LcIncrementLcAbortPredicate();
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    CInputParCLcCondsPtr m_inputpCond;
    CLcCondsPtr GetInputpCond();
    bool HasValueInputpCond();
    COutputPardouble m_outputTargOffset;
    void SetOutputTargOffset( double );
    void SetOutputTargOffsetNoValue();
    COutputPardouble m_outputTargLookAhead;
    void SetOutputTargLookAhead( double );
    void SetOutputTargLookAheadNoValue();
};

class CLcExecuteSteady : public CHcsmConcurrent
{
public:
    CLcExecuteSteady( CHcsmCollection* );
    CLcExecuteSteady( const CLcExecuteSteady& );
    CLcExecuteSteady& operator=( const CLcExecuteSteady& );
    virtual ~CLcExecuteSteady();
    void SetInputpI( CAdoInfoPtr );
    void SetInputpCond( CLcCondsPtr );
    double GetOutputTargOffset();
    bool HasValueOutputTargOffset();
    double GetOutputTargLookAhead();
    bool HasValueOutputTargLookAhead();

private:
    virtual bool ExecutePredicate( int );
    bool ExecuteLcSteadyLcDecrementPredicate();
    bool ExecuteLcSteadyLcAbortPredicate();
    virtual void PostActivity();
           void UserPostActivity();
           bool LcSteadyDecrementPredicate();
           bool LcSteadyLcAbortPredicate();
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    CInputParCLcCondsPtr m_inputpCond;
    CLcCondsPtr GetInputpCond();
    bool HasValueInputpCond();
    COutputPardouble m_outputTargOffset;
    void SetOutputTargOffset( double );
    void SetOutputTargOffsetNoValue();
    COutputPardouble m_outputTargLookAhead;
    void SetOutputTargLookAhead( double );
    void SetOutputTargLookAheadNoValue();
};

class CLcExecuteDecrement : public CHcsmConcurrent
{
public:
    CLcExecuteDecrement( CHcsmCollection* );
    CLcExecuteDecrement( const CLcExecuteDecrement& );
    CLcExecuteDecrement& operator=( const CLcExecuteDecrement& );
    virtual ~CLcExecuteDecrement();
    void SetInputpI( CAdoInfoPtr );
    void SetInputpCond( CLcCondsPtr );
    double GetOutputTargOffset();
    bool HasValueOutputTargOffset();
    double GetOutputTargLookAhead();
    bool HasValueOutputTargLookAhead();

private:
    virtual bool ExecutePredicate( int );
    bool ExecuteLcDecrementLcNeutralizePredicate();
    bool ExecuteLcDecrementLcAbortPredicate();
    virtual void PostActivity();
           void UserPostActivity();
           bool LcDecrementNeutralizePredicate();
           bool LcDecrementLcAbortPredicate();
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    CInputParCLcCondsPtr m_inputpCond;
    CLcCondsPtr GetInputpCond();
    bool HasValueInputpCond();
    COutputPardouble m_outputTargOffset;
    void SetOutputTargOffset( double );
    void SetOutputTargOffsetNoValue();
    COutputPardouble m_outputTargLookAhead;
    void SetOutputTargLookAhead( double );
    void SetOutputTargLookAheadNoValue();
};

class CNavigateIntrsctn : public CHcsmConcurrent
{
public:
    CNavigateIntrsctn( CHcsmCollection*, const CSnoBlock& );
    CNavigateIntrsctn( const CNavigateIntrsctn& );
    CNavigateIntrsctn& operator=( const CNavigateIntrsctn& );
    virtual ~CNavigateIntrsctn();
    void SetInputpI( CAdoInfoPtr );
    double GetOutputTargAccel();
    bool HasValueOutputTargAccel();
    string GetOutputImTargCrdrs();
    bool HasValueOutputImTargCrdrs();
    bool GetOutputHasStopSignTarget();
    bool HasValueOutputHasStopSignTarget();
    int GetOutputStoppedAtStopSignFrame();
    bool HasValueOutputStoppedAtStopSignFrame();

private:
    virtual void Creation( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void Creation();
           void PreActivity();
           void PostActivity();
           void ResetStopSignVars();
           deque<int> m_signaledIntrsctns;
           bool m_madeStopSignCheck;
           bool m_stopSignCrdr;
           double m_stopSignHldOfsDist;
           bool m_madeTheNeededStop;
           int m_StoppedAtStopSignFrame;
           int m_tempStartFrames;
           bool m_firstFrame;
           double m_firstDist;
           double m_minDist;
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    COutputPardouble m_outputTargAccel;
    void SetOutputTargAccel( double );
    void SetOutputTargAccelNoValue();
    COutputParstring m_outputImTargCrdrs;
    void SetOutputImTargCrdrs( string );
    void SetOutputImTargCrdrsNoValue();
    COutputParbool m_outputHasStopSignTarget;
    void SetOutputHasStopSignTarget( bool );
    void SetOutputHasStopSignTargetNoValue();
    COutputParint m_outputStoppedAtStopSignFrame;
    void SetOutputStoppedAtStopSignFrame( int );
    void SetOutputStoppedAtStopSignFrameNoValue();
};

class CMerge : public CHcsmConcurrent
{
public:
    CMerge( CHcsmCollection* );
    CMerge( const CMerge& );
    CMerge& operator=( const CMerge& );
    virtual ~CMerge();
    void SetInputpI( CAdoInfoPtr );
    double GetOutputTargAccel();
    bool HasValueOutputTargAccel();

private:
    virtual void Creation();
    virtual void PreActivity();
    virtual void PostActivity();
           void UserCreation();
           void UserPreActivity();
           void UserPostActivity();
           EMergeState m_state;
           bool m_isMergeLaneChangeDone;
    		bool m_isOnMergeRoad;
           bool m_firstFrame;
           double m_firstDist;
           double m_minDist;
           double m_prevFollowActualDist;
           long m_currFollEngTime;
           double m_initFollDist;
           int  m_lastLeadId;
           double  m_distToP1Ado;
           double  m_distToP1ApprchObj;
           TFollowParams m_mergeParams;
           double m_mergeTtc;
    		CCrdr m_targCrdr;
    		double m_distAtP1;
           int  m_gapObjId;
    		void ComputeTimeToArrival( CAdoInfoPtr& pI, int objId,  double dist, double& tta );
    		bool ComputeApprchObjDistToP1( CAdoInfoPtr& pI, int gapObjId, double& distToP1 );
    		void ComputeActualDist( CAdoInfoPtr& pI, double apprchObjDistToP1, double& acutalDist );
           void ProcessOffState( CAdoInfoPtr& pI, double& targAccel );
     		bool CheckMergeRoad( CAdoInfoPtr& pI );
    		bool TransitionOffToGapSearch( CAdoInfoPtr& pI );
    		bool TransitionGapSearchToTrack( bool hasGap );
    		bool TransitionGapSearchToOff( CAdoInfoPtr& pI );
           bool GapSearch( CAdoInfoPtr& pI, int& gapObjId, double& targAccel );
           bool ProcessGapSearchState( CAdoInfoPtr& pI, int& gapObjId, double& targAccel );
           bool ProcessTrackState( CAdoInfoPtr& pI, double actualDist, double& targAccel );
    		bool TransitionTrackToGapSearch( bool hasTrack );
    		bool TransitionTrackToOff( CAdoInfoPtr& pI ); 
    CInputParCAdoInfoPtr m_inputpI;
    CAdoInfoPtr GetInputpI();
    bool HasValueInputpI();
    COutputPardouble m_outputTargAccel;
    void SetOutputTargAccel( double );
    void SetOutputTargAccelNoValue();
};

class CEnvironmentController : public CHcsmConcurrent
{
public:
    CEnvironmentController( CHcsmCollection*, const CSnoBlock& );
    CEnvironmentController( const CEnvironmentController& );
    CEnvironmentController& operator=( const CEnvironmentController& );
    virtual ~CEnvironmentController();

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CEnvControlParseBlock* );
           void UserPreActivity( const CEnvControlParseBlock* );
           void UserPostActivity( const CEnvControlParseBlock* );
           void UserDeletion( const CEnvControlParseBlock* );
           void MakeStringUpper( string& s );
           eCVEnviroType StringToLightState( const string& str );
           void Dump( void );
};

class CEnviroInfo : public CHcsmConcurrent
{
public:
    CEnviroInfo( CHcsmCollection*, const CSnoBlock& );
    CEnviroInfo( const CEnviroInfo& );
    CEnviroInfo& operator=( const CEnviroInfo& );
    virtual ~CEnviroInfo();

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CEnviroInfoParseBlock* );
           void UserPreActivity( const CEnviroInfoParseBlock* );
           void UserPostActivity( const CEnviroInfoParseBlock* );
           void UserDeletion( const CEnviroInfoParseBlock* );
};

class CIntersectionManager : public CHcsmConcurrent
{
public:
    CIntersectionManager( CHcsmCollection*, const CSnoBlock& );
    CIntersectionManager( const CIntersectionManager& );
    CIntersectionManager& operator=( const CIntersectionManager& );
    virtual ~CIntersectionManager();

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CIntersectionMngrParseBlock* );
           void UserPreActivity( const CIntersectionMngrParseBlock* );
           void UserPostActivity( const CIntersectionMngrParseBlock* );
           void UserDeletion( const CIntersectionMngrParseBlock* );
    		void PrioritizeVehicles( const CIntrsctn&, const set<int>&, const map<int, TImActiveObjInfo>&, const vector<TCrdrPriorityList>&, const CObjTypeMask&, vector<TVehiclePriorityList>&, set<int>& );
           void SignalVehicles( const CIntrsctn&, const vector<TVehiclePriorityList>& );
           void SetVehicleState( int, EImTravelState, double );
           void RemoveInactiveIntrsctns();
           void ProcessRegisterRequests();
           void DebugActiveIntrsctns();
           bool BuildAdoTargCrdr( const CDynObj* cpObj, CHcsm* pObjHcsm, const CIntrsctn cIntrsctn, CCrdr& crdr );
           TImIntrsctn m_intrsctns[cMAX_IM_INTRSCTN];
           CImActiveIntrsctn m_activeIntrsctns[cMAX_ACTIVE_IM_INTRSCTN];
           int m_activeIntrsctnsLastElem;
           queue<int> m_freeActiveIntrsctnsIdx;
};

class COwnVehicleMirror : public CHcsmConcurrent
{
public:
    COwnVehicleMirror( CHcsmCollection*, const CSnoBlock& );
    COwnVehicleMirror( const COwnVehicleMirror& );
    COwnVehicleMirror& operator=( const COwnVehicleMirror& );
    virtual ~COwnVehicleMirror();

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const COwnVehicleMirrorParseBlock* );
           void UserPreActivity( const COwnVehicleMirrorParseBlock* );
           void UserPostActivity( const COwnVehicleMirrorParseBlock* );
           void UserDeletion( const COwnVehicleMirrorParseBlock* );
};

class CStaticObjManager : public CHcsmConcurrent
{
public:
    CStaticObjManager( CHcsmCollection*, const CSnoBlock& );
    CStaticObjManager( const CStaticObjManager& );
    CStaticObjManager& operator=( const CStaticObjManager& );
    virtual ~CStaticObjManager();
    void SetDialSetOption1( string );
    void SetDialSetOption1NoValue();
    void SetDialSetOption2( string );
    void SetDialSetOption2NoValue();
    void SetDialAudioState( string );
    void SetDialAudioStateNoValue();
    void SetDialVisualState( string );
    void SetDialVisualStateNoValue();
    void SetDialAnimationState( string );
    void SetDialAnimationStateNoValue();
    bool SetDialByName( const string&, const int& );
    bool SetDialByName( const string&, const double& );
    bool SetDialByName( const string&, const string& );
    bool SetDialByName( const string&, const float& );
    bool SetDialByName( const string&, const bool& );
    bool SetDialByNameStr( const string&, const string& );
    bool IsDialActiveByNameStr( const string& );
    bool ResetDialByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
    		void Creation( const CSobjMngrParseBlock* );
    		void Deletion( const CSobjMngrParseBlock* );
           void PostActivity( const CSobjMngrParseBlock* );
           bool SetObjectOptions( const string& name, int *pValues );
           bool SetObjectAudioState( const string& name, short val );
           bool SetObjectVisualState( const string& name, short val );
    CDialstring m_dialSetOption1;
    string GetDialSetOption1();
    CDialstring m_dialSetOption2;
    string GetDialSetOption2();
    CDialstring m_dialAudioState;
    string GetDialAudioState();
    CDialstring m_dialVisualState;
    string GetDialVisualState();
    CDialstring m_dialAnimationState;
    string GetDialAnimationState();
};

class CTrafficLightManager : public CHcsmConcurrent
{
public:
    CTrafficLightManager( CHcsmCollection*, const CSnoBlock& );
    CTrafficLightManager( const CTrafficLightManager& );
    CTrafficLightManager& operator=( const CTrafficLightManager& );
    virtual ~CTrafficLightManager();
    void SetDialTrafficLight( string );
    void SetDialTrafficLightNoValue();
    bool SetDialByName( const string&, const int& );
    bool SetDialByName( const string&, const double& );
    bool SetDialByName( const string&, const string& );
    bool SetDialByName( const string&, const float& );
    bool SetDialByName( const string&, const bool& );
    bool SetDialByNameStr( const string&, const string& );
    bool IsDialActiveByNameStr( const string& );
    bool ResetDialByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CTrafLghtMngrParseBlock* );
           void UserPreActivity( const CTrafLghtMngrParseBlock* );
           void UserPostActivity( const CTrafLghtMngrParseBlock* );
           void UserDeletion( const CTrafLghtMngrParseBlock* );
    		void MakeStringUpper( string& s );
    		void ParseDialString( const string&, string&, string&, double* );
    		vector<CClg>     m_clgs;
    CDialstring m_dialTrafficLight;
    string GetDialTrafficLight();
};

class CTrafficManager : public CHcsmConcurrent
{
public:
    CTrafficManager( CHcsmCollection*, const CSnoBlock& );
    CTrafficManager( const CTrafficManager& );
    CTrafficManager& operator=( const CTrafficManager& );
    virtual ~CTrafficManager();
    void SetDialInputSet( string );
    void SetDialInputSetNoValue();
    virtual bool SetButtonByName( const string& );
    bool SetDialByName( const string&, const int& );
    bool SetDialByName( const string&, const double& );
    bool SetDialByName( const string&, const string& );
    bool SetDialByName( const string&, const float& );
    bool SetDialByName( const string&, const bool& );
    bool SetDialByNameStr( const string&, const string& );
    bool IsDialActiveByNameStr( const string& );
    bool ResetDialByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CTrafMngrParseBlock* );
           void UserActivity( const CTrafMngrParseBlock* );
           void UserDeletion( const CTrafMngrParseBlock* );
    		void GetOwnVehRoadPos();
    		void MaintainPath();
    		void MaintainPathDist( const double cPathPrependDist, const double cPathAppendDist );
    		void CreateObjects( vector<TTmCreationPoint>& creationPoints, const string& solName );
    		void DeleteObjects();
           void CountObjectsCreatedByTM( vector<TTmObj>& tmObjs );
           void LimitOverload(	vector<TTmObj>& tmObjs,	int desKill );
           int KillTmObjs( vector<TTmObj>& tmObjs, int numToKill, bool killBehindOnly, const double cDistToKill );
           int KillTmObjsDist( vector<TTmObj>& tmObjs, const double cAheadDist, const double cBehindDist );
           void FindCreationPoints( vector<TTmCreationPoint>& creationPoints,	const double& cMaxDensity, double ownVehVel	);
    		void FindCreationPointsOnHighway( vector<TTmCreationPoint>&, const double&, double ownVehVel );
    		vector<CTrafMngrParseBlock::TInputSet> m_inputSets;
    		vector<CTrafMngrParseBlock::TInputSet>::const_iterator m_cInputSetItr;
    		double m_distAtAppending;
    		double m_timeAtObjCreation;
    		CRoadPos m_roadPos;
           CPath*  m_pPath;
           int m_rndStreamId;
    		vector<int> m_objsByTM;
    		int m_creationCounter;	
    CHcsmBtn m_buttonMakeTraffic;
    bool GetButtonMakeTraffic();
    CDialstring m_dialInputSet;
    string GetDialInputSet();
};

class CTrafficSource : public CHcsmConcurrent
{
public:
    CTrafficSource( CHcsmCollection*, const CSnoBlock& );
    CTrafficSource( const CTrafficSource& );
    CTrafficSource& operator=( const CTrafficSource& );
    virtual ~CTrafficSource();
    void SetDialStartStop( bool );
    void SetDialStartStopNoValue();
    virtual bool SetButtonByName( const string& );
    bool SetDialByName( const string&, const int& );
    bool SetDialByName( const string&, const double& );
    bool SetDialByName( const string&, const string& );
    bool SetDialByName( const string&, const float& );
    bool SetDialByName( const string&, const bool& );
    bool SetDialByNameStr( const string&, const string& );
    bool IsDialActiveByNameStr( const string& );
    bool ResetDialByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CTrafSrcParseBlock* );
           void UserActivity( const CTrafSrcParseBlock* );
           void UserDeletion( const CTrafSrcParseBlock* );
    		void MakeTraffic( void );
    		bool TimeToMakeTraffic( int );
    		CObjectInitCond	m_initCondition;
    		int m_startFrame;
    		int m_curTimeIdx;
    		double m_randTime;
    		vector<CSnoBlock> m_traffic;
    		vector<double> m_times;
    		vector<double> m_periodicSequence;
    		vector<double> m_workingSequence;
    		bool	m_randomSequence;
    		bool	m_isRandomUniform;
    		int m_curSequenceIdx;
    		int m_curSequenceCount;
    		CRandNumGen m_rng;
    		int m_rngTime;
    		int m_rngTraffic;
    		CVED::CCoordinatorObjectObj*    m_pTraffSource;
    CHcsmBtn m_buttonMakeTraffic;
    bool GetButtonMakeTraffic();
    CDialbool m_dialStartStop;
    bool GetDialStartStop();
};

class CVehFail : public CHcsmConcurrent
{
public:
    CVehFail( CHcsmCollection*, const CSnoBlock& );
    CVehFail( const CVehFail& );
    CVehFail& operator=( const CVehFail& );
    virtual ~CVehFail();
    void SetDialFailure( string );
    void SetDialFailureNoValue();
    bool SetDialByName( const string&, const int& );
    bool SetDialByName( const string&, const double& );
    bool SetDialByName( const string&, const string& );
    bool SetDialByName( const string&, const float& );
    bool SetDialByName( const string&, const bool& );
    bool SetDialByNameStr( const string&, const string& );
    bool IsDialActiveByNameStr( const string& );
    bool ResetDialByName( const string& );

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CVehFailParseBlock* );
           void UserPreActivity( const CVehFailParseBlock* );
           void UserPostActivity( const CVehFailParseBlock* );
           void UserDeletion( const CVehFailParseBlock* );
    		int			    m_Socket;
           int             m_CmdSock;
           TFailureQueue   m_Failures;
    CDialstring m_dialFailure;
    string GetDialFailure();
};

class CDriverMirror : public CHcsmConcurrent
{
public:
    CDriverMirror( CHcsmCollection* );
    CDriverMirror( const CDriverMirror& );
    CDriverMirror& operator=( const CDriverMirror& );
    virtual ~CDriverMirror();
    void SetDialTargetVelocity( string );
    void SetDialTargetVelocityNoValue();
    CRoadPos GetMonitorRoadPos();
    CRoadPos GetMonitorTrailerPos();
    CCrdr GetMonitorTargCrdr();
    int GetMonitorStoppedBehindObj();
    string GetMonitorImTargCrdrs();
    bool SetDialByName( const string&, const int& );
    bool SetDialByName( const string&, const double& );
    bool SetDialByName( const string&, const string& );
    bool SetDialByName( const string&, const float& );
    bool SetDialByName( const string&, const bool& );
    bool SetDialByNameStr( const string&, const string& );
    bool IsDialActiveByNameStr( const string& );
    bool ResetDialByName( const string& );
    bool GetMonitorByName( const string&, CRoadPos* );
    bool GetMonitorByName( const string&, float* );
    bool GetMonitorByName( const string&, CCrdr* );
    bool GetMonitorByName( const string&, int* );
    bool GetMonitorByName( const string&, bool* );
    bool GetMonitorByName( const string&, string* );

private:
    virtual void Creation();
    virtual void Deletion();
    virtual void PreActivity();
    virtual void PostActivity();
           void UserCreation();
           void UserPreActivity();
           void UserPostActivity();
           void UserDeletion();
           deque<int> m_signaledIntrsctns;
           bool ComputeTargCrdr( CCrdr& );
           long m_prevRoadPosFrame;
           bool m_registeredHcsmId;
           CRoadPos m_currRoadPos;
           CRoadPos m_prevRoadPos;
           long m_prevTrailerPosFrame;
           CRoadPos m_currTrailerPos;
           CCrdr m_prevTargCrdr;
    CDialstring m_dialTargetVelocity;
    string GetDialTargetVelocity();
    CMonitorCRoadPos m_monitorRoadPos;
    void SetMonitorRoadPos( CRoadPos );
    void SetMonitorRoadPosNoValue();
    CMonitorCRoadPos m_monitorTrailerPos;
    void SetMonitorTrailerPos( CRoadPos );
    void SetMonitorTrailerPosNoValue();
    CMonitorCCrdr m_monitorTargCrdr;
    void SetMonitorTargCrdr( CCrdr );
    void SetMonitorTargCrdrNoValue();
    CMonitorint m_monitorStoppedBehindObj;
    void SetMonitorStoppedBehindObj( int );
    void SetMonitorStoppedBehindObjNoValue();
    CMonitorstring m_monitorImTargCrdrs;
    void SetMonitorImTargCrdrs( string );
    void SetMonitorImTargCrdrsNoValue();
};

class CTrafficData : public CHcsmConcurrent
{
public:
    CTrafficData( CHcsmCollection*, const CSnoBlock& );
    CTrafficData( const CTrafficData& );
    CTrafficData& operator=( const CTrafficData& );
    virtual ~CTrafficData();

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CTrafficDataParseBlock* );
           void UserPreActivity( const CTrafficDataParseBlock* );
           void UserPostActivity( const CTrafficDataParseBlock* );
           void UserDeletion( const CTrafficDataParseBlock* );
           bool m_logAllObjs;
           string m_logObjName;
           bool m_logAccel;
           double m_accelMin;
           double m_accelMax;
};

class CDaqDriver : public CHcsmConcurrent
{
public:
    CDaqDriver( CHcsmCollection*, const CSnoBlock& );
    CDaqDriver( const CDaqDriver& );
    CDaqDriver& operator=( const CDaqDriver& );
    virtual ~CDaqDriver();

private:
    virtual void Creation( const CSnoBlock* );
    virtual void Deletion( const CSnoBlock* );
    virtual void PreActivity( const CSnoBlock* );
    virtual void PostActivity( const CSnoBlock* );
           void UserCreation( const CDaqDriverParseBlock* );
           void UserPreActivity( const CDaqDriverParseBlock* );
           void UserPostActivity( const CDaqDriverParseBlock* );
           void UserDeletion( const CDaqDriverParseBlock* );
           void ProcessOneDaqFrame();
    		CDynObj* m_pObj;
    		CFastDeque<TDaqData> m_DaqDataContainer;
           double m_dataFreq;
           double m_executionMultiplier;
           int m_framesSinceLastExecution;
};



#endif
