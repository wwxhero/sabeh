/*****************************************************************************
 *
 *  (C) Copyright 1998 by National Advanced Driving Simulator and
 *  Simulation Center, the University of Iowa and The University
 *  of Iowa. All rights reserved.
 *
 *  This file has been generated by the hcsm code generator.
 *  ### DO NOT EDIT DIRECTLY ###
 *
 */


#include "genhcsm.h"

CDdo::CDdo(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CDdoParseBlock( snoBlock ),
            "Ddo",
            true,
            1
            )
,
    m_buttonTurnOnAnimation( pRootCollection, "TurnOnAnimation" ),
    m_buttonTurnOffAnimation( pRootCollection, "TurnOffAnimation" ),
    m_dialAudioState( pRootCollection, "AudioState" ),
    m_dialVisualState( pRootCollection, "VisualState" ),
    m_dialMode( pRootCollection, "Mode" ),
    m_dialDependent( pRootCollection, "Dependent" ),
    m_dialSpeedOverRide( pRootCollection, "SpeedOverRide" ),
    m_dialDiGuyAction( pRootCollection, "DiGuyAction" ),
    m_dialDiGuyJointOverride( pRootCollection, "DiGuyJointOverride" ),
    m_monitorRoadPos( pRootCollection, "RoadPos" )
{


}

CDdo::CDdo( const CDdo& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_buttonTurnOnAnimation( objToCopy.m_pRootCollection, objToCopy.m_buttonTurnOnAnimation.GetName() ),
    m_buttonTurnOffAnimation( objToCopy.m_pRootCollection, objToCopy.m_buttonTurnOffAnimation.GetName() ),
    m_dialAudioState( objToCopy.m_pRootCollection, objToCopy.m_dialAudioState.GetName() ),
    m_dialVisualState( objToCopy.m_pRootCollection, objToCopy.m_dialVisualState.GetName() ),
    m_dialMode( objToCopy.m_pRootCollection, objToCopy.m_dialMode.GetName() ),
    m_dialDependent( objToCopy.m_pRootCollection, objToCopy.m_dialDependent.GetName() ),
    m_dialSpeedOverRide( objToCopy.m_pRootCollection, objToCopy.m_dialSpeedOverRide.GetName() ),
    m_dialDiGuyAction( objToCopy.m_pRootCollection, objToCopy.m_dialDiGuyAction.GetName() ),
    m_dialDiGuyJointOverride( objToCopy.m_pRootCollection, objToCopy.m_dialDiGuyJointOverride.GetName() ),
    m_monitorRoadPos( objToCopy.m_pRootCollection, objToCopy.m_monitorRoadPos.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CDdo& CDdo::operator=(
            const CDdo& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CDdo::~CDdo()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CDdo::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CDdoParseBlock* pSnoBlock = dynamic_cast<const CDdoParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CDdo::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CDdoParseBlock* pSnoBlock = dynamic_cast<const CDdoParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CDdo::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CDdoParseBlock* pSnoBlock = dynamic_cast<const CDdoParseBlock*>(pBaseSnoBlock);
	UserActivity( pSnoBlock );

}

void CDdo::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CDdoParseBlock* pSnoBlock = dynamic_cast<const CDdoParseBlock*>(pBaseSnoBlock);
;

}

bool CDdo::GetButtonTurnOnAnimation()
{

    return m_buttonTurnOnAnimation.IsButtonPressed();

}

bool CDdo::GetButtonTurnOffAnimation()
{

    return m_buttonTurnOffAnimation.IsButtonPressed();

}

bool CDdo::SetButtonByName( const string& buttonName )
{

    if ( buttonName == m_buttonTurnOnAnimation.GetName() ) {
        
        m_buttonTurnOnAnimation.PressButton();
        return true;
        
    }
    
    if ( buttonName == m_buttonTurnOffAnimation.GetName() ) {
        
        m_buttonTurnOffAnimation.PressButton();
        return true;
        
    }
    
    return false;

}

int CDdo::GetDialAudioState()
{

    return m_dialAudioState.GetValue();

}

void CDdo::SetDialAudioState( int value )
{

    m_dialAudioState.SetValue( value );

}

void CDdo::SetDialAudioStateNoValue()
{

    m_dialAudioState.SetNoValue();

}

int CDdo::GetDialVisualState()
{

    return m_dialVisualState.GetValue();

}

void CDdo::SetDialVisualState( int value )
{

    m_dialVisualState.SetValue( value );

}

void CDdo::SetDialVisualStateNoValue()
{

    m_dialVisualState.SetNoValue();

}

int CDdo::GetDialMode()
{

    return m_dialMode.GetValue();

}

void CDdo::SetDialMode( int value )
{

    m_dialMode.SetValue( value );

}

void CDdo::SetDialModeNoValue()
{

    m_dialMode.SetNoValue();

}

int CDdo::GetDialDependent()
{

    return m_dialDependent.GetValue();

}

void CDdo::SetDialDependent( int value )
{

    m_dialDependent.SetValue( value );

}

void CDdo::SetDialDependentNoValue()
{

    m_dialDependent.SetNoValue();

}

double CDdo::GetDialSpeedOverRide()
{

    return m_dialSpeedOverRide.GetValue();

}

void CDdo::SetDialSpeedOverRide( double value )
{

    m_dialSpeedOverRide.SetValue( value );

}

void CDdo::SetDialSpeedOverRideNoValue()
{

    m_dialSpeedOverRide.SetNoValue();

}

string CDdo::GetDialDiGuyAction()
{

    return m_dialDiGuyAction.GetValue();

}

void CDdo::SetDialDiGuyAction( string value )
{

    m_dialDiGuyAction.SetValue( value );

}

void CDdo::SetDialDiGuyActionNoValue()
{

    m_dialDiGuyAction.SetNoValue();

}

string CDdo::GetDialDiGuyJointOverride()
{

    return m_dialDiGuyJointOverride.GetValue();

}

void CDdo::SetDialDiGuyJointOverride( string value )
{

    m_dialDiGuyJointOverride.SetValue( value );

}

void CDdo::SetDialDiGuyJointOverrideNoValue()
{

    m_dialDiGuyJointOverride.SetNoValue();

}

bool CDdo::SetDialByName( const string& dialName, const int& value )
{

    if ( dialName == m_dialAudioState.GetName() ) {
        
        m_dialAudioState.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialVisualState.GetName() ) {
        
        m_dialVisualState.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialMode.GetName() ) {
        
        m_dialMode.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialDependent.GetName() ) {
        
        m_dialDependent.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CDdo::SetDialByName( const string& dialName, const double& value )
{

    if ( dialName == m_dialSpeedOverRide.GetName() ) {
        
        m_dialSpeedOverRide.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CDdo::SetDialByName( const string& dialName, const string& value )
{

    if ( dialName == m_dialDiGuyAction.GetName() ) {
        
        m_dialDiGuyAction.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialDiGuyJointOverride.GetName() ) {
        
        m_dialDiGuyJointOverride.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CDdo::SetDialByName( const string& dialName, const float& value )
{

    
    return false;

}

bool CDdo::SetDialByName( const string& dialName, const bool& value )
{

    
    return false;

}

bool CDdo::SetDialByNameStr( const string& dialName, const string& value )
{

    if ( dialName == m_dialAudioState.GetName() ) {
        
        m_dialAudioState.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialVisualState.GetName() ) {
        
        m_dialVisualState.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialMode.GetName() ) {
        
        m_dialMode.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialDependent.GetName() ) {
        
        m_dialDependent.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialSpeedOverRide.GetName() ) {
        
        m_dialSpeedOverRide.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialDiGuyAction.GetName() ) {
        
        m_dialDiGuyAction.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialDiGuyJointOverride.GetName() ) {
        
        m_dialDiGuyJointOverride.SetValueStr( value );
        return true;
        
    }
    
    return false;

}

bool CDdo::IsDialActiveByNameStr( const string& dialName )
{

    if ( dialName == m_dialAudioState.GetName() ) {
        
        return m_dialAudioState.HasValue();
        
    }
    if ( dialName == m_dialVisualState.GetName() ) {
        
        return m_dialVisualState.HasValue();
        
    }
    if ( dialName == m_dialMode.GetName() ) {
        
        return m_dialMode.HasValue();
        
    }
    if ( dialName == m_dialDependent.GetName() ) {
        
        return m_dialDependent.HasValue();
        
    }
    if ( dialName == m_dialSpeedOverRide.GetName() ) {
        
        return m_dialSpeedOverRide.HasValue();
        
    }
    if ( dialName == m_dialDiGuyAction.GetName() ) {
        
        return m_dialDiGuyAction.HasValue();
        
    }
    if ( dialName == m_dialDiGuyJointOverride.GetName() ) {
        
        return m_dialDiGuyJointOverride.HasValue();
        
    }
    
    return false;

}

bool CDdo::ResetDialByName( const string& dialName )
{

    if ( dialName == m_dialAudioState.GetName() ) {
        
        m_dialAudioState.Reset();
        return true;
        
    }
    if ( dialName == m_dialVisualState.GetName() ) {
        
        m_dialVisualState.Reset();
        return true;
        
    }
    if ( dialName == m_dialMode.GetName() ) {
        
        m_dialMode.Reset();
        return true;
        
    }
    if ( dialName == m_dialDependent.GetName() ) {
        
        m_dialDependent.Reset();
        return true;
        
    }
    if ( dialName == m_dialSpeedOverRide.GetName() ) {
        
        m_dialSpeedOverRide.Reset();
        return true;
        
    }
    if ( dialName == m_dialDiGuyAction.GetName() ) {
        
        m_dialDiGuyAction.Reset();
        return true;
        
    }
    if ( dialName == m_dialDiGuyJointOverride.GetName() ) {
        
        m_dialDiGuyJointOverride.Reset();
        return true;
        
    }
    
    return false;

}

CRoadPos CDdo::GetMonitorRoadPos()
{

    return m_monitorRoadPos.GetValue();

}

void CDdo::SetMonitorRoadPos( CRoadPos value )
{

    m_monitorRoadPos.SetValue( value );

}

void CDdo::SetMonitorRoadPosNoValue()
{

    m_monitorRoadPos.SetNoValue();

}

bool CDdo::GetMonitorByName( const string& monitorName, CRoadPos* pValue )
{

    if ( monitorName == m_monitorRoadPos.GetName() ) {
        
        bool retVal = m_monitorRoadPos.HasValue();
        if ( retVal ) {
            *pValue = m_monitorRoadPos.GetValue();
        }
        
        return retVal;
        
    }
    
    return false;

}

bool CDdo::GetMonitorByName( const string& monitorName, float* pValue )
{

    return false;

}

bool CDdo::GetMonitorByName( const string& monitorName, CCrdr* pValue )
{

    return false;

}

bool CDdo::GetMonitorByName( const string& monitorName, int* pValue )
{

    return false;

}

bool CDdo::GetMonitorByName( const string& monitorName, bool* pValue )
{

    return false;

}

bool CDdo::GetMonitorByName( const string& monitorName, string* pValue )
{

    return false;

}

CVirtualObject::CVirtualObject(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CVirtualObjectParseBlock( snoBlock ),
            "VirtualObject",
            true,
            2
            )
,
    m_buttonTurnOnAnimation( pRootCollection, "TurnOnAnimation" ),
    m_buttonTurnOffAnimation( pRootCollection, "TurnOffAnimation" ),
    m_dialSetAnimation( pRootCollection, "SetAnimation" ),
    m_dialSetRotation( pRootCollection, "SetRotation" ),
    m_dialSetPosition( pRootCollection, "SetPosition" ),
    m_dialSetStateIndex( pRootCollection, "SetStateIndex" ),
    m_dialSetDrawType( pRootCollection, "SetDrawType" ),
    m_dialAttachToObject( pRootCollection, "AttachToObject" ),
    m_dialAttachToLight( pRootCollection, "AttachToLight" )
{


}

CVirtualObject::CVirtualObject( const CVirtualObject& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_buttonTurnOnAnimation( objToCopy.m_pRootCollection, objToCopy.m_buttonTurnOnAnimation.GetName() ),
    m_buttonTurnOffAnimation( objToCopy.m_pRootCollection, objToCopy.m_buttonTurnOffAnimation.GetName() ),
    m_dialSetAnimation( objToCopy.m_pRootCollection, objToCopy.m_dialSetAnimation.GetName() ),
    m_dialSetRotation( objToCopy.m_pRootCollection, objToCopy.m_dialSetRotation.GetName() ),
    m_dialSetPosition( objToCopy.m_pRootCollection, objToCopy.m_dialSetPosition.GetName() ),
    m_dialSetStateIndex( objToCopy.m_pRootCollection, objToCopy.m_dialSetStateIndex.GetName() ),
    m_dialSetDrawType( objToCopy.m_pRootCollection, objToCopy.m_dialSetDrawType.GetName() ),
    m_dialAttachToObject( objToCopy.m_pRootCollection, objToCopy.m_dialAttachToObject.GetName() ),
    m_dialAttachToLight( objToCopy.m_pRootCollection, objToCopy.m_dialAttachToLight.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CVirtualObject& CVirtualObject::operator=(
            const CVirtualObject& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CVirtualObject::~CVirtualObject()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CVirtualObject::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CVirtualObjectParseBlock* pSnoBlock = dynamic_cast<const CVirtualObjectParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CVirtualObject::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CVirtualObjectParseBlock* pSnoBlock = dynamic_cast<const CVirtualObjectParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CVirtualObject::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CVirtualObjectParseBlock* pSnoBlock = dynamic_cast<const CVirtualObjectParseBlock*>(pBaseSnoBlock);
	UserActivity( pSnoBlock );

}

void CVirtualObject::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CVirtualObjectParseBlock* pSnoBlock = dynamic_cast<const CVirtualObjectParseBlock*>(pBaseSnoBlock);
	UserPostActivity( pSnoBlock );

}

bool CVirtualObject::GetButtonTurnOnAnimation()
{

    return m_buttonTurnOnAnimation.IsButtonPressed();

}

bool CVirtualObject::GetButtonTurnOffAnimation()
{

    return m_buttonTurnOffAnimation.IsButtonPressed();

}

bool CVirtualObject::SetButtonByName( const string& buttonName )
{

    if ( buttonName == m_buttonTurnOnAnimation.GetName() ) {
        
        m_buttonTurnOnAnimation.PressButton();
        return true;
        
    }
    
    if ( buttonName == m_buttonTurnOffAnimation.GetName() ) {
        
        m_buttonTurnOffAnimation.PressButton();
        return true;
        
    }
    
    return false;

}

string CVirtualObject::GetDialSetAnimation()
{

    return m_dialSetAnimation.GetValue();

}

void CVirtualObject::SetDialSetAnimation( string value )
{

    m_dialSetAnimation.SetValue( value );

}

void CVirtualObject::SetDialSetAnimationNoValue()
{

    m_dialSetAnimation.SetNoValue();

}

float CVirtualObject::GetDialSetRotation()
{

    return m_dialSetRotation.GetValue();

}

void CVirtualObject::SetDialSetRotation( float value )
{

    m_dialSetRotation.SetValue( value );

}

void CVirtualObject::SetDialSetRotationNoValue()
{

    m_dialSetRotation.SetNoValue();

}

string CVirtualObject::GetDialSetPosition()
{

    return m_dialSetPosition.GetValue();

}

void CVirtualObject::SetDialSetPosition( string value )
{

    m_dialSetPosition.SetValue( value );

}

void CVirtualObject::SetDialSetPositionNoValue()
{

    m_dialSetPosition.SetNoValue();

}

string CVirtualObject::GetDialSetStateIndex()
{

    return m_dialSetStateIndex.GetValue();

}

void CVirtualObject::SetDialSetStateIndex( string value )
{

    m_dialSetStateIndex.SetValue( value );

}

void CVirtualObject::SetDialSetStateIndexNoValue()
{

    m_dialSetStateIndex.SetNoValue();

}

int CVirtualObject::GetDialSetDrawType()
{

    return m_dialSetDrawType.GetValue();

}

void CVirtualObject::SetDialSetDrawType( int value )
{

    m_dialSetDrawType.SetValue( value );

}

void CVirtualObject::SetDialSetDrawTypeNoValue()
{

    m_dialSetDrawType.SetNoValue();

}

string CVirtualObject::GetDialAttachToObject()
{

    return m_dialAttachToObject.GetValue();

}

void CVirtualObject::SetDialAttachToObject( string value )
{

    m_dialAttachToObject.SetValue( value );

}

void CVirtualObject::SetDialAttachToObjectNoValue()
{

    m_dialAttachToObject.SetNoValue();

}

int CVirtualObject::GetDialAttachToLight()
{

    return m_dialAttachToLight.GetValue();

}

void CVirtualObject::SetDialAttachToLight( int value )
{

    m_dialAttachToLight.SetValue( value );

}

void CVirtualObject::SetDialAttachToLightNoValue()
{

    m_dialAttachToLight.SetNoValue();

}

bool CVirtualObject::SetDialByName( const string& dialName, const int& value )
{

    if ( dialName == m_dialSetDrawType.GetName() ) {
        
        m_dialSetDrawType.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialAttachToLight.GetName() ) {
        
        m_dialAttachToLight.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CVirtualObject::SetDialByName( const string& dialName, const double& value )
{

    
    return false;

}

bool CVirtualObject::SetDialByName( const string& dialName, const string& value )
{

    if ( dialName == m_dialSetAnimation.GetName() ) {
        
        m_dialSetAnimation.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialSetPosition.GetName() ) {
        
        m_dialSetPosition.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialSetStateIndex.GetName() ) {
        
        m_dialSetStateIndex.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialAttachToObject.GetName() ) {
        
        m_dialAttachToObject.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CVirtualObject::SetDialByName( const string& dialName, const float& value )
{

    if ( dialName == m_dialSetRotation.GetName() ) {
        
        m_dialSetRotation.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CVirtualObject::SetDialByName( const string& dialName, const bool& value )
{

    
    return false;

}

bool CVirtualObject::SetDialByNameStr( const string& dialName, const string& value )
{

    if ( dialName == m_dialSetAnimation.GetName() ) {
        
        m_dialSetAnimation.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialSetRotation.GetName() ) {
        
        m_dialSetRotation.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialSetPosition.GetName() ) {
        
        m_dialSetPosition.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialSetStateIndex.GetName() ) {
        
        m_dialSetStateIndex.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialSetDrawType.GetName() ) {
        
        m_dialSetDrawType.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialAttachToObject.GetName() ) {
        
        m_dialAttachToObject.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialAttachToLight.GetName() ) {
        
        m_dialAttachToLight.SetValueStr( value );
        return true;
        
    }
    
    return false;

}

bool CVirtualObject::IsDialActiveByNameStr( const string& dialName )
{

    if ( dialName == m_dialSetAnimation.GetName() ) {
        
        return m_dialSetAnimation.HasValue();
        
    }
    if ( dialName == m_dialSetRotation.GetName() ) {
        
        return m_dialSetRotation.HasValue();
        
    }
    if ( dialName == m_dialSetPosition.GetName() ) {
        
        return m_dialSetPosition.HasValue();
        
    }
    if ( dialName == m_dialSetStateIndex.GetName() ) {
        
        return m_dialSetStateIndex.HasValue();
        
    }
    if ( dialName == m_dialSetDrawType.GetName() ) {
        
        return m_dialSetDrawType.HasValue();
        
    }
    if ( dialName == m_dialAttachToObject.GetName() ) {
        
        return m_dialAttachToObject.HasValue();
        
    }
    if ( dialName == m_dialAttachToLight.GetName() ) {
        
        return m_dialAttachToLight.HasValue();
        
    }
    
    return false;

}

bool CVirtualObject::ResetDialByName( const string& dialName )
{

    if ( dialName == m_dialSetAnimation.GetName() ) {
        
        m_dialSetAnimation.Reset();
        return true;
        
    }
    if ( dialName == m_dialSetRotation.GetName() ) {
        
        m_dialSetRotation.Reset();
        return true;
        
    }
    if ( dialName == m_dialSetPosition.GetName() ) {
        
        m_dialSetPosition.Reset();
        return true;
        
    }
    if ( dialName == m_dialSetStateIndex.GetName() ) {
        
        m_dialSetStateIndex.Reset();
        return true;
        
    }
    if ( dialName == m_dialSetDrawType.GetName() ) {
        
        m_dialSetDrawType.Reset();
        return true;
        
    }
    if ( dialName == m_dialAttachToObject.GetName() ) {
        
        m_dialAttachToObject.Reset();
        return true;
        
    }
    if ( dialName == m_dialAttachToLight.GetName() ) {
        
        m_dialAttachToLight.Reset();
        return true;
        
    }
    
    return false;

}

CTimeTrigger::CTimeTrigger(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CTriggerParseBlock( snoBlock ),
            "TimeTrigger",
            true,
            3
            )
,
    m_buttonFireTrigger( pRootCollection, "FireTrigger" )
{


}

CTimeTrigger::CTimeTrigger( const CTimeTrigger& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_buttonFireTrigger( objToCopy.m_pRootCollection, objToCopy.m_buttonFireTrigger.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CTimeTrigger& CTimeTrigger::operator=(
            const CTimeTrigger& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CTimeTrigger::~CTimeTrigger()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CTimeTrigger::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CTimeTrigger::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CTimeTrigger::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserActivity( pSnoBlock );

}

void CTimeTrigger::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	;

}

bool CTimeTrigger::GetButtonFireTrigger()
{

    return m_buttonFireTrigger.IsButtonPressed();

}

bool CTimeTrigger::SetButtonByName( const string& buttonName )
{

    if ( buttonName == m_buttonFireTrigger.GetName() ) {
        
        m_buttonFireTrigger.PressButton();
        return true;
        
    }
    
    return false;

}

CGmtrcPstnTrigger::CGmtrcPstnTrigger(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CTriggerParseBlock( snoBlock ),
            "GmtrcPstnTrigger",
            true,
            4
            )
,
    m_buttonFireTrigger( pRootCollection, "FireTrigger" )
{


}

CGmtrcPstnTrigger::CGmtrcPstnTrigger( const CGmtrcPstnTrigger& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_buttonFireTrigger( objToCopy.m_pRootCollection, objToCopy.m_buttonFireTrigger.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CGmtrcPstnTrigger& CGmtrcPstnTrigger::operator=(
            const CGmtrcPstnTrigger& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CGmtrcPstnTrigger::~CGmtrcPstnTrigger()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CGmtrcPstnTrigger::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CGmtrcPstnTrigger::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CGmtrcPstnTrigger::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserActivity( pSnoBlock );

}

void CGmtrcPstnTrigger::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	;

}

bool CGmtrcPstnTrigger::GetButtonFireTrigger()
{

    return m_buttonFireTrigger.IsButtonPressed();

}

bool CGmtrcPstnTrigger::SetButtonByName( const string& buttonName )
{

    if ( buttonName == m_buttonFireTrigger.GetName() ) {
        
        m_buttonFireTrigger.PressButton();
        return true;
        
    }
    
    return false;

}

CTrffcLghtTrigger::CTrffcLghtTrigger(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CTriggerParseBlock( snoBlock ),
            "TrffcLghtTrigger",
            true,
            5
            )
,
    m_buttonFireTrigger( pRootCollection, "FireTrigger" )
{


}

CTrffcLghtTrigger::CTrffcLghtTrigger( const CTrffcLghtTrigger& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_buttonFireTrigger( objToCopy.m_pRootCollection, objToCopy.m_buttonFireTrigger.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CTrffcLghtTrigger& CTrffcLghtTrigger::operator=(
            const CTrffcLghtTrigger& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CTrffcLghtTrigger::~CTrffcLghtTrigger()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CTrffcLghtTrigger::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CTrffcLghtTrigger::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CTrffcLghtTrigger::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserActivity( pSnoBlock );

}

void CTrffcLghtTrigger::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	;

}

bool CTrffcLghtTrigger::GetButtonFireTrigger()
{

    return m_buttonFireTrigger.IsButtonPressed();

}

bool CTrffcLghtTrigger::SetButtonByName( const string& buttonName )
{

    if ( buttonName == m_buttonFireTrigger.GetName() ) {
        
        m_buttonFireTrigger.PressButton();
        return true;
        
    }
    
    return false;

}

CRoadPadTrigger::CRoadPadTrigger(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CTriggerParseBlock( snoBlock ),
            "RoadPadTrigger",
            true,
            6
            )
,
    m_buttonFireTrigger( pRootCollection, "FireTrigger" )
{


}

CRoadPadTrigger::CRoadPadTrigger( const CRoadPadTrigger& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_buttonFireTrigger( objToCopy.m_pRootCollection, objToCopy.m_buttonFireTrigger.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CRoadPadTrigger& CRoadPadTrigger::operator=(
            const CRoadPadTrigger& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CRoadPadTrigger::~CRoadPadTrigger()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CRoadPadTrigger::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CRoadPadTrigger::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CRoadPadTrigger::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserActivity( pSnoBlock );

}

void CRoadPadTrigger::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	;

}

bool CRoadPadTrigger::GetButtonFireTrigger()
{

    return m_buttonFireTrigger.IsButtonPressed();

}

bool CRoadPadTrigger::SetButtonByName( const string& buttonName )
{

    if ( buttonName == m_buttonFireTrigger.GetName() ) {
        
        m_buttonFireTrigger.PressButton();
        return true;
        
    }
    
    return false;

}

CExpressionTrigger::CExpressionTrigger(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CTriggerParseBlock( snoBlock ),
            "ExpressionTrigger",
            true,
            7
            )
,
    m_buttonFireTrigger( pRootCollection, "FireTrigger" )
{


}

CExpressionTrigger::CExpressionTrigger( const CExpressionTrigger& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_buttonFireTrigger( objToCopy.m_pRootCollection, objToCopy.m_buttonFireTrigger.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CExpressionTrigger& CExpressionTrigger::operator=(
            const CExpressionTrigger& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CExpressionTrigger::~CExpressionTrigger()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CExpressionTrigger::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CExpressionTrigger::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CExpressionTrigger::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserActivity( pSnoBlock );

}

void CExpressionTrigger::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	;

}

bool CExpressionTrigger::GetButtonFireTrigger()
{

    return m_buttonFireTrigger.IsButtonPressed();

}

bool CExpressionTrigger::SetButtonByName( const string& buttonName )
{

    if ( buttonName == m_buttonFireTrigger.GetName() ) {
        
        m_buttonFireTrigger.PressButton();
        return true;
        
    }
    
    return false;

}

CFollowTrigger::CFollowTrigger(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CTriggerParseBlock( snoBlock ),
            "FollowTrigger",
            true,
            8
            )
,
    m_buttonFireTrigger( pRootCollection, "FireTrigger" )
{


}

CFollowTrigger::CFollowTrigger( const CFollowTrigger& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_buttonFireTrigger( objToCopy.m_pRootCollection, objToCopy.m_buttonFireTrigger.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CFollowTrigger& CFollowTrigger::operator=(
            const CFollowTrigger& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CFollowTrigger::~CFollowTrigger()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CFollowTrigger::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CFollowTrigger::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CFollowTrigger::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserActivity( pSnoBlock );

}

void CFollowTrigger::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	;

}

bool CFollowTrigger::GetButtonFireTrigger()
{

    return m_buttonFireTrigger.IsButtonPressed();

}

bool CFollowTrigger::SetButtonByName( const string& buttonName )
{

    if ( buttonName == m_buttonFireTrigger.GetName() ) {
        
        m_buttonFireTrigger.PressButton();
        return true;
        
    }
    
    return false;

}

CTimeToArrvlTrigger::CTimeToArrvlTrigger(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CTriggerParseBlock( snoBlock ),
            "TimeToArrvlTrigger",
            true,
            9
            )
,
    m_buttonFireTrigger( pRootCollection, "FireTrigger" )
{


}

CTimeToArrvlTrigger::CTimeToArrvlTrigger( const CTimeToArrvlTrigger& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_buttonFireTrigger( objToCopy.m_pRootCollection, objToCopy.m_buttonFireTrigger.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CTimeToArrvlTrigger& CTimeToArrvlTrigger::operator=(
            const CTimeToArrvlTrigger& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CTimeToArrvlTrigger::~CTimeToArrvlTrigger()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CTimeToArrvlTrigger::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CTimeToArrvlTrigger::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CTimeToArrvlTrigger::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	UserActivity( pSnoBlock );

}

void CTimeToArrvlTrigger::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTriggerParseBlock* pSnoBlock = dynamic_cast<const CTriggerParseBlock*>(pBaseSnoBlock);
	;

}

bool CTimeToArrvlTrigger::GetButtonFireTrigger()
{

    return m_buttonFireTrigger.IsButtonPressed();

}

bool CTimeToArrvlTrigger::SetButtonByName( const string& buttonName )
{

    if ( buttonName == m_buttonFireTrigger.GetName() ) {
        
        m_buttonFireTrigger.PressButton();
        return true;
        
    }
    
    return false;

}

CGateway::CGateway(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CGatewayParseBlock( snoBlock ),
            "Gateway",
            true,
            10
            )

{


}

CGateway::CGateway( const CGateway& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            )
{

    // call the assignment operator
    *this = objToCopy;

}

CGateway& CGateway::operator=(
            const CGateway& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CGateway::~CGateway()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CGateway::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CGatewayParseBlock* pSnoBlock = dynamic_cast<const CGatewayParseBlock*>(pBaseSnoBlock);
	CreateWorker( pSnoBlock );

}

void CGateway::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CGatewayParseBlock* pSnoBlock = dynamic_cast<const CGatewayParseBlock*>(pBaseSnoBlock);
	DeleteWorker( pSnoBlock );

}

void CGateway::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CGatewayParseBlock* pSnoBlock = dynamic_cast<const CGatewayParseBlock*>(pBaseSnoBlock);
	Worker( );

}

CAdo::CAdo(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmSequential(
            pRootCollection,
            new CAdoParseBlock( snoBlock ),
            "Ado",
            true,
            11
            )
,
    m_buttonChangeLaneLeft( pRootCollection, "ChangeLaneLeft" ),
    m_buttonChangeLaneRight( pRootCollection, "ChangeLaneRight" ),
    m_buttonTurnLeft( pRootCollection, "TurnLeft" ),
    m_buttonTurnRight( pRootCollection, "TurnRight" ),
    m_buttonProjectAndResetLaneOffset( pRootCollection, "ProjectAndResetLaneOffset" ),
    m_buttonAutoControlBrakeLightsOn( pRootCollection, "AutoControlBrakeLightsOn" ),
    m_buttonAutoControlBrakeLightsOff( pRootCollection, "AutoControlBrakeLightsOff" ),
    m_buttonInhibitLaneChangeOn( pRootCollection, "InhibitLaneChangeOn" ),
    m_buttonInhibitLaneChangeOff( pRootCollection, "InhibitLaneChangeOff" ),
    m_dialAudioState( pRootCollection, "AudioState" ),
    m_dialForcedLaneOffset( pRootCollection, "ForcedLaneOffset" ),
    m_dialForcedVelocity( pRootCollection, "ForcedVelocity" ),
    m_dialForcedSteeringAngle( pRootCollection, "ForcedSteeringAngle" ),
    m_dialImStop( pRootCollection, "ImStop" ),
    m_dialInhibitLaneChange( pRootCollection, "InhibitLaneChange" ),
    m_dialLaneChange( pRootCollection, "LaneChange" ),
    m_dialLaneChangeStatus( pRootCollection, "LaneChangeStatus" ),
    m_dialMaintainGap( pRootCollection, "MaintainGap" ),
    m_dialTargetVelocity( pRootCollection, "TargetVelocity" ),
    m_dialVisualState( pRootCollection, "VisualState" ),
    m_monitorRoadPos( pRootCollection, "RoadPos" ),
    m_monitorDistanceToNextHldOffset( pRootCollection, "DistanceToNextHldOffset" ),
    m_monitorTargCrdr( pRootCollection, "TargCrdr" ),
    m_monitorStoppedBehindObj( pRootCollection, "StoppedBehindObj" ),
    m_monitorHasStopSignTarget( pRootCollection, "HasStopSignTarget" ),
    m_monitorImTargCrdrs( pRootCollection, "ImTargCrdrs" ),
    m_monitorStoppedAtStopSignFrame( pRootCollection, "StoppedAtStopSignFrame" )
{

    // add my children
    AddChild( new CAutonomous( pRootCollection, snoBlock ) );
    AddChild( new CRemoteControl( pRootCollection, snoBlock ) );

    m_activeChild = m_children[0];
    m_defaultActiveChild = m_children[0];


}

CAdo::CAdo( const CAdo& objToCopy ):
    CHcsmSequential(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_buttonChangeLaneLeft( objToCopy.m_pRootCollection, objToCopy.m_buttonChangeLaneLeft.GetName() ),
    m_buttonChangeLaneRight( objToCopy.m_pRootCollection, objToCopy.m_buttonChangeLaneRight.GetName() ),
    m_buttonTurnLeft( objToCopy.m_pRootCollection, objToCopy.m_buttonTurnLeft.GetName() ),
    m_buttonTurnRight( objToCopy.m_pRootCollection, objToCopy.m_buttonTurnRight.GetName() ),
    m_buttonProjectAndResetLaneOffset( objToCopy.m_pRootCollection, objToCopy.m_buttonProjectAndResetLaneOffset.GetName() ),
    m_buttonAutoControlBrakeLightsOn( objToCopy.m_pRootCollection, objToCopy.m_buttonAutoControlBrakeLightsOn.GetName() ),
    m_buttonAutoControlBrakeLightsOff( objToCopy.m_pRootCollection, objToCopy.m_buttonAutoControlBrakeLightsOff.GetName() ),
    m_buttonInhibitLaneChangeOn( objToCopy.m_pRootCollection, objToCopy.m_buttonInhibitLaneChangeOn.GetName() ),
    m_buttonInhibitLaneChangeOff( objToCopy.m_pRootCollection, objToCopy.m_buttonInhibitLaneChangeOff.GetName() ),
    m_dialAudioState( objToCopy.m_pRootCollection, objToCopy.m_dialAudioState.GetName() ),
    m_dialForcedLaneOffset( objToCopy.m_pRootCollection, objToCopy.m_dialForcedLaneOffset.GetName() ),
    m_dialForcedVelocity( objToCopy.m_pRootCollection, objToCopy.m_dialForcedVelocity.GetName() ),
    m_dialForcedSteeringAngle( objToCopy.m_pRootCollection, objToCopy.m_dialForcedSteeringAngle.GetName() ),
    m_dialImStop( objToCopy.m_pRootCollection, objToCopy.m_dialImStop.GetName() ),
    m_dialInhibitLaneChange( objToCopy.m_pRootCollection, objToCopy.m_dialInhibitLaneChange.GetName() ),
    m_dialLaneChange( objToCopy.m_pRootCollection, objToCopy.m_dialLaneChange.GetName() ),
    m_dialLaneChangeStatus( objToCopy.m_pRootCollection, objToCopy.m_dialLaneChangeStatus.GetName() ),
    m_dialMaintainGap( objToCopy.m_pRootCollection, objToCopy.m_dialMaintainGap.GetName() ),
    m_dialTargetVelocity( objToCopy.m_pRootCollection, objToCopy.m_dialTargetVelocity.GetName() ),
    m_dialVisualState( objToCopy.m_pRootCollection, objToCopy.m_dialVisualState.GetName() ),
    m_monitorRoadPos( objToCopy.m_pRootCollection, objToCopy.m_monitorRoadPos.GetName() ),
    m_monitorDistanceToNextHldOffset( objToCopy.m_pRootCollection, objToCopy.m_monitorDistanceToNextHldOffset.GetName() ),
    m_monitorTargCrdr( objToCopy.m_pRootCollection, objToCopy.m_monitorTargCrdr.GetName() ),
    m_monitorStoppedBehindObj( objToCopy.m_pRootCollection, objToCopy.m_monitorStoppedBehindObj.GetName() ),
    m_monitorHasStopSignTarget( objToCopy.m_pRootCollection, objToCopy.m_monitorHasStopSignTarget.GetName() ),
    m_monitorImTargCrdrs( objToCopy.m_pRootCollection, objToCopy.m_monitorImTargCrdrs.GetName() ),
    m_monitorStoppedAtStopSignFrame( objToCopy.m_pRootCollection, objToCopy.m_monitorStoppedAtStopSignFrame.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CAdo& CAdo::operator=(
            const CAdo& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CAdo::~CAdo()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CAdo::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CAdo::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CAdo::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	UserPreActivity( pSnoBlock );

}

void CAdo::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	UserPostActivity( pSnoBlock );

}

void CAdo::ExecuteTransitions()
{

    // from "Autonomous" to "RemoteControl"
    if ( m_activeChild == m_children[0] && m_children[0]->ExecutePredicate( 1 ) ) {
        
        m_activeChild = m_children[1];
        return;
        
    }

    // from "RemoteControl" to "Autonomous"
    if ( m_activeChild == m_children[1] && m_children[1]->ExecutePredicate( 2 ) ) {
        
        m_activeChild = m_children[0];
        return;
        
    }

}

void CAdo::SetInputpIForAutonomous( CAdoInfoPtr value )
{

    ( dynamic_cast<CAutonomous*>(m_children[0]) )->SetInputpI( value );

}

void CAdo::SetInputpIForRemoteControl( CAdoInfoPtr value )
{

    ( dynamic_cast<CRemoteControl*>(m_children[1]) )->SetInputpI( value );

}

CPoint3D CAdo::GetOutputTargPosFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->GetOutputTargPos();

}

bool CAdo::HasValueOutputTargPosFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->HasValueOutputTargPos();

}

double CAdo::GetOutputTargSteerFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->GetOutputTargSteer();

}

bool CAdo::HasValueOutputTargSteerFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->HasValueOutputTargSteer();

}

double CAdo::GetOutputTargAccelFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->GetOutputTargAccel();

}

bool CAdo::HasValueOutputTargAccelFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->HasValueOutputTargAccel();

}

string CAdo::GetOutputImTargCrdrsFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->GetOutputImTargCrdrs();

}

bool CAdo::HasValueOutputImTargCrdrsFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->HasValueOutputImTargCrdrs();

}

bool CAdo::GetOutputHasStopSignTargetFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->GetOutputHasStopSignTarget();

}

bool CAdo::HasValueOutputHasStopSignTargetFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->HasValueOutputHasStopSignTarget();

}

int CAdo::GetOutputStoppedAtStopSignFrameFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->GetOutputStoppedAtStopSignFrame();

}

bool CAdo::HasValueOutputStoppedAtStopSignFrameFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->HasValueOutputStoppedAtStopSignFrame();

}

double CAdo::GetOutputMaxSteerFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->GetOutputMaxSteer();

}

bool CAdo::HasValueOutputMaxSteerFromRemoteControl()
{

    return ( dynamic_cast<CRemoteControl*>(m_children[1]) )->HasValueOutputMaxSteer();

}

bool CAdo::GetButtonChangeLaneLeft()
{

    return m_buttonChangeLaneLeft.IsButtonPressed();

}

bool CAdo::GetButtonChangeLaneRight()
{

    return m_buttonChangeLaneRight.IsButtonPressed();

}

bool CAdo::GetButtonTurnLeft()
{

    return m_buttonTurnLeft.IsButtonPressed();

}

bool CAdo::GetButtonTurnRight()
{

    return m_buttonTurnRight.IsButtonPressed();

}

bool CAdo::GetButtonProjectAndResetLaneOffset()
{

    return m_buttonProjectAndResetLaneOffset.IsButtonPressed();

}

bool CAdo::GetButtonAutoControlBrakeLightsOn()
{

    return m_buttonAutoControlBrakeLightsOn.IsButtonPressed();

}

bool CAdo::GetButtonAutoControlBrakeLightsOff()
{

    return m_buttonAutoControlBrakeLightsOff.IsButtonPressed();

}

bool CAdo::GetButtonInhibitLaneChangeOn()
{

    return m_buttonInhibitLaneChangeOn.IsButtonPressed();

}

bool CAdo::GetButtonInhibitLaneChangeOff()
{

    return m_buttonInhibitLaneChangeOff.IsButtonPressed();

}

bool CAdo::SetButtonByName( const string& buttonName )
{

    if ( buttonName == m_buttonChangeLaneLeft.GetName() ) {
        
        m_buttonChangeLaneLeft.PressButton();
        return true;
        
    }
    
    if ( buttonName == m_buttonChangeLaneRight.GetName() ) {
        
        m_buttonChangeLaneRight.PressButton();
        return true;
        
    }
    
    if ( buttonName == m_buttonTurnLeft.GetName() ) {
        
        m_buttonTurnLeft.PressButton();
        return true;
        
    }
    
    if ( buttonName == m_buttonTurnRight.GetName() ) {
        
        m_buttonTurnRight.PressButton();
        return true;
        
    }
    
    if ( buttonName == m_buttonProjectAndResetLaneOffset.GetName() ) {
        
        m_buttonProjectAndResetLaneOffset.PressButton();
        return true;
        
    }
    
    if ( buttonName == m_buttonAutoControlBrakeLightsOn.GetName() ) {
        
        m_buttonAutoControlBrakeLightsOn.PressButton();
        return true;
        
    }
    
    if ( buttonName == m_buttonAutoControlBrakeLightsOff.GetName() ) {
        
        m_buttonAutoControlBrakeLightsOff.PressButton();
        return true;
        
    }
    
    if ( buttonName == m_buttonInhibitLaneChangeOn.GetName() ) {
        
        m_buttonInhibitLaneChangeOn.PressButton();
        return true;
        
    }
    
    if ( buttonName == m_buttonInhibitLaneChangeOff.GetName() ) {
        
        m_buttonInhibitLaneChangeOff.PressButton();
        return true;
        
    }
    
    return false;

}

string CAdo::GetDialAudioState()
{

    return m_dialAudioState.GetValue();

}

void CAdo::SetDialAudioState( string value )
{

    m_dialAudioState.SetValue( value );

}

void CAdo::SetDialAudioStateNoValue()
{

    m_dialAudioState.SetNoValue();

}

string CAdo::GetDialForcedLaneOffset()
{

    return m_dialForcedLaneOffset.GetValue();

}

void CAdo::SetDialForcedLaneOffset( string value )
{

    m_dialForcedLaneOffset.SetValue( value );

}

void CAdo::SetDialForcedLaneOffsetNoValue()
{

    m_dialForcedLaneOffset.SetNoValue();

}

string CAdo::GetDialForcedVelocity()
{

    return m_dialForcedVelocity.GetValue();

}

void CAdo::SetDialForcedVelocity( string value )
{

    m_dialForcedVelocity.SetValue( value );

}

void CAdo::SetDialForcedVelocityNoValue()
{

    m_dialForcedVelocity.SetNoValue();

}

string CAdo::GetDialForcedSteeringAngle()
{

    return m_dialForcedSteeringAngle.GetValue();

}

void CAdo::SetDialForcedSteeringAngle( string value )
{

    m_dialForcedSteeringAngle.SetValue( value );

}

void CAdo::SetDialForcedSteeringAngleNoValue()
{

    m_dialForcedSteeringAngle.SetNoValue();

}

double CAdo::GetDialImStop()
{

    return m_dialImStop.GetValue();

}

void CAdo::SetDialImStop( double value )
{

    m_dialImStop.SetValue( value );

}

void CAdo::SetDialImStopNoValue()
{

    m_dialImStop.SetNoValue();

}

double CAdo::GetDialInhibitLaneChange()
{

    return m_dialInhibitLaneChange.GetValue();

}

void CAdo::SetDialInhibitLaneChange( double value )
{

    m_dialInhibitLaneChange.SetValue( value );

}

void CAdo::SetDialInhibitLaneChangeNoValue()
{

    m_dialInhibitLaneChange.SetNoValue();

}

string CAdo::GetDialLaneChange()
{

    return m_dialLaneChange.GetValue();

}

void CAdo::SetDialLaneChange( string value )
{

    m_dialLaneChange.SetValue( value );

}

void CAdo::SetDialLaneChangeNoValue()
{

    m_dialLaneChange.SetNoValue();

}

string CAdo::GetDialLaneChangeStatus()
{

    return m_dialLaneChangeStatus.GetValue();

}

void CAdo::SetDialLaneChangeStatus( string value )
{

    m_dialLaneChangeStatus.SetValue( value );

}

void CAdo::SetDialLaneChangeStatusNoValue()
{

    m_dialLaneChangeStatus.SetNoValue();

}

string CAdo::GetDialMaintainGap()
{

    return m_dialMaintainGap.GetValue();

}

void CAdo::SetDialMaintainGap( string value )
{

    m_dialMaintainGap.SetValue( value );

}

void CAdo::SetDialMaintainGapNoValue()
{

    m_dialMaintainGap.SetNoValue();

}

string CAdo::GetDialTargetVelocity()
{

    return m_dialTargetVelocity.GetValue();

}

void CAdo::SetDialTargetVelocity( string value )
{

    m_dialTargetVelocity.SetValue( value );

}

void CAdo::SetDialTargetVelocityNoValue()
{

    m_dialTargetVelocity.SetNoValue();

}

string CAdo::GetDialVisualState()
{

    return m_dialVisualState.GetValue();

}

void CAdo::SetDialVisualState( string value )
{

    m_dialVisualState.SetValue( value );

}

void CAdo::SetDialVisualStateNoValue()
{

    m_dialVisualState.SetNoValue();

}

bool CAdo::SetDialByName( const string& dialName, const int& value )
{

    
    return false;

}

bool CAdo::SetDialByName( const string& dialName, const double& value )
{

    if ( dialName == m_dialImStop.GetName() ) {
        
        m_dialImStop.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialInhibitLaneChange.GetName() ) {
        
        m_dialInhibitLaneChange.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CAdo::SetDialByName( const string& dialName, const string& value )
{

    if ( dialName == m_dialAudioState.GetName() ) {
        
        m_dialAudioState.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialForcedLaneOffset.GetName() ) {
        
        m_dialForcedLaneOffset.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialForcedVelocity.GetName() ) {
        
        m_dialForcedVelocity.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialForcedSteeringAngle.GetName() ) {
        
        m_dialForcedSteeringAngle.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialLaneChange.GetName() ) {
        
        m_dialLaneChange.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialLaneChangeStatus.GetName() ) {
        
        m_dialLaneChangeStatus.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialMaintainGap.GetName() ) {
        
        m_dialMaintainGap.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialTargetVelocity.GetName() ) {
        
        m_dialTargetVelocity.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialVisualState.GetName() ) {
        
        m_dialVisualState.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CAdo::SetDialByName( const string& dialName, const float& value )
{

    
    return false;

}

bool CAdo::SetDialByName( const string& dialName, const bool& value )
{

    
    return false;

}

bool CAdo::SetDialByNameStr( const string& dialName, const string& value )
{

    if ( dialName == m_dialAudioState.GetName() ) {
        
        m_dialAudioState.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialForcedLaneOffset.GetName() ) {
        
        m_dialForcedLaneOffset.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialForcedVelocity.GetName() ) {
        
        m_dialForcedVelocity.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialForcedSteeringAngle.GetName() ) {
        
        m_dialForcedSteeringAngle.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialImStop.GetName() ) {
        
        m_dialImStop.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialInhibitLaneChange.GetName() ) {
        
        m_dialInhibitLaneChange.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialLaneChange.GetName() ) {
        
        m_dialLaneChange.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialLaneChangeStatus.GetName() ) {
        
        m_dialLaneChangeStatus.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialMaintainGap.GetName() ) {
        
        m_dialMaintainGap.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialTargetVelocity.GetName() ) {
        
        m_dialTargetVelocity.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialVisualState.GetName() ) {
        
        m_dialVisualState.SetValueStr( value );
        return true;
        
    }
    
    return false;

}

bool CAdo::IsDialActiveByNameStr( const string& dialName )
{

    if ( dialName == m_dialAudioState.GetName() ) {
        
        return m_dialAudioState.HasValue();
        
    }
    if ( dialName == m_dialForcedLaneOffset.GetName() ) {
        
        return m_dialForcedLaneOffset.HasValue();
        
    }
    if ( dialName == m_dialForcedVelocity.GetName() ) {
        
        return m_dialForcedVelocity.HasValue();
        
    }
    if ( dialName == m_dialForcedSteeringAngle.GetName() ) {
        
        return m_dialForcedSteeringAngle.HasValue();
        
    }
    if ( dialName == m_dialImStop.GetName() ) {
        
        return m_dialImStop.HasValue();
        
    }
    if ( dialName == m_dialInhibitLaneChange.GetName() ) {
        
        return m_dialInhibitLaneChange.HasValue();
        
    }
    if ( dialName == m_dialLaneChange.GetName() ) {
        
        return m_dialLaneChange.HasValue();
        
    }
    if ( dialName == m_dialLaneChangeStatus.GetName() ) {
        
        return m_dialLaneChangeStatus.HasValue();
        
    }
    if ( dialName == m_dialMaintainGap.GetName() ) {
        
        return m_dialMaintainGap.HasValue();
        
    }
    if ( dialName == m_dialTargetVelocity.GetName() ) {
        
        return m_dialTargetVelocity.HasValue();
        
    }
    if ( dialName == m_dialVisualState.GetName() ) {
        
        return m_dialVisualState.HasValue();
        
    }
    
    return false;

}

bool CAdo::ResetDialByName( const string& dialName )
{

    if ( dialName == m_dialAudioState.GetName() ) {
        
        m_dialAudioState.Reset();
        return true;
        
    }
    if ( dialName == m_dialForcedLaneOffset.GetName() ) {
        
        m_dialForcedLaneOffset.Reset();
        return true;
        
    }
    if ( dialName == m_dialForcedVelocity.GetName() ) {
        
        m_dialForcedVelocity.Reset();
        return true;
        
    }
    if ( dialName == m_dialForcedSteeringAngle.GetName() ) {
        
        m_dialForcedSteeringAngle.Reset();
        return true;
        
    }
    if ( dialName == m_dialImStop.GetName() ) {
        
        m_dialImStop.Reset();
        return true;
        
    }
    if ( dialName == m_dialInhibitLaneChange.GetName() ) {
        
        m_dialInhibitLaneChange.Reset();
        return true;
        
    }
    if ( dialName == m_dialLaneChange.GetName() ) {
        
        m_dialLaneChange.Reset();
        return true;
        
    }
    if ( dialName == m_dialLaneChangeStatus.GetName() ) {
        
        m_dialLaneChangeStatus.Reset();
        return true;
        
    }
    if ( dialName == m_dialMaintainGap.GetName() ) {
        
        m_dialMaintainGap.Reset();
        return true;
        
    }
    if ( dialName == m_dialTargetVelocity.GetName() ) {
        
        m_dialTargetVelocity.Reset();
        return true;
        
    }
    if ( dialName == m_dialVisualState.GetName() ) {
        
        m_dialVisualState.Reset();
        return true;
        
    }
    
    return false;

}

CRoadPos CAdo::GetMonitorRoadPos()
{

    return m_monitorRoadPos.GetValue();

}

void CAdo::SetMonitorRoadPos( CRoadPos value )
{

    m_monitorRoadPos.SetValue( value );

}

void CAdo::SetMonitorRoadPosNoValue()
{

    m_monitorRoadPos.SetNoValue();

}

float CAdo::GetMonitorDistanceToNextHldOffset()
{

    return m_monitorDistanceToNextHldOffset.GetValue();

}

void CAdo::SetMonitorDistanceToNextHldOffset( float value )
{

    m_monitorDistanceToNextHldOffset.SetValue( value );

}

void CAdo::SetMonitorDistanceToNextHldOffsetNoValue()
{

    m_monitorDistanceToNextHldOffset.SetNoValue();

}

CCrdr CAdo::GetMonitorTargCrdr()
{

    return m_monitorTargCrdr.GetValue();

}

void CAdo::SetMonitorTargCrdr( CCrdr value )
{

    m_monitorTargCrdr.SetValue( value );

}

void CAdo::SetMonitorTargCrdrNoValue()
{

    m_monitorTargCrdr.SetNoValue();

}

int CAdo::GetMonitorStoppedBehindObj()
{

    return m_monitorStoppedBehindObj.GetValue();

}

void CAdo::SetMonitorStoppedBehindObj( int value )
{

    m_monitorStoppedBehindObj.SetValue( value );

}

void CAdo::SetMonitorStoppedBehindObjNoValue()
{

    m_monitorStoppedBehindObj.SetNoValue();

}

bool CAdo::GetMonitorHasStopSignTarget()
{

    return m_monitorHasStopSignTarget.GetValue();

}

void CAdo::SetMonitorHasStopSignTarget( bool value )
{

    m_monitorHasStopSignTarget.SetValue( value );

}

void CAdo::SetMonitorHasStopSignTargetNoValue()
{

    m_monitorHasStopSignTarget.SetNoValue();

}

string CAdo::GetMonitorImTargCrdrs()
{

    return m_monitorImTargCrdrs.GetValue();

}

void CAdo::SetMonitorImTargCrdrs( string value )
{

    m_monitorImTargCrdrs.SetValue( value );

}

void CAdo::SetMonitorImTargCrdrsNoValue()
{

    m_monitorImTargCrdrs.SetNoValue();

}

int CAdo::GetMonitorStoppedAtStopSignFrame()
{

    return m_monitorStoppedAtStopSignFrame.GetValue();

}

void CAdo::SetMonitorStoppedAtStopSignFrame( int value )
{

    m_monitorStoppedAtStopSignFrame.SetValue( value );

}

void CAdo::SetMonitorStoppedAtStopSignFrameNoValue()
{

    m_monitorStoppedAtStopSignFrame.SetNoValue();

}

bool CAdo::GetMonitorByName( const string& monitorName, CRoadPos* pValue )
{

    if ( monitorName == m_monitorRoadPos.GetName() ) {
        
        bool retVal = m_monitorRoadPos.HasValue();
        if ( retVal ) {
            *pValue = m_monitorRoadPos.GetValue();
        }
        
        return retVal;
        
    }
    
    return false;

}

bool CAdo::GetMonitorByName( const string& monitorName, float* pValue )
{

    if ( monitorName == m_monitorDistanceToNextHldOffset.GetName() ) {
        
        bool retVal = m_monitorDistanceToNextHldOffset.HasValue();
        if ( retVal ) {
            *pValue = m_monitorDistanceToNextHldOffset.GetValue();
        }
        
        return retVal;
        
    }
    
    return false;

}

bool CAdo::GetMonitorByName( const string& monitorName, CCrdr* pValue )
{

    if ( monitorName == m_monitorTargCrdr.GetName() ) {
        
        bool retVal = m_monitorTargCrdr.HasValue();
        if ( retVal ) {
            *pValue = m_monitorTargCrdr.GetValue();
        }
        
        return retVal;
        
    }
    
    return false;

}

bool CAdo::GetMonitorByName( const string& monitorName, int* pValue )
{

    if ( monitorName == m_monitorStoppedBehindObj.GetName() ) {
        
        bool retVal = m_monitorStoppedBehindObj.HasValue();
        if ( retVal ) {
            *pValue = m_monitorStoppedBehindObj.GetValue();
        }
        
        return retVal;
        
    }
    
    if ( monitorName == m_monitorStoppedAtStopSignFrame.GetName() ) {
        
        bool retVal = m_monitorStoppedAtStopSignFrame.HasValue();
        if ( retVal ) {
            *pValue = m_monitorStoppedAtStopSignFrame.GetValue();
        }
        
        return retVal;
        
    }
    
    return false;

}

bool CAdo::GetMonitorByName( const string& monitorName, bool* pValue )
{

    if ( monitorName == m_monitorHasStopSignTarget.GetName() ) {
        
        bool retVal = m_monitorHasStopSignTarget.HasValue();
        if ( retVal ) {
            *pValue = m_monitorHasStopSignTarget.GetValue();
        }
        
        return retVal;
        
    }
    
    return false;

}

bool CAdo::GetMonitorByName( const string& monitorName, string* pValue )
{

    if ( monitorName == m_monitorImTargCrdrs.GetName() ) {
        
        bool retVal = m_monitorImTargCrdrs.HasValue();
        if ( retVal ) {
            *pValue = m_monitorImTargCrdrs.GetValue();
        }
        
        return retVal;
        
    }
    
    return false;

}

CAutonomous::CAutonomous(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CAdoParseBlock( snoBlock ),
            "Autonomous",
            false,
            12
            )
,
    m_inputpI( "pI" )
{


}

CAutonomous::CAutonomous( const CAutonomous& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CAutonomous& CAutonomous::operator=(
            const CAutonomous& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CAutonomous::~CAutonomous()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CAutonomous::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	AutonomousPreActivity();

}

void CAutonomous::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	AutonomousPostActivity();

}

bool CAutonomous::ExecutePredicate( int functionId )
{

    if ( functionId == 1 ) {
        
        return AdoAutoRemotePredicate();
        
    }
    else {
        
        // unknown function id
        return false;
        
    }

}

bool CAutonomous::AdoAutoRemotePredicate()
{

	return AutoRemotePredicate();

}

CAdoInfoPtr CAutonomous::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CAutonomous::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CAutonomous::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

CRemoteControl::CRemoteControl(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CAdoParseBlock( snoBlock ),
            "RemoteControl",
            false,
            13
            )
,
    m_inputpI( "pI" ),
    m_outputTargPos( "TargPos" ),
    m_outputTargSteer( "TargSteer" ),
    m_outputTargAccel( "TargAccel" ),
    m_outputImTargCrdrs( "ImTargCrdrs" ),
    m_outputHasStopSignTarget( "HasStopSignTarget" ),
    m_outputStoppedAtStopSignFrame( "StoppedAtStopSignFrame" ),
    m_outputMaxSteer( "MaxSteer" )
{

    // add my children
    AddChild( new CFreeDrive( pRootCollection, snoBlock ) );
    AddChild( new CFollow( pRootCollection, snoBlock ) );
    AddChild( new CLaneChange( pRootCollection, snoBlock ) );
    AddChild( new CNavigateIntrsctn( pRootCollection, snoBlock ) );
    AddChild( new CMerge( pRootCollection ) );


}

CRemoteControl::CRemoteControl( const CRemoteControl& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_outputTargPos( objToCopy.m_outputTargPos.GetName() ),
    m_outputTargSteer( objToCopy.m_outputTargSteer.GetName() ),
    m_outputTargAccel( objToCopy.m_outputTargAccel.GetName() ),
    m_outputImTargCrdrs( objToCopy.m_outputImTargCrdrs.GetName() ),
    m_outputHasStopSignTarget( objToCopy.m_outputHasStopSignTarget.GetName() ),
    m_outputStoppedAtStopSignFrame( objToCopy.m_outputStoppedAtStopSignFrame.GetName() ),
    m_outputMaxSteer( objToCopy.m_outputMaxSteer.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CRemoteControl& CRemoteControl::operator=(
            const CRemoteControl& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CRemoteControl::~CRemoteControl()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CRemoteControl::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	RemoteControlPreActivity();

}

void CRemoteControl::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	RemoteControlPostActivity();

}

bool CRemoteControl::ExecutePredicate( int functionId )
{

    if ( functionId == 2 ) {
        
        return AdoRemoteAutoPredicate();
        
    }
    else {
        
        // unknown function id
        return false;
        
    }

}

bool CRemoteControl::AdoRemoteAutoPredicate()
{

	return RemoteAutoPredicate();

}

CAdoInfoPtr CRemoteControl::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CRemoteControl::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CRemoteControl::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

void CRemoteControl::SetInputpIForFreeDrive( CAdoInfoPtr value )
{

    ( dynamic_cast<CFreeDrive*>(m_children[0]) )->SetInputpI( value );

}

void CRemoteControl::SetInputpIForFollow( CAdoInfoPtr value )
{

    ( dynamic_cast<CFollow*>(m_children[1]) )->SetInputpI( value );

}

void CRemoteControl::SetInputpIForLaneChange( CAdoInfoPtr value )
{

    ( dynamic_cast<CLaneChange*>(m_children[2]) )->SetInputpI( value );

}

void CRemoteControl::SetInputFreeDriveTargVelForLaneChange( double value )
{

    ( dynamic_cast<CLaneChange*>(m_children[2]) )->SetInputFreeDriveTargVel( value );

}

void CRemoteControl::SetInputpIForNavigateIntrsctn( CAdoInfoPtr value )
{

    ( dynamic_cast<CNavigateIntrsctn*>(m_children[3]) )->SetInputpI( value );

}

void CRemoteControl::SetInputpIForMerge( CAdoInfoPtr value )
{

    ( dynamic_cast<CMerge*>(m_children[4]) )->SetInputpI( value );

}

CPoint3D CRemoteControl::GetOutputTargPos()
{

    return m_outputTargPos.GetValue();

}

bool CRemoteControl::HasValueOutputTargPos()
{

    return m_outputTargPos.HasValue();

}

void CRemoteControl::SetOutputTargPos( CPoint3D value )
{

    m_outputTargPos.SetValue( value );

}

void CRemoteControl::SetOutputTargPosNoValue()
{

    m_outputTargPos.SetNoValue();

}

double CRemoteControl::GetOutputTargSteer()
{

    return m_outputTargSteer.GetValue();

}

bool CRemoteControl::HasValueOutputTargSteer()
{

    return m_outputTargSteer.HasValue();

}

void CRemoteControl::SetOutputTargSteer( double value )
{

    m_outputTargSteer.SetValue( value );

}

void CRemoteControl::SetOutputTargSteerNoValue()
{

    m_outputTargSteer.SetNoValue();

}

double CRemoteControl::GetOutputTargAccel()
{

    return m_outputTargAccel.GetValue();

}

bool CRemoteControl::HasValueOutputTargAccel()
{

    return m_outputTargAccel.HasValue();

}

void CRemoteControl::SetOutputTargAccel( double value )
{

    m_outputTargAccel.SetValue( value );

}

void CRemoteControl::SetOutputTargAccelNoValue()
{

    m_outputTargAccel.SetNoValue();

}

string CRemoteControl::GetOutputImTargCrdrs()
{

    return m_outputImTargCrdrs.GetValue();

}

bool CRemoteControl::HasValueOutputImTargCrdrs()
{

    return m_outputImTargCrdrs.HasValue();

}

void CRemoteControl::SetOutputImTargCrdrs( string value )
{

    m_outputImTargCrdrs.SetValue( value );

}

void CRemoteControl::SetOutputImTargCrdrsNoValue()
{

    m_outputImTargCrdrs.SetNoValue();

}

bool CRemoteControl::GetOutputHasStopSignTarget()
{

    return m_outputHasStopSignTarget.GetValue();

}

bool CRemoteControl::HasValueOutputHasStopSignTarget()
{

    return m_outputHasStopSignTarget.HasValue();

}

void CRemoteControl::SetOutputHasStopSignTarget( bool value )
{

    m_outputHasStopSignTarget.SetValue( value );

}

void CRemoteControl::SetOutputHasStopSignTargetNoValue()
{

    m_outputHasStopSignTarget.SetNoValue();

}

int CRemoteControl::GetOutputStoppedAtStopSignFrame()
{

    return m_outputStoppedAtStopSignFrame.GetValue();

}

bool CRemoteControl::HasValueOutputStoppedAtStopSignFrame()
{

    return m_outputStoppedAtStopSignFrame.HasValue();

}

void CRemoteControl::SetOutputStoppedAtStopSignFrame( int value )
{

    m_outputStoppedAtStopSignFrame.SetValue( value );

}

void CRemoteControl::SetOutputStoppedAtStopSignFrameNoValue()
{

    m_outputStoppedAtStopSignFrame.SetNoValue();

}

double CRemoteControl::GetOutputMaxSteer()
{

    return m_outputMaxSteer.GetValue();

}

bool CRemoteControl::HasValueOutputMaxSteer()
{

    return m_outputMaxSteer.HasValue();

}

void CRemoteControl::SetOutputMaxSteer( double value )
{

    m_outputMaxSteer.SetValue( value );

}

void CRemoteControl::SetOutputMaxSteerNoValue()
{

    m_outputMaxSteer.SetNoValue();

}

CPoint3D CRemoteControl::GetOutputTargPosFromFreeDrive()
{

    return ( dynamic_cast<CFreeDrive*>(m_children[0]) )->GetOutputTargPos();

}

bool CRemoteControl::HasValueOutputTargPosFromFreeDrive()
{

    return ( dynamic_cast<CFreeDrive*>(m_children[0]) )->HasValueOutputTargPos();

}

double CRemoteControl::GetOutputTargVelFromFreeDrive()
{

    return ( dynamic_cast<CFreeDrive*>(m_children[0]) )->GetOutputTargVel();

}

bool CRemoteControl::HasValueOutputTargVelFromFreeDrive()
{

    return ( dynamic_cast<CFreeDrive*>(m_children[0]) )->HasValueOutputTargVel();

}

double CRemoteControl::GetOutputTargSteerFromFreeDrive()
{

    return ( dynamic_cast<CFreeDrive*>(m_children[0]) )->GetOutputTargSteer();

}

bool CRemoteControl::HasValueOutputTargSteerFromFreeDrive()
{

    return ( dynamic_cast<CFreeDrive*>(m_children[0]) )->HasValueOutputTargSteer();

}

double CRemoteControl::GetOutputTargAccelFromFreeDrive()
{

    return ( dynamic_cast<CFreeDrive*>(m_children[0]) )->GetOutputTargAccel();

}

bool CRemoteControl::HasValueOutputTargAccelFromFreeDrive()
{

    return ( dynamic_cast<CFreeDrive*>(m_children[0]) )->HasValueOutputTargAccel();

}

double CRemoteControl::GetOutputMaxSteerFromFreeDrive()
{

    return ( dynamic_cast<CFreeDrive*>(m_children[0]) )->GetOutputMaxSteer();

}

bool CRemoteControl::HasValueOutputMaxSteerFromFreeDrive()
{

    return ( dynamic_cast<CFreeDrive*>(m_children[0]) )->HasValueOutputMaxSteer();

}

double CRemoteControl::GetOutputTargAccelFromFollow()
{

    return ( dynamic_cast<CFollow*>(m_children[1]) )->GetOutputTargAccel();

}

bool CRemoteControl::HasValueOutputTargAccelFromFollow()
{

    return ( dynamic_cast<CFollow*>(m_children[1]) )->HasValueOutputTargAccel();

}

double CRemoteControl::GetOutputTargAccelFromLaneChange()
{

    return ( dynamic_cast<CLaneChange*>(m_children[2]) )->GetOutputTargAccel();

}

bool CRemoteControl::HasValueOutputTargAccelFromLaneChange()
{

    return ( dynamic_cast<CLaneChange*>(m_children[2]) )->HasValueOutputTargAccel();

}

CPoint3D CRemoteControl::GetOutputTargPosFromLaneChange()
{

    return ( dynamic_cast<CLaneChange*>(m_children[2]) )->GetOutputTargPos();

}

bool CRemoteControl::HasValueOutputTargPosFromLaneChange()
{

    return ( dynamic_cast<CLaneChange*>(m_children[2]) )->HasValueOutputTargPos();

}

double CRemoteControl::GetOutputMaxSteerFromLaneChange()
{

    return ( dynamic_cast<CLaneChange*>(m_children[2]) )->GetOutputMaxSteer();

}

bool CRemoteControl::HasValueOutputMaxSteerFromLaneChange()
{

    return ( dynamic_cast<CLaneChange*>(m_children[2]) )->HasValueOutputMaxSteer();

}

double CRemoteControl::GetOutputTargAccelFromNavigateIntrsctn()
{

    return ( dynamic_cast<CNavigateIntrsctn*>(m_children[3]) )->GetOutputTargAccel();

}

bool CRemoteControl::HasValueOutputTargAccelFromNavigateIntrsctn()
{

    return ( dynamic_cast<CNavigateIntrsctn*>(m_children[3]) )->HasValueOutputTargAccel();

}

string CRemoteControl::GetOutputImTargCrdrsFromNavigateIntrsctn()
{

    return ( dynamic_cast<CNavigateIntrsctn*>(m_children[3]) )->GetOutputImTargCrdrs();

}

bool CRemoteControl::HasValueOutputImTargCrdrsFromNavigateIntrsctn()
{

    return ( dynamic_cast<CNavigateIntrsctn*>(m_children[3]) )->HasValueOutputImTargCrdrs();

}

bool CRemoteControl::GetOutputHasStopSignTargetFromNavigateIntrsctn()
{

    return ( dynamic_cast<CNavigateIntrsctn*>(m_children[3]) )->GetOutputHasStopSignTarget();

}

bool CRemoteControl::HasValueOutputHasStopSignTargetFromNavigateIntrsctn()
{

    return ( dynamic_cast<CNavigateIntrsctn*>(m_children[3]) )->HasValueOutputHasStopSignTarget();

}

int CRemoteControl::GetOutputStoppedAtStopSignFrameFromNavigateIntrsctn()
{

    return ( dynamic_cast<CNavigateIntrsctn*>(m_children[3]) )->GetOutputStoppedAtStopSignFrame();

}

bool CRemoteControl::HasValueOutputStoppedAtStopSignFrameFromNavigateIntrsctn()
{

    return ( dynamic_cast<CNavigateIntrsctn*>(m_children[3]) )->HasValueOutputStoppedAtStopSignFrame();

}

double CRemoteControl::GetOutputTargAccelFromMerge()
{

    return ( dynamic_cast<CMerge*>(m_children[4]) )->GetOutputTargAccel();

}

bool CRemoteControl::HasValueOutputTargAccelFromMerge()
{

    return ( dynamic_cast<CMerge*>(m_children[4]) )->HasValueOutputTargAccel();

}

CFreeDrive::CFreeDrive(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CAdoParseBlock( snoBlock ),
            "FreeDrive",
            false,
            14
            )
,
    m_inputpI( "pI" ),
    m_outputTargPos( "TargPos" ),
    m_outputTargVel( "TargVel" ),
    m_outputTargSteer( "TargSteer" ),
    m_outputTargAccel( "TargAccel" ),
    m_outputMaxSteer( "MaxSteer" )
{


}

CFreeDrive::CFreeDrive( const CFreeDrive& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_outputTargPos( objToCopy.m_outputTargPos.GetName() ),
    m_outputTargVel( objToCopy.m_outputTargVel.GetName() ),
    m_outputTargSteer( objToCopy.m_outputTargSteer.GetName() ),
    m_outputTargAccel( objToCopy.m_outputTargAccel.GetName() ),
    m_outputMaxSteer( objToCopy.m_outputMaxSteer.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CFreeDrive& CFreeDrive::operator=(
            const CFreeDrive& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CFreeDrive::~CFreeDrive()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CFreeDrive::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	Creation();

}

void CFreeDrive::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PreActivity();

}

void CFreeDrive::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PostActivity();

}

CAdoInfoPtr CFreeDrive::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CFreeDrive::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CFreeDrive::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

CPoint3D CFreeDrive::GetOutputTargPos()
{

    return m_outputTargPos.GetValue();

}

bool CFreeDrive::HasValueOutputTargPos()
{

    return m_outputTargPos.HasValue();

}

void CFreeDrive::SetOutputTargPos( CPoint3D value )
{

    m_outputTargPos.SetValue( value );

}

void CFreeDrive::SetOutputTargPosNoValue()
{

    m_outputTargPos.SetNoValue();

}

double CFreeDrive::GetOutputTargVel()
{

    return m_outputTargVel.GetValue();

}

bool CFreeDrive::HasValueOutputTargVel()
{

    return m_outputTargVel.HasValue();

}

void CFreeDrive::SetOutputTargVel( double value )
{

    m_outputTargVel.SetValue( value );

}

void CFreeDrive::SetOutputTargVelNoValue()
{

    m_outputTargVel.SetNoValue();

}

double CFreeDrive::GetOutputTargSteer()
{

    return m_outputTargSteer.GetValue();

}

bool CFreeDrive::HasValueOutputTargSteer()
{

    return m_outputTargSteer.HasValue();

}

void CFreeDrive::SetOutputTargSteer( double value )
{

    m_outputTargSteer.SetValue( value );

}

void CFreeDrive::SetOutputTargSteerNoValue()
{

    m_outputTargSteer.SetNoValue();

}

double CFreeDrive::GetOutputTargAccel()
{

    return m_outputTargAccel.GetValue();

}

bool CFreeDrive::HasValueOutputTargAccel()
{

    return m_outputTargAccel.HasValue();

}

void CFreeDrive::SetOutputTargAccel( double value )
{

    m_outputTargAccel.SetValue( value );

}

void CFreeDrive::SetOutputTargAccelNoValue()
{

    m_outputTargAccel.SetNoValue();

}

double CFreeDrive::GetOutputMaxSteer()
{

    return m_outputMaxSteer.GetValue();

}

bool CFreeDrive::HasValueOutputMaxSteer()
{

    return m_outputMaxSteer.HasValue();

}

void CFreeDrive::SetOutputMaxSteer( double value )
{

    m_outputMaxSteer.SetValue( value );

}

void CFreeDrive::SetOutputMaxSteerNoValue()
{

    m_outputMaxSteer.SetNoValue();

}

CFollow::CFollow(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CAdoParseBlock( snoBlock ),
            "Follow",
            false,
            15
            )
,
    m_inputpI( "pI" ),
    m_outputTargAccel( "TargAccel" )
{


}

CFollow::CFollow( const CFollow& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_outputTargAccel( objToCopy.m_outputTargAccel.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CFollow& CFollow::operator=(
            const CFollow& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CFollow::~CFollow()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CFollow::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	Creation();

}

void CFollow::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PreActivity();

}

void CFollow::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PostActivity();

}

CAdoInfoPtr CFollow::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CFollow::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CFollow::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

double CFollow::GetOutputTargAccel()
{

    return m_outputTargAccel.GetValue();

}

bool CFollow::HasValueOutputTargAccel()
{

    return m_outputTargAccel.HasValue();

}

void CFollow::SetOutputTargAccel( double value )
{

    m_outputTargAccel.SetValue( value );

}

void CFollow::SetOutputTargAccelNoValue()
{

    m_outputTargAccel.SetNoValue();

}

CLaneChange::CLaneChange(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmSequential(
            pRootCollection,
            new CAdoParseBlock( snoBlock ),
            "LaneChange",
            false,
            16
            )
,
    m_inputpI( "pI" ),
    m_inputFreeDriveTargVel( "FreeDriveTargVel" ),
    m_outputTargAccel( "TargAccel" ),
    m_outputTargPos( "TargPos" ),
    m_outputMaxSteer( "MaxSteer" )
{

    // add my children
    AddChild( new CLcMonitor( pRootCollection, snoBlock ) );
    AddChild( new CLcSignal( pRootCollection, snoBlock ) );
    AddChild( new CLcExecute( pRootCollection, snoBlock ) );
    AddChild( new CLcAbort( pRootCollection, snoBlock ) );

    m_activeChild = m_children[0];
    m_defaultActiveChild = m_children[0];


}

CLaneChange::CLaneChange( const CLaneChange& objToCopy ):
    CHcsmSequential(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_inputFreeDriveTargVel( objToCopy.m_inputFreeDriveTargVel.GetName() ),
    m_outputTargAccel( objToCopy.m_outputTargAccel.GetName() ),
    m_outputTargPos( objToCopy.m_outputTargPos.GetName() ),
    m_outputMaxSteer( objToCopy.m_outputMaxSteer.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CLaneChange& CLaneChange::operator=(
            const CLaneChange& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CLaneChange::~CLaneChange()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CLaneChange::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	Creation();

}

void CLaneChange::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	Deletion();

}

void CLaneChange::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PreActivity();

}

void CLaneChange::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PostActivity();

}

void CLaneChange::ExecuteTransitions()
{

    // from "LcMonitor" to "LcExecute"
    if ( m_activeChild == m_children[0] && m_children[0]->ExecutePredicate( 3 ) ) {
        
        m_activeChild = m_children[2];
        return;
        
    }

    // from "LcMonitor" to "LcSignal"
    if ( m_activeChild == m_children[0] && m_children[0]->ExecutePredicate( 4 ) ) {
        
        m_activeChild = m_children[1];
        return;
        
    }

    // from "LcSignal" to "LcExecute"
    if ( m_activeChild == m_children[1] && m_children[1]->ExecutePredicate( 5 ) ) {
        
        m_activeChild = m_children[2];
        return;
        
    }

    // from "LcSignal" to "LcAbort"
    if ( m_activeChild == m_children[1] && m_children[1]->ExecutePredicate( 6 ) ) {
        
        m_activeChild = m_children[3];
        return;
        
    }

    // from "LcExecute" to "LcAbort"
    if ( m_activeChild == m_children[2] && m_children[2]->ExecutePredicate( 7 ) ) {
        
        m_activeChild = m_children[3];
        return;
        
    }

    // from "LcExecute" to "LcMonitor"
    if ( m_activeChild == m_children[2] && m_children[2]->ExecutePredicate( 8 ) ) {
        
        m_activeChild = m_children[0];
        return;
        
    }

    // from "LcAbort" to "LcMonitor"
    if ( m_activeChild == m_children[3] && m_children[3]->ExecutePredicate( 9 ) ) {
        
        m_activeChild = m_children[0];
        return;
        
    }

}

CAdoInfoPtr CLaneChange::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CLaneChange::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CLaneChange::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

double CLaneChange::GetInputFreeDriveTargVel()
{

    return m_inputFreeDriveTargVel.GetValue();

}

bool CLaneChange::HasValueInputFreeDriveTargVel()
{

    return m_inputFreeDriveTargVel.HasValue();

}

void CLaneChange::SetInputFreeDriveTargVel( double value )
{

    m_inputFreeDriveTargVel.SetValue( value );

}

void CLaneChange::SetInputpIForLcMonitor( CAdoInfoPtr value )
{

    ( dynamic_cast<CLcMonitor*>(m_children[0]) )->SetInputpI( value );

}

void CLaneChange::SetInputpCondForLcMonitor( CLcCondsPtr value )
{

    ( dynamic_cast<CLcMonitor*>(m_children[0]) )->SetInputpCond( value );

}

void CLaneChange::SetInputFreeDriveTargVelForLcMonitor( double value )
{

    ( dynamic_cast<CLcMonitor*>(m_children[0]) )->SetInputFreeDriveTargVel( value );

}

void CLaneChange::SetInputpIForLcSignal( CAdoInfoPtr value )
{

    ( dynamic_cast<CLcSignal*>(m_children[1]) )->SetInputpI( value );

}

void CLaneChange::SetInputpCondForLcSignal( CLcCondsPtr value )
{

    ( dynamic_cast<CLcSignal*>(m_children[1]) )->SetInputpCond( value );

}

void CLaneChange::SetInputpIForLcExecute( CAdoInfoPtr value )
{

    ( dynamic_cast<CLcExecute*>(m_children[2]) )->SetInputpI( value );

}

void CLaneChange::SetInputpCondForLcExecute( CLcCondsPtr value )
{

    ( dynamic_cast<CLcExecute*>(m_children[2]) )->SetInputpCond( value );

}

void CLaneChange::SetInputpIForLcAbort( CAdoInfoPtr value )
{

    ( dynamic_cast<CLcAbort*>(m_children[3]) )->SetInputpI( value );

}

void CLaneChange::SetInputpCondForLcAbort( CLcCondsPtr value )
{

    ( dynamic_cast<CLcAbort*>(m_children[3]) )->SetInputpCond( value );

}

double CLaneChange::GetOutputTargAccel()
{

    return m_outputTargAccel.GetValue();

}

bool CLaneChange::HasValueOutputTargAccel()
{

    return m_outputTargAccel.HasValue();

}

void CLaneChange::SetOutputTargAccel( double value )
{

    m_outputTargAccel.SetValue( value );

}

void CLaneChange::SetOutputTargAccelNoValue()
{

    m_outputTargAccel.SetNoValue();

}

CPoint3D CLaneChange::GetOutputTargPos()
{

    return m_outputTargPos.GetValue();

}

bool CLaneChange::HasValueOutputTargPos()
{

    return m_outputTargPos.HasValue();

}

void CLaneChange::SetOutputTargPos( CPoint3D value )
{

    m_outputTargPos.SetValue( value );

}

void CLaneChange::SetOutputTargPosNoValue()
{

    m_outputTargPos.SetNoValue();

}

double CLaneChange::GetOutputMaxSteer()
{

    return m_outputMaxSteer.GetValue();

}

bool CLaneChange::HasValueOutputMaxSteer()
{

    return m_outputMaxSteer.HasValue();

}

void CLaneChange::SetOutputMaxSteer( double value )
{

    m_outputMaxSteer.SetValue( value );

}

void CLaneChange::SetOutputMaxSteerNoValue()
{

    m_outputMaxSteer.SetNoValue();

}

double CLaneChange::GetOutputTargAccelFromLcExecute()
{

    return ( dynamic_cast<CLcExecute*>(m_children[2]) )->GetOutputTargAccel();

}

bool CLaneChange::HasValueOutputTargAccelFromLcExecute()
{

    return ( dynamic_cast<CLcExecute*>(m_children[2]) )->HasValueOutputTargAccel();

}

CPoint3D CLaneChange::GetOutputTargPosFromLcExecute()
{

    return ( dynamic_cast<CLcExecute*>(m_children[2]) )->GetOutputTargPos();

}

bool CLaneChange::HasValueOutputTargPosFromLcExecute()
{

    return ( dynamic_cast<CLcExecute*>(m_children[2]) )->HasValueOutputTargPos();

}

CLcMonitor::CLcMonitor(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CAdoParseBlock( snoBlock ),
            "LcMonitor",
            false,
            17
            )
,
    m_inputpI( "pI" ),
    m_inputpCond( "pCond" ),
    m_inputFreeDriveTargVel( "FreeDriveTargVel" )
{


}

CLcMonitor::CLcMonitor( const CLcMonitor& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_inputpCond( objToCopy.m_inputpCond.GetName() ),
    m_inputFreeDriveTargVel( objToCopy.m_inputFreeDriveTargVel.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CLcMonitor& CLcMonitor::operator=(
            const CLcMonitor& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CLcMonitor::~CLcMonitor()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CLcMonitor::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PreActivity();

}

void CLcMonitor::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PostActivity();

}

bool CLcMonitor::ExecutePredicate( int functionId )
{

    if ( functionId == 3 ) {
        
        return AdoLcMonitorLcExecutePredicate();
        
    }
    else if ( functionId == 4 ) {
        
        return AdoLcMonitorLcSignalPredicate();
        
    }
    else {
        
        // unknown function id
        return false;
        
    }

}

bool CLcMonitor::AdoLcMonitorLcExecutePredicate()
{

	return LcMonitorLcExecutePredicate();

}
bool CLcMonitor::AdoLcMonitorLcSignalPredicate()
{

	return LcMonitorLcSignalPredicate();

}

CAdoInfoPtr CLcMonitor::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CLcMonitor::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CLcMonitor::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

CLcCondsPtr CLcMonitor::GetInputpCond()
{

    return m_inputpCond.GetValue();

}

bool CLcMonitor::HasValueInputpCond()
{

    return m_inputpCond.HasValue();

}

void CLcMonitor::SetInputpCond( CLcCondsPtr value )
{

    m_inputpCond.SetValue( value );

}

double CLcMonitor::GetInputFreeDriveTargVel()
{

    return m_inputFreeDriveTargVel.GetValue();

}

bool CLcMonitor::HasValueInputFreeDriveTargVel()
{

    return m_inputFreeDriveTargVel.HasValue();

}

void CLcMonitor::SetInputFreeDriveTargVel( double value )
{

    m_inputFreeDriveTargVel.SetValue( value );

}

CLcSignal::CLcSignal(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CAdoParseBlock( snoBlock ),
            "LcSignal",
            false,
            18
            )
,
    m_inputpI( "pI" ),
    m_inputpCond( "pCond" )
{


}

CLcSignal::CLcSignal( const CLcSignal& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_inputpCond( objToCopy.m_inputpCond.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CLcSignal& CLcSignal::operator=(
            const CLcSignal& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CLcSignal::~CLcSignal()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CLcSignal::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	Creation();

}

void CLcSignal::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PreActivity();

}

void CLcSignal::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PostActivity();

}

bool CLcSignal::ExecutePredicate( int functionId )
{

    if ( functionId == 5 ) {
        
        return AdoLcSignalLcExecutePredicate();
        
    }
    else if ( functionId == 6 ) {
        
        return AdoLcSignalLcAbortPredicate();
        
    }
    else {
        
        // unknown function id
        return false;
        
    }

}

bool CLcSignal::AdoLcSignalLcExecutePredicate()
{

	return LcSignalLcExecutePredicate();

}
bool CLcSignal::AdoLcSignalLcAbortPredicate()
{

	return LcSignalLcAbortPredicate();

}

CAdoInfoPtr CLcSignal::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CLcSignal::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CLcSignal::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

CLcCondsPtr CLcSignal::GetInputpCond()
{

    return m_inputpCond.GetValue();

}

bool CLcSignal::HasValueInputpCond()
{

    return m_inputpCond.HasValue();

}

void CLcSignal::SetInputpCond( CLcCondsPtr value )
{

    m_inputpCond.SetValue( value );

}

CLcExecute::CLcExecute(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmSequential(
            pRootCollection,
            new CAdoParseBlock( snoBlock ),
            "LcExecute",
            false,
            19
            )
,
    m_inputpI( "pI" ),
    m_inputpCond( "pCond" ),
    m_outputTargAccel( "TargAccel" ),
    m_outputTargPos( "TargPos" )
{

    // add my children
    AddChild( new CLcExecuteNeutralize( pRootCollection ) );
    AddChild( new CLcExecuteIncrement( pRootCollection ) );
    AddChild( new CLcExecuteSteady( pRootCollection ) );
    AddChild( new CLcExecuteDecrement( pRootCollection ) );

    m_activeChild = m_children[0];
    m_defaultActiveChild = m_children[0];


}

CLcExecute::CLcExecute( const CLcExecute& objToCopy ):
    CHcsmSequential(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_inputpCond( objToCopy.m_inputpCond.GetName() ),
    m_outputTargAccel( objToCopy.m_outputTargAccel.GetName() ),
    m_outputTargPos( objToCopy.m_outputTargPos.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CLcExecute& CLcExecute::operator=(
            const CLcExecute& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CLcExecute::~CLcExecute()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CLcExecute::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	Creation();

}

void CLcExecute::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PreActivity();

}

void CLcExecute::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PostActivity();

}

void CLcExecute::ExecuteTransitions()
{

    // from "LcExecuteNeutralize" to "LcExecuteIncrement"
    if ( m_activeChild == m_children[0] && m_children[0]->ExecutePredicate( 10 ) ) {
        
        m_activeChild = m_children[1];
        return;
        
    }

    // from "LcExecuteIncrement" to "LcExecuteSteady"
    if ( m_activeChild == m_children[1] && m_children[1]->ExecutePredicate( 11 ) ) {
        
        m_activeChild = m_children[2];
        return;
        
    }

    // from "LcExecuteSteady" to "LcExecuteDecrement"
    if ( m_activeChild == m_children[2] && m_children[2]->ExecutePredicate( 12 ) ) {
        
        m_activeChild = m_children[3];
        return;
        
    }

    // from "LcExecuteDecrement" to "LcExecuteNeutralize"
    if ( m_activeChild == m_children[3] && m_children[3]->ExecutePredicate( 13 ) ) {
        
        m_activeChild = m_children[0];
        return;
        
    }

    // from "LcExecuteIncrement" to "LcExecuteNeutralize"
    if ( m_activeChild == m_children[1] && m_children[1]->ExecutePredicate( 14 ) ) {
        
        m_activeChild = m_children[0];
        return;
        
    }

    // from "LcExecuteSteady" to "LcExecuteNeutralize"
    if ( m_activeChild == m_children[2] && m_children[2]->ExecutePredicate( 15 ) ) {
        
        m_activeChild = m_children[0];
        return;
        
    }

    // from "LcExecuteDecrement" to "LcExecuteNeutralize"
    if ( m_activeChild == m_children[3] && m_children[3]->ExecutePredicate( 16 ) ) {
        
        m_activeChild = m_children[0];
        return;
        
    }

}

bool CLcExecute::ExecutePredicate( int functionId )
{

    if ( functionId == 7 ) {
        
        return AdoLcExecuteLcAbortPredicate();
        
    }
    else if ( functionId == 8 ) {
        
        return AdoLcExecuteLcMonitorPredicate();
        
    }
    else {
        
        // unknown function id
        return false;
        
    }

}

bool CLcExecute::AdoLcExecuteLcAbortPredicate()
{

	return LcExecuteLcAbortPredicate();

}
bool CLcExecute::AdoLcExecuteLcMonitorPredicate()
{

	return LcExecuteLcMonitorPredicate();

}

CAdoInfoPtr CLcExecute::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CLcExecute::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CLcExecute::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

CLcCondsPtr CLcExecute::GetInputpCond()
{

    return m_inputpCond.GetValue();

}

bool CLcExecute::HasValueInputpCond()
{

    return m_inputpCond.HasValue();

}

void CLcExecute::SetInputpCond( CLcCondsPtr value )
{

    m_inputpCond.SetValue( value );

}

void CLcExecute::SetInputpIForLcExecuteNeutralize( CAdoInfoPtr value )
{

    ( dynamic_cast<CLcExecuteNeutralize*>(m_children[0]) )->SetInputpI( value );

}

void CLcExecute::SetInputpCondForLcExecuteNeutralize( CLcCondsPtr value )
{

    ( dynamic_cast<CLcExecuteNeutralize*>(m_children[0]) )->SetInputpCond( value );

}

void CLcExecute::SetInputpIForLcExecuteIncrement( CAdoInfoPtr value )
{

    ( dynamic_cast<CLcExecuteIncrement*>(m_children[1]) )->SetInputpI( value );

}

void CLcExecute::SetInputpCondForLcExecuteIncrement( CLcCondsPtr value )
{

    ( dynamic_cast<CLcExecuteIncrement*>(m_children[1]) )->SetInputpCond( value );

}

void CLcExecute::SetInputpIForLcExecuteSteady( CAdoInfoPtr value )
{

    ( dynamic_cast<CLcExecuteSteady*>(m_children[2]) )->SetInputpI( value );

}

void CLcExecute::SetInputpCondForLcExecuteSteady( CLcCondsPtr value )
{

    ( dynamic_cast<CLcExecuteSteady*>(m_children[2]) )->SetInputpCond( value );

}

void CLcExecute::SetInputpIForLcExecuteDecrement( CAdoInfoPtr value )
{

    ( dynamic_cast<CLcExecuteDecrement*>(m_children[3]) )->SetInputpI( value );

}

void CLcExecute::SetInputpCondForLcExecuteDecrement( CLcCondsPtr value )
{

    ( dynamic_cast<CLcExecuteDecrement*>(m_children[3]) )->SetInputpCond( value );

}

double CLcExecute::GetOutputTargAccel()
{

    return m_outputTargAccel.GetValue();

}

bool CLcExecute::HasValueOutputTargAccel()
{

    return m_outputTargAccel.HasValue();

}

void CLcExecute::SetOutputTargAccel( double value )
{

    m_outputTargAccel.SetValue( value );

}

void CLcExecute::SetOutputTargAccelNoValue()
{

    m_outputTargAccel.SetNoValue();

}

CPoint3D CLcExecute::GetOutputTargPos()
{

    return m_outputTargPos.GetValue();

}

bool CLcExecute::HasValueOutputTargPos()
{

    return m_outputTargPos.HasValue();

}

void CLcExecute::SetOutputTargPos( CPoint3D value )
{

    m_outputTargPos.SetValue( value );

}

void CLcExecute::SetOutputTargPosNoValue()
{

    m_outputTargPos.SetNoValue();

}

double CLcExecute::GetOutputTargOffsetFromLcExecuteNeutralize()
{

    return ( dynamic_cast<CLcExecuteNeutralize*>(m_children[0]) )->GetOutputTargOffset();

}

bool CLcExecute::HasValueOutputTargOffsetFromLcExecuteNeutralize()
{

    return ( dynamic_cast<CLcExecuteNeutralize*>(m_children[0]) )->HasValueOutputTargOffset();

}

double CLcExecute::GetOutputTargOffsetFromLcExecuteIncrement()
{

    return ( dynamic_cast<CLcExecuteIncrement*>(m_children[1]) )->GetOutputTargOffset();

}

bool CLcExecute::HasValueOutputTargOffsetFromLcExecuteIncrement()
{

    return ( dynamic_cast<CLcExecuteIncrement*>(m_children[1]) )->HasValueOutputTargOffset();

}

double CLcExecute::GetOutputTargLookAheadFromLcExecuteIncrement()
{

    return ( dynamic_cast<CLcExecuteIncrement*>(m_children[1]) )->GetOutputTargLookAhead();

}

bool CLcExecute::HasValueOutputTargLookAheadFromLcExecuteIncrement()
{

    return ( dynamic_cast<CLcExecuteIncrement*>(m_children[1]) )->HasValueOutputTargLookAhead();

}

double CLcExecute::GetOutputTargOffsetFromLcExecuteSteady()
{

    return ( dynamic_cast<CLcExecuteSteady*>(m_children[2]) )->GetOutputTargOffset();

}

bool CLcExecute::HasValueOutputTargOffsetFromLcExecuteSteady()
{

    return ( dynamic_cast<CLcExecuteSteady*>(m_children[2]) )->HasValueOutputTargOffset();

}

double CLcExecute::GetOutputTargLookAheadFromLcExecuteSteady()
{

    return ( dynamic_cast<CLcExecuteSteady*>(m_children[2]) )->GetOutputTargLookAhead();

}

bool CLcExecute::HasValueOutputTargLookAheadFromLcExecuteSteady()
{

    return ( dynamic_cast<CLcExecuteSteady*>(m_children[2]) )->HasValueOutputTargLookAhead();

}

double CLcExecute::GetOutputTargOffsetFromLcExecuteDecrement()
{

    return ( dynamic_cast<CLcExecuteDecrement*>(m_children[3]) )->GetOutputTargOffset();

}

bool CLcExecute::HasValueOutputTargOffsetFromLcExecuteDecrement()
{

    return ( dynamic_cast<CLcExecuteDecrement*>(m_children[3]) )->HasValueOutputTargOffset();

}

double CLcExecute::GetOutputTargLookAheadFromLcExecuteDecrement()
{

    return ( dynamic_cast<CLcExecuteDecrement*>(m_children[3]) )->GetOutputTargLookAhead();

}

bool CLcExecute::HasValueOutputTargLookAheadFromLcExecuteDecrement()
{

    return ( dynamic_cast<CLcExecuteDecrement*>(m_children[3]) )->HasValueOutputTargLookAhead();

}

CLcAbort::CLcAbort(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CAdoParseBlock( snoBlock ),
            "LcAbort",
            false,
            20
            )
,
    m_inputpI( "pI" ),
    m_inputpCond( "pCond" )
{


}

CLcAbort::CLcAbort( const CLcAbort& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_inputpCond( objToCopy.m_inputpCond.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CLcAbort& CLcAbort::operator=(
            const CLcAbort& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CLcAbort::~CLcAbort()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CLcAbort::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	Creation();

}

void CLcAbort::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PreActivity();

}

void CLcAbort::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PostActivity();

}

bool CLcAbort::ExecutePredicate( int functionId )
{

    if ( functionId == 9 ) {
        
        return AdoLcAbortLcMonitorPredicate();
        
    }
    else {
        
        // unknown function id
        return false;
        
    }

}

bool CLcAbort::AdoLcAbortLcMonitorPredicate()
{

	return LcAbortLcMonitorPredicate();

}

CAdoInfoPtr CLcAbort::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CLcAbort::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CLcAbort::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

CLcCondsPtr CLcAbort::GetInputpCond()
{

    return m_inputpCond.GetValue();

}

bool CLcAbort::HasValueInputpCond()
{

    return m_inputpCond.HasValue();

}

void CLcAbort::SetInputpCond( CLcCondsPtr value )
{

    m_inputpCond.SetValue( value );

}

CLcExecuteNeutralize::CLcExecuteNeutralize(
            CHcsmCollection* pRootCollection
            ):
    CHcsmConcurrent(
            pRootCollection,
            "LcExecuteNeutralize",
            false,
            21
            )
,
    m_inputpI( "pI" ),
    m_inputpCond( "pCond" ),
    m_outputTargOffset( "TargOffset" )
{


}

CLcExecuteNeutralize::CLcExecuteNeutralize( const CLcExecuteNeutralize& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_inputpCond( objToCopy.m_inputpCond.GetName() ),
    m_outputTargOffset( objToCopy.m_outputTargOffset.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CLcExecuteNeutralize& CLcExecuteNeutralize::operator=(
            const CLcExecuteNeutralize& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CLcExecuteNeutralize::~CLcExecuteNeutralize()
{

    // call the deletion function
    Deletion();

}

void CLcExecuteNeutralize::PostActivity()
{

	UserPostActivity();

}

bool CLcExecuteNeutralize::ExecutePredicate( int functionId )
{

    if ( functionId == 10 ) {
        
        return ExecuteLcNeutralizeLcIncrementPredicate();
        
    }
    else {
        
        // unknown function id
        return false;
        
    }

}

bool CLcExecuteNeutralize::ExecuteLcNeutralizeLcIncrementPredicate()
{

	return LcNeutralizeIncrementPredicate();

}

CAdoInfoPtr CLcExecuteNeutralize::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CLcExecuteNeutralize::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CLcExecuteNeutralize::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

CLcCondsPtr CLcExecuteNeutralize::GetInputpCond()
{

    return m_inputpCond.GetValue();

}

bool CLcExecuteNeutralize::HasValueInputpCond()
{

    return m_inputpCond.HasValue();

}

void CLcExecuteNeutralize::SetInputpCond( CLcCondsPtr value )
{

    m_inputpCond.SetValue( value );

}

double CLcExecuteNeutralize::GetOutputTargOffset()
{

    return m_outputTargOffset.GetValue();

}

bool CLcExecuteNeutralize::HasValueOutputTargOffset()
{

    return m_outputTargOffset.HasValue();

}

void CLcExecuteNeutralize::SetOutputTargOffset( double value )
{

    m_outputTargOffset.SetValue( value );

}

void CLcExecuteNeutralize::SetOutputTargOffsetNoValue()
{

    m_outputTargOffset.SetNoValue();

}

CLcExecuteIncrement::CLcExecuteIncrement(
            CHcsmCollection* pRootCollection
            ):
    CHcsmConcurrent(
            pRootCollection,
            "LcExecuteIncrement",
            false,
            22
            )
,
    m_inputpI( "pI" ),
    m_inputpCond( "pCond" ),
    m_outputTargOffset( "TargOffset" ),
    m_outputTargLookAhead( "TargLookAhead" )
{


}

CLcExecuteIncrement::CLcExecuteIncrement( const CLcExecuteIncrement& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_inputpCond( objToCopy.m_inputpCond.GetName() ),
    m_outputTargOffset( objToCopy.m_outputTargOffset.GetName() ),
    m_outputTargLookAhead( objToCopy.m_outputTargLookAhead.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CLcExecuteIncrement& CLcExecuteIncrement::operator=(
            const CLcExecuteIncrement& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CLcExecuteIncrement::~CLcExecuteIncrement()
{

    // call the deletion function
    Deletion();

}

void CLcExecuteIncrement::PostActivity()
{

	UserPostActivity();

}

bool CLcExecuteIncrement::ExecutePredicate( int functionId )
{

    if ( functionId == 11 ) {
        
        return ExecuteLcIncrementLcSteadyPredicate();
        
    }
    else if ( functionId == 14 ) {
        
        return ExecuteLcIncrementLcAbortPredicate();
        
    }
    else {
        
        // unknown function id
        return false;
        
    }

}

bool CLcExecuteIncrement::ExecuteLcIncrementLcSteadyPredicate()
{

	return LcIncrementSteadyPredicate();

}
bool CLcExecuteIncrement::ExecuteLcIncrementLcAbortPredicate()
{

	return LcIncrementLcAbortPredicate();

}

CAdoInfoPtr CLcExecuteIncrement::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CLcExecuteIncrement::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CLcExecuteIncrement::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

CLcCondsPtr CLcExecuteIncrement::GetInputpCond()
{

    return m_inputpCond.GetValue();

}

bool CLcExecuteIncrement::HasValueInputpCond()
{

    return m_inputpCond.HasValue();

}

void CLcExecuteIncrement::SetInputpCond( CLcCondsPtr value )
{

    m_inputpCond.SetValue( value );

}

double CLcExecuteIncrement::GetOutputTargOffset()
{

    return m_outputTargOffset.GetValue();

}

bool CLcExecuteIncrement::HasValueOutputTargOffset()
{

    return m_outputTargOffset.HasValue();

}

void CLcExecuteIncrement::SetOutputTargOffset( double value )
{

    m_outputTargOffset.SetValue( value );

}

void CLcExecuteIncrement::SetOutputTargOffsetNoValue()
{

    m_outputTargOffset.SetNoValue();

}

double CLcExecuteIncrement::GetOutputTargLookAhead()
{

    return m_outputTargLookAhead.GetValue();

}

bool CLcExecuteIncrement::HasValueOutputTargLookAhead()
{

    return m_outputTargLookAhead.HasValue();

}

void CLcExecuteIncrement::SetOutputTargLookAhead( double value )
{

    m_outputTargLookAhead.SetValue( value );

}

void CLcExecuteIncrement::SetOutputTargLookAheadNoValue()
{

    m_outputTargLookAhead.SetNoValue();

}

CLcExecuteSteady::CLcExecuteSteady(
            CHcsmCollection* pRootCollection
            ):
    CHcsmConcurrent(
            pRootCollection,
            "LcExecuteSteady",
            false,
            23
            )
,
    m_inputpI( "pI" ),
    m_inputpCond( "pCond" ),
    m_outputTargOffset( "TargOffset" ),
    m_outputTargLookAhead( "TargLookAhead" )
{


}

CLcExecuteSteady::CLcExecuteSteady( const CLcExecuteSteady& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_inputpCond( objToCopy.m_inputpCond.GetName() ),
    m_outputTargOffset( objToCopy.m_outputTargOffset.GetName() ),
    m_outputTargLookAhead( objToCopy.m_outputTargLookAhead.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CLcExecuteSteady& CLcExecuteSteady::operator=(
            const CLcExecuteSteady& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CLcExecuteSteady::~CLcExecuteSteady()
{

    // call the deletion function
    Deletion();

}

void CLcExecuteSteady::PostActivity()
{

	UserPostActivity();

}

bool CLcExecuteSteady::ExecutePredicate( int functionId )
{

    if ( functionId == 12 ) {
        
        return ExecuteLcSteadyLcDecrementPredicate();
        
    }
    else if ( functionId == 15 ) {
        
        return ExecuteLcSteadyLcAbortPredicate();
        
    }
    else {
        
        // unknown function id
        return false;
        
    }

}

bool CLcExecuteSteady::ExecuteLcSteadyLcDecrementPredicate()
{

	return LcSteadyDecrementPredicate();

}
bool CLcExecuteSteady::ExecuteLcSteadyLcAbortPredicate()
{

	return LcSteadyLcAbortPredicate();

}

CAdoInfoPtr CLcExecuteSteady::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CLcExecuteSteady::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CLcExecuteSteady::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

CLcCondsPtr CLcExecuteSteady::GetInputpCond()
{

    return m_inputpCond.GetValue();

}

bool CLcExecuteSteady::HasValueInputpCond()
{

    return m_inputpCond.HasValue();

}

void CLcExecuteSteady::SetInputpCond( CLcCondsPtr value )
{

    m_inputpCond.SetValue( value );

}

double CLcExecuteSteady::GetOutputTargOffset()
{

    return m_outputTargOffset.GetValue();

}

bool CLcExecuteSteady::HasValueOutputTargOffset()
{

    return m_outputTargOffset.HasValue();

}

void CLcExecuteSteady::SetOutputTargOffset( double value )
{

    m_outputTargOffset.SetValue( value );

}

void CLcExecuteSteady::SetOutputTargOffsetNoValue()
{

    m_outputTargOffset.SetNoValue();

}

double CLcExecuteSteady::GetOutputTargLookAhead()
{

    return m_outputTargLookAhead.GetValue();

}

bool CLcExecuteSteady::HasValueOutputTargLookAhead()
{

    return m_outputTargLookAhead.HasValue();

}

void CLcExecuteSteady::SetOutputTargLookAhead( double value )
{

    m_outputTargLookAhead.SetValue( value );

}

void CLcExecuteSteady::SetOutputTargLookAheadNoValue()
{

    m_outputTargLookAhead.SetNoValue();

}

CLcExecuteDecrement::CLcExecuteDecrement(
            CHcsmCollection* pRootCollection
            ):
    CHcsmConcurrent(
            pRootCollection,
            "LcExecuteDecrement",
            false,
            24
            )
,
    m_inputpI( "pI" ),
    m_inputpCond( "pCond" ),
    m_outputTargOffset( "TargOffset" ),
    m_outputTargLookAhead( "TargLookAhead" )
{


}

CLcExecuteDecrement::CLcExecuteDecrement( const CLcExecuteDecrement& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_inputpCond( objToCopy.m_inputpCond.GetName() ),
    m_outputTargOffset( objToCopy.m_outputTargOffset.GetName() ),
    m_outputTargLookAhead( objToCopy.m_outputTargLookAhead.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CLcExecuteDecrement& CLcExecuteDecrement::operator=(
            const CLcExecuteDecrement& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CLcExecuteDecrement::~CLcExecuteDecrement()
{

    // call the deletion function
    Deletion();

}

void CLcExecuteDecrement::PostActivity()
{

	UserPostActivity();

}

bool CLcExecuteDecrement::ExecutePredicate( int functionId )
{

    if ( functionId == 13 ) {
        
        return ExecuteLcDecrementLcNeutralizePredicate();
        
    }
    else if ( functionId == 16 ) {
        
        return ExecuteLcDecrementLcAbortPredicate();
        
    }
    else {
        
        // unknown function id
        return false;
        
    }

}

bool CLcExecuteDecrement::ExecuteLcDecrementLcNeutralizePredicate()
{

	return LcDecrementNeutralizePredicate();

}
bool CLcExecuteDecrement::ExecuteLcDecrementLcAbortPredicate()
{

	return LcDecrementLcAbortPredicate();

}

CAdoInfoPtr CLcExecuteDecrement::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CLcExecuteDecrement::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CLcExecuteDecrement::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

CLcCondsPtr CLcExecuteDecrement::GetInputpCond()
{

    return m_inputpCond.GetValue();

}

bool CLcExecuteDecrement::HasValueInputpCond()
{

    return m_inputpCond.HasValue();

}

void CLcExecuteDecrement::SetInputpCond( CLcCondsPtr value )
{

    m_inputpCond.SetValue( value );

}

double CLcExecuteDecrement::GetOutputTargOffset()
{

    return m_outputTargOffset.GetValue();

}

bool CLcExecuteDecrement::HasValueOutputTargOffset()
{

    return m_outputTargOffset.HasValue();

}

void CLcExecuteDecrement::SetOutputTargOffset( double value )
{

    m_outputTargOffset.SetValue( value );

}

void CLcExecuteDecrement::SetOutputTargOffsetNoValue()
{

    m_outputTargOffset.SetNoValue();

}

double CLcExecuteDecrement::GetOutputTargLookAhead()
{

    return m_outputTargLookAhead.GetValue();

}

bool CLcExecuteDecrement::HasValueOutputTargLookAhead()
{

    return m_outputTargLookAhead.HasValue();

}

void CLcExecuteDecrement::SetOutputTargLookAhead( double value )
{

    m_outputTargLookAhead.SetValue( value );

}

void CLcExecuteDecrement::SetOutputTargLookAheadNoValue()
{

    m_outputTargLookAhead.SetNoValue();

}

CNavigateIntrsctn::CNavigateIntrsctn(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CAdoParseBlock( snoBlock ),
            "NavigateIntrsctn",
            false,
            25
            )
,
    m_inputpI( "pI" ),
    m_outputTargAccel( "TargAccel" ),
    m_outputImTargCrdrs( "ImTargCrdrs" ),
    m_outputHasStopSignTarget( "HasStopSignTarget" ),
    m_outputStoppedAtStopSignFrame( "StoppedAtStopSignFrame" )
{


}

CNavigateIntrsctn::CNavigateIntrsctn( const CNavigateIntrsctn& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_outputTargAccel( objToCopy.m_outputTargAccel.GetName() ),
    m_outputImTargCrdrs( objToCopy.m_outputImTargCrdrs.GetName() ),
    m_outputHasStopSignTarget( objToCopy.m_outputHasStopSignTarget.GetName() ),
    m_outputStoppedAtStopSignFrame( objToCopy.m_outputStoppedAtStopSignFrame.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CNavigateIntrsctn& CNavigateIntrsctn::operator=(
            const CNavigateIntrsctn& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CNavigateIntrsctn::~CNavigateIntrsctn()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CNavigateIntrsctn::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	Creation();

}

void CNavigateIntrsctn::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PreActivity();

}

void CNavigateIntrsctn::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CAdoParseBlock* pSnoBlock = dynamic_cast<const CAdoParseBlock*>(pBaseSnoBlock);
	PostActivity();

}

CAdoInfoPtr CNavigateIntrsctn::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CNavigateIntrsctn::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CNavigateIntrsctn::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

double CNavigateIntrsctn::GetOutputTargAccel()
{

    return m_outputTargAccel.GetValue();

}

bool CNavigateIntrsctn::HasValueOutputTargAccel()
{

    return m_outputTargAccel.HasValue();

}

void CNavigateIntrsctn::SetOutputTargAccel( double value )
{

    m_outputTargAccel.SetValue( value );

}

void CNavigateIntrsctn::SetOutputTargAccelNoValue()
{

    m_outputTargAccel.SetNoValue();

}

string CNavigateIntrsctn::GetOutputImTargCrdrs()
{

    return m_outputImTargCrdrs.GetValue();

}

bool CNavigateIntrsctn::HasValueOutputImTargCrdrs()
{

    return m_outputImTargCrdrs.HasValue();

}

void CNavigateIntrsctn::SetOutputImTargCrdrs( string value )
{

    m_outputImTargCrdrs.SetValue( value );

}

void CNavigateIntrsctn::SetOutputImTargCrdrsNoValue()
{

    m_outputImTargCrdrs.SetNoValue();

}

bool CNavigateIntrsctn::GetOutputHasStopSignTarget()
{

    return m_outputHasStopSignTarget.GetValue();

}

bool CNavigateIntrsctn::HasValueOutputHasStopSignTarget()
{

    return m_outputHasStopSignTarget.HasValue();

}

void CNavigateIntrsctn::SetOutputHasStopSignTarget( bool value )
{

    m_outputHasStopSignTarget.SetValue( value );

}

void CNavigateIntrsctn::SetOutputHasStopSignTargetNoValue()
{

    m_outputHasStopSignTarget.SetNoValue();

}

int CNavigateIntrsctn::GetOutputStoppedAtStopSignFrame()
{

    return m_outputStoppedAtStopSignFrame.GetValue();

}

bool CNavigateIntrsctn::HasValueOutputStoppedAtStopSignFrame()
{

    return m_outputStoppedAtStopSignFrame.HasValue();

}

void CNavigateIntrsctn::SetOutputStoppedAtStopSignFrame( int value )
{

    m_outputStoppedAtStopSignFrame.SetValue( value );

}

void CNavigateIntrsctn::SetOutputStoppedAtStopSignFrameNoValue()
{

    m_outputStoppedAtStopSignFrame.SetNoValue();

}

CMerge::CMerge(
            CHcsmCollection* pRootCollection
            ):
    CHcsmConcurrent(
            pRootCollection,
            "Merge",
            false,
            26
            )
,
    m_inputpI( "pI" ),
    m_outputTargAccel( "TargAccel" )
{


}

CMerge::CMerge( const CMerge& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_inputpI( objToCopy.m_inputpI.GetName() ),
    m_outputTargAccel( objToCopy.m_outputTargAccel.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CMerge& CMerge::operator=(
            const CMerge& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CMerge::~CMerge()
{

    // call the deletion function
    Deletion();

}

void CMerge::Creation()
{

	UserCreation();

}

void CMerge::PreActivity()
{

	UserPreActivity();

}

void CMerge::PostActivity()
{

	UserPostActivity();

}

CAdoInfoPtr CMerge::GetInputpI()
{

    return m_inputpI.GetValue();

}

bool CMerge::HasValueInputpI()
{

    return m_inputpI.HasValue();

}

void CMerge::SetInputpI( CAdoInfoPtr value )
{

    m_inputpI.SetValue( value );

}

double CMerge::GetOutputTargAccel()
{

    return m_outputTargAccel.GetValue();

}

bool CMerge::HasValueOutputTargAccel()
{

    return m_outputTargAccel.HasValue();

}

void CMerge::SetOutputTargAccel( double value )
{

    m_outputTargAccel.SetValue( value );

}

void CMerge::SetOutputTargAccelNoValue()
{

    m_outputTargAccel.SetNoValue();

}

CEnvironmentController::CEnvironmentController(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CEnvControlParseBlock( snoBlock ),
            "EnvironmentController",
            true,
            27
            )

{


}

CEnvironmentController::CEnvironmentController( const CEnvironmentController& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            )
{

    // call the assignment operator
    *this = objToCopy;

}

CEnvironmentController& CEnvironmentController::operator=(
            const CEnvironmentController& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CEnvironmentController::~CEnvironmentController()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CEnvironmentController::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CEnvControlParseBlock* pSnoBlock = dynamic_cast<const CEnvControlParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CEnvironmentController::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CEnvControlParseBlock* pSnoBlock = dynamic_cast<const CEnvControlParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CEnvironmentController::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CEnvControlParseBlock* pSnoBlock = dynamic_cast<const CEnvControlParseBlock*>(pBaseSnoBlock);
	UserPreActivity( pSnoBlock );

}

void CEnvironmentController::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CEnvControlParseBlock* pSnoBlock = dynamic_cast<const CEnvControlParseBlock*>(pBaseSnoBlock);
	UserPostActivity( pSnoBlock );

}

CEnviroInfo::CEnviroInfo(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CEnviroInfoParseBlock( snoBlock ),
            "EnviroInfo",
            true,
            28
            )

{


}

CEnviroInfo::CEnviroInfo( const CEnviroInfo& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            )
{

    // call the assignment operator
    *this = objToCopy;

}

CEnviroInfo& CEnviroInfo::operator=(
            const CEnviroInfo& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CEnviroInfo::~CEnviroInfo()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CEnviroInfo::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CEnviroInfoParseBlock* pSnoBlock = dynamic_cast<const CEnviroInfoParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CEnviroInfo::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CEnviroInfoParseBlock* pSnoBlock = dynamic_cast<const CEnviroInfoParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CEnviroInfo::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CEnviroInfoParseBlock* pSnoBlock = dynamic_cast<const CEnviroInfoParseBlock*>(pBaseSnoBlock);
	UserPreActivity( pSnoBlock );

}

void CEnviroInfo::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CEnviroInfoParseBlock* pSnoBlock = dynamic_cast<const CEnviroInfoParseBlock*>(pBaseSnoBlock);
	UserPostActivity( pSnoBlock );

}

CIntersectionManager::CIntersectionManager(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CIntersectionMngrParseBlock( snoBlock ),
            "IntersectionManager",
            true,
            29
            )

{


}

CIntersectionManager::CIntersectionManager( const CIntersectionManager& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            )
{

    // call the assignment operator
    *this = objToCopy;

}

CIntersectionManager& CIntersectionManager::operator=(
            const CIntersectionManager& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CIntersectionManager::~CIntersectionManager()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CIntersectionManager::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CIntersectionMngrParseBlock* pSnoBlock = dynamic_cast<const CIntersectionMngrParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CIntersectionManager::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CIntersectionMngrParseBlock* pSnoBlock = dynamic_cast<const CIntersectionMngrParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CIntersectionManager::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CIntersectionMngrParseBlock* pSnoBlock = dynamic_cast<const CIntersectionMngrParseBlock*>(pBaseSnoBlock);
	UserPreActivity( pSnoBlock );

}

void CIntersectionManager::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CIntersectionMngrParseBlock* pSnoBlock = dynamic_cast<const CIntersectionMngrParseBlock*>(pBaseSnoBlock);
	UserPostActivity( pSnoBlock );

}

COwnVehicleMirror::COwnVehicleMirror(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new COwnVehicleMirrorParseBlock( snoBlock ),
            "OwnVehicleMirror",
            true,
            30
            )

{


}

COwnVehicleMirror::COwnVehicleMirror( const COwnVehicleMirror& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            )
{

    // call the assignment operator
    *this = objToCopy;

}

COwnVehicleMirror& COwnVehicleMirror::operator=(
            const COwnVehicleMirror& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

COwnVehicleMirror::~COwnVehicleMirror()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void COwnVehicleMirror::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const COwnVehicleMirrorParseBlock* pSnoBlock = dynamic_cast<const COwnVehicleMirrorParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void COwnVehicleMirror::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const COwnVehicleMirrorParseBlock* pSnoBlock = dynamic_cast<const COwnVehicleMirrorParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void COwnVehicleMirror::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const COwnVehicleMirrorParseBlock* pSnoBlock = dynamic_cast<const COwnVehicleMirrorParseBlock*>(pBaseSnoBlock);
	UserPreActivity( pSnoBlock );

}

void COwnVehicleMirror::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const COwnVehicleMirrorParseBlock* pSnoBlock = dynamic_cast<const COwnVehicleMirrorParseBlock*>(pBaseSnoBlock);
	UserPostActivity( pSnoBlock );

}

CStaticObjManager::CStaticObjManager(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CSobjMngrParseBlock( snoBlock ),
            "StaticObjManager",
            true,
            31
            )
,
    m_dialSetOption1( pRootCollection, "SetOption1" ),
    m_dialSetOption2( pRootCollection, "SetOption2" ),
    m_dialAudioState( pRootCollection, "AudioState" ),
    m_dialVisualState( pRootCollection, "VisualState" ),
    m_dialAnimationState( pRootCollection, "AnimationState" )
{


}

CStaticObjManager::CStaticObjManager( const CStaticObjManager& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_dialSetOption1( objToCopy.m_pRootCollection, objToCopy.m_dialSetOption1.GetName() ),
    m_dialSetOption2( objToCopy.m_pRootCollection, objToCopy.m_dialSetOption2.GetName() ),
    m_dialAudioState( objToCopy.m_pRootCollection, objToCopy.m_dialAudioState.GetName() ),
    m_dialVisualState( objToCopy.m_pRootCollection, objToCopy.m_dialVisualState.GetName() ),
    m_dialAnimationState( objToCopy.m_pRootCollection, objToCopy.m_dialAnimationState.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CStaticObjManager& CStaticObjManager::operator=(
            const CStaticObjManager& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CStaticObjManager::~CStaticObjManager()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CStaticObjManager::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CSobjMngrParseBlock* pSnoBlock = dynamic_cast<const CSobjMngrParseBlock*>(pBaseSnoBlock);
	Creation( pSnoBlock );

}

void CStaticObjManager::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CSobjMngrParseBlock* pSnoBlock = dynamic_cast<const CSobjMngrParseBlock*>(pBaseSnoBlock);
	Deletion( pSnoBlock );

}

void CStaticObjManager::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CSobjMngrParseBlock* pSnoBlock = dynamic_cast<const CSobjMngrParseBlock*>(pBaseSnoBlock);
	PostActivity( pSnoBlock );

}

string CStaticObjManager::GetDialSetOption1()
{

    return m_dialSetOption1.GetValue();

}

void CStaticObjManager::SetDialSetOption1( string value )
{

    m_dialSetOption1.SetValue( value );

}

void CStaticObjManager::SetDialSetOption1NoValue()
{

    m_dialSetOption1.SetNoValue();

}

string CStaticObjManager::GetDialSetOption2()
{

    return m_dialSetOption2.GetValue();

}

void CStaticObjManager::SetDialSetOption2( string value )
{

    m_dialSetOption2.SetValue( value );

}

void CStaticObjManager::SetDialSetOption2NoValue()
{

    m_dialSetOption2.SetNoValue();

}

string CStaticObjManager::GetDialAudioState()
{

    return m_dialAudioState.GetValue();

}

void CStaticObjManager::SetDialAudioState( string value )
{

    m_dialAudioState.SetValue( value );

}

void CStaticObjManager::SetDialAudioStateNoValue()
{

    m_dialAudioState.SetNoValue();

}

string CStaticObjManager::GetDialVisualState()
{

    return m_dialVisualState.GetValue();

}

void CStaticObjManager::SetDialVisualState( string value )
{

    m_dialVisualState.SetValue( value );

}

void CStaticObjManager::SetDialVisualStateNoValue()
{

    m_dialVisualState.SetNoValue();

}

string CStaticObjManager::GetDialAnimationState()
{

    return m_dialAnimationState.GetValue();

}

void CStaticObjManager::SetDialAnimationState( string value )
{

    m_dialAnimationState.SetValue( value );

}

void CStaticObjManager::SetDialAnimationStateNoValue()
{

    m_dialAnimationState.SetNoValue();

}

bool CStaticObjManager::SetDialByName( const string& dialName, const int& value )
{

    
    return false;

}

bool CStaticObjManager::SetDialByName( const string& dialName, const double& value )
{

    
    return false;

}

bool CStaticObjManager::SetDialByName( const string& dialName, const string& value )
{

    if ( dialName == m_dialSetOption1.GetName() ) {
        
        m_dialSetOption1.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialSetOption2.GetName() ) {
        
        m_dialSetOption2.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialAudioState.GetName() ) {
        
        m_dialAudioState.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialVisualState.GetName() ) {
        
        m_dialVisualState.SetValue( value );
        return true;
        
    }
    if ( dialName == m_dialAnimationState.GetName() ) {
        
        m_dialAnimationState.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CStaticObjManager::SetDialByName( const string& dialName, const float& value )
{

    
    return false;

}

bool CStaticObjManager::SetDialByName( const string& dialName, const bool& value )
{

    
    return false;

}

bool CStaticObjManager::SetDialByNameStr( const string& dialName, const string& value )
{

    if ( dialName == m_dialSetOption1.GetName() ) {
        
        m_dialSetOption1.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialSetOption2.GetName() ) {
        
        m_dialSetOption2.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialAudioState.GetName() ) {
        
        m_dialAudioState.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialVisualState.GetName() ) {
        
        m_dialVisualState.SetValueStr( value );
        return true;
        
    }
    if ( dialName == m_dialAnimationState.GetName() ) {
        
        m_dialAnimationState.SetValueStr( value );
        return true;
        
    }
    
    return false;

}

bool CStaticObjManager::IsDialActiveByNameStr( const string& dialName )
{

    if ( dialName == m_dialSetOption1.GetName() ) {
        
        return m_dialSetOption1.HasValue();
        
    }
    if ( dialName == m_dialSetOption2.GetName() ) {
        
        return m_dialSetOption2.HasValue();
        
    }
    if ( dialName == m_dialAudioState.GetName() ) {
        
        return m_dialAudioState.HasValue();
        
    }
    if ( dialName == m_dialVisualState.GetName() ) {
        
        return m_dialVisualState.HasValue();
        
    }
    if ( dialName == m_dialAnimationState.GetName() ) {
        
        return m_dialAnimationState.HasValue();
        
    }
    
    return false;

}

bool CStaticObjManager::ResetDialByName( const string& dialName )
{

    if ( dialName == m_dialSetOption1.GetName() ) {
        
        m_dialSetOption1.Reset();
        return true;
        
    }
    if ( dialName == m_dialSetOption2.GetName() ) {
        
        m_dialSetOption2.Reset();
        return true;
        
    }
    if ( dialName == m_dialAudioState.GetName() ) {
        
        m_dialAudioState.Reset();
        return true;
        
    }
    if ( dialName == m_dialVisualState.GetName() ) {
        
        m_dialVisualState.Reset();
        return true;
        
    }
    if ( dialName == m_dialAnimationState.GetName() ) {
        
        m_dialAnimationState.Reset();
        return true;
        
    }
    
    return false;

}

CTrafficLightManager::CTrafficLightManager(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CTrafLghtMngrParseBlock( snoBlock ),
            "TrafficLightManager",
            true,
            32
            )
,
    m_dialTrafficLight( pRootCollection, "TrafficLight" )
{


}

CTrafficLightManager::CTrafficLightManager( const CTrafficLightManager& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_dialTrafficLight( objToCopy.m_pRootCollection, objToCopy.m_dialTrafficLight.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CTrafficLightManager& CTrafficLightManager::operator=(
            const CTrafficLightManager& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CTrafficLightManager::~CTrafficLightManager()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CTrafficLightManager::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafLghtMngrParseBlock* pSnoBlock = dynamic_cast<const CTrafLghtMngrParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CTrafficLightManager::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafLghtMngrParseBlock* pSnoBlock = dynamic_cast<const CTrafLghtMngrParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CTrafficLightManager::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafLghtMngrParseBlock* pSnoBlock = dynamic_cast<const CTrafLghtMngrParseBlock*>(pBaseSnoBlock);
	UserPreActivity( pSnoBlock );

}

void CTrafficLightManager::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafLghtMngrParseBlock* pSnoBlock = dynamic_cast<const CTrafLghtMngrParseBlock*>(pBaseSnoBlock);
	UserPostActivity( pSnoBlock );

}

string CTrafficLightManager::GetDialTrafficLight()
{

    return m_dialTrafficLight.GetValue();

}

void CTrafficLightManager::SetDialTrafficLight( string value )
{

    m_dialTrafficLight.SetValue( value );

}

void CTrafficLightManager::SetDialTrafficLightNoValue()
{

    m_dialTrafficLight.SetNoValue();

}

bool CTrafficLightManager::SetDialByName( const string& dialName, const int& value )
{

    
    return false;

}

bool CTrafficLightManager::SetDialByName( const string& dialName, const double& value )
{

    
    return false;

}

bool CTrafficLightManager::SetDialByName( const string& dialName, const string& value )
{

    if ( dialName == m_dialTrafficLight.GetName() ) {
        
        m_dialTrafficLight.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CTrafficLightManager::SetDialByName( const string& dialName, const float& value )
{

    
    return false;

}

bool CTrafficLightManager::SetDialByName( const string& dialName, const bool& value )
{

    
    return false;

}

bool CTrafficLightManager::SetDialByNameStr( const string& dialName, const string& value )
{

    if ( dialName == m_dialTrafficLight.GetName() ) {
        
        m_dialTrafficLight.SetValueStr( value );
        return true;
        
    }
    
    return false;

}

bool CTrafficLightManager::IsDialActiveByNameStr( const string& dialName )
{

    if ( dialName == m_dialTrafficLight.GetName() ) {
        
        return m_dialTrafficLight.HasValue();
        
    }
    
    return false;

}

bool CTrafficLightManager::ResetDialByName( const string& dialName )
{

    if ( dialName == m_dialTrafficLight.GetName() ) {
        
        m_dialTrafficLight.Reset();
        return true;
        
    }
    
    return false;

}

CTrafficManager::CTrafficManager(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CTrafMngrParseBlock( snoBlock ),
            "TrafficManager",
            true,
            33
            )
,
    m_buttonMakeTraffic( pRootCollection, "MakeTraffic" ),
    m_dialInputSet( pRootCollection, "InputSet" )
{


}

CTrafficManager::CTrafficManager( const CTrafficManager& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_buttonMakeTraffic( objToCopy.m_pRootCollection, objToCopy.m_buttonMakeTraffic.GetName() ),
    m_dialInputSet( objToCopy.m_pRootCollection, objToCopy.m_dialInputSet.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CTrafficManager& CTrafficManager::operator=(
            const CTrafficManager& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CTrafficManager::~CTrafficManager()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CTrafficManager::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafMngrParseBlock* pSnoBlock = dynamic_cast<const CTrafMngrParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CTrafficManager::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafMngrParseBlock* pSnoBlock = dynamic_cast<const CTrafMngrParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CTrafficManager::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafMngrParseBlock* pSnoBlock = dynamic_cast<const CTrafMngrParseBlock*>(pBaseSnoBlock);
	UserActivity( pSnoBlock );

}

void CTrafficManager::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafMngrParseBlock* pSnoBlock = dynamic_cast<const CTrafMngrParseBlock*>(pBaseSnoBlock);
	pSnoBlock;

}

bool CTrafficManager::GetButtonMakeTraffic()
{

    return m_buttonMakeTraffic.IsButtonPressed();

}

bool CTrafficManager::SetButtonByName( const string& buttonName )
{

    if ( buttonName == m_buttonMakeTraffic.GetName() ) {
        
        m_buttonMakeTraffic.PressButton();
        return true;
        
    }
    
    return false;

}

string CTrafficManager::GetDialInputSet()
{

    return m_dialInputSet.GetValue();

}

void CTrafficManager::SetDialInputSet( string value )
{

    m_dialInputSet.SetValue( value );

}

void CTrafficManager::SetDialInputSetNoValue()
{

    m_dialInputSet.SetNoValue();

}

bool CTrafficManager::SetDialByName( const string& dialName, const int& value )
{

    
    return false;

}

bool CTrafficManager::SetDialByName( const string& dialName, const double& value )
{

    
    return false;

}

bool CTrafficManager::SetDialByName( const string& dialName, const string& value )
{

    if ( dialName == m_dialInputSet.GetName() ) {
        
        m_dialInputSet.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CTrafficManager::SetDialByName( const string& dialName, const float& value )
{

    
    return false;

}

bool CTrafficManager::SetDialByName( const string& dialName, const bool& value )
{

    
    return false;

}

bool CTrafficManager::SetDialByNameStr( const string& dialName, const string& value )
{

    if ( dialName == m_dialInputSet.GetName() ) {
        
        m_dialInputSet.SetValueStr( value );
        return true;
        
    }
    
    return false;

}

bool CTrafficManager::IsDialActiveByNameStr( const string& dialName )
{

    if ( dialName == m_dialInputSet.GetName() ) {
        
        return m_dialInputSet.HasValue();
        
    }
    
    return false;

}

bool CTrafficManager::ResetDialByName( const string& dialName )
{

    if ( dialName == m_dialInputSet.GetName() ) {
        
        m_dialInputSet.Reset();
        return true;
        
    }
    
    return false;

}

CTrafficSource::CTrafficSource(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CTrafSrcParseBlock( snoBlock ),
            "TrafficSource",
            true,
            34
            )
,
    m_buttonMakeTraffic( pRootCollection, "MakeTraffic" ),
    m_dialStartStop( pRootCollection, "StartStop" )
{


}

CTrafficSource::CTrafficSource( const CTrafficSource& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_buttonMakeTraffic( objToCopy.m_pRootCollection, objToCopy.m_buttonMakeTraffic.GetName() ),
    m_dialStartStop( objToCopy.m_pRootCollection, objToCopy.m_dialStartStop.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CTrafficSource& CTrafficSource::operator=(
            const CTrafficSource& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CTrafficSource::~CTrafficSource()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CTrafficSource::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafSrcParseBlock* pSnoBlock = dynamic_cast<const CTrafSrcParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CTrafficSource::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafSrcParseBlock* pSnoBlock = dynamic_cast<const CTrafSrcParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CTrafficSource::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafSrcParseBlock* pSnoBlock = dynamic_cast<const CTrafSrcParseBlock*>(pBaseSnoBlock);
	UserActivity( pSnoBlock );

}

void CTrafficSource::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafSrcParseBlock* pSnoBlock = dynamic_cast<const CTrafSrcParseBlock*>(pBaseSnoBlock);
;

}

bool CTrafficSource::GetButtonMakeTraffic()
{

    return m_buttonMakeTraffic.IsButtonPressed();

}

bool CTrafficSource::SetButtonByName( const string& buttonName )
{

    if ( buttonName == m_buttonMakeTraffic.GetName() ) {
        
        m_buttonMakeTraffic.PressButton();
        return true;
        
    }
    
    return false;

}

bool CTrafficSource::GetDialStartStop()
{

    return m_dialStartStop.GetValue();

}

void CTrafficSource::SetDialStartStop( bool value )
{

    m_dialStartStop.SetValue( value );

}

void CTrafficSource::SetDialStartStopNoValue()
{

    m_dialStartStop.SetNoValue();

}

bool CTrafficSource::SetDialByName( const string& dialName, const int& value )
{

    
    return false;

}

bool CTrafficSource::SetDialByName( const string& dialName, const double& value )
{

    
    return false;

}

bool CTrafficSource::SetDialByName( const string& dialName, const string& value )
{

    
    return false;

}

bool CTrafficSource::SetDialByName( const string& dialName, const float& value )
{

    
    return false;

}

bool CTrafficSource::SetDialByName( const string& dialName, const bool& value )
{

    if ( dialName == m_dialStartStop.GetName() ) {
        
        m_dialStartStop.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CTrafficSource::SetDialByNameStr( const string& dialName, const string& value )
{

    if ( dialName == m_dialStartStop.GetName() ) {
        
        m_dialStartStop.SetValueStr( value );
        return true;
        
    }
    
    return false;

}

bool CTrafficSource::IsDialActiveByNameStr( const string& dialName )
{

    if ( dialName == m_dialStartStop.GetName() ) {
        
        return m_dialStartStop.HasValue();
        
    }
    
    return false;

}

bool CTrafficSource::ResetDialByName( const string& dialName )
{

    if ( dialName == m_dialStartStop.GetName() ) {
        
        m_dialStartStop.Reset();
        return true;
        
    }
    
    return false;

}

CVehFail::CVehFail(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CVehFailParseBlock( snoBlock ),
            "VehFail",
            true,
            35
            )
,
    m_dialFailure( pRootCollection, "Failure" )
{


}

CVehFail::CVehFail( const CVehFail& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_dialFailure( objToCopy.m_pRootCollection, objToCopy.m_dialFailure.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CVehFail& CVehFail::operator=(
            const CVehFail& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CVehFail::~CVehFail()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CVehFail::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CVehFailParseBlock* pSnoBlock = dynamic_cast<const CVehFailParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CVehFail::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CVehFailParseBlock* pSnoBlock = dynamic_cast<const CVehFailParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CVehFail::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CVehFailParseBlock* pSnoBlock = dynamic_cast<const CVehFailParseBlock*>(pBaseSnoBlock);
	UserPreActivity( pSnoBlock );

}

void CVehFail::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CVehFailParseBlock* pSnoBlock = dynamic_cast<const CVehFailParseBlock*>(pBaseSnoBlock);
	UserPostActivity( pSnoBlock );

}

string CVehFail::GetDialFailure()
{

    return m_dialFailure.GetValue();

}

void CVehFail::SetDialFailure( string value )
{

    m_dialFailure.SetValue( value );

}

void CVehFail::SetDialFailureNoValue()
{

    m_dialFailure.SetNoValue();

}

bool CVehFail::SetDialByName( const string& dialName, const int& value )
{

    
    return false;

}

bool CVehFail::SetDialByName( const string& dialName, const double& value )
{

    
    return false;

}

bool CVehFail::SetDialByName( const string& dialName, const string& value )
{

    if ( dialName == m_dialFailure.GetName() ) {
        
        m_dialFailure.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CVehFail::SetDialByName( const string& dialName, const float& value )
{

    
    return false;

}

bool CVehFail::SetDialByName( const string& dialName, const bool& value )
{

    
    return false;

}

bool CVehFail::SetDialByNameStr( const string& dialName, const string& value )
{

    if ( dialName == m_dialFailure.GetName() ) {
        
        m_dialFailure.SetValueStr( value );
        return true;
        
    }
    
    return false;

}

bool CVehFail::IsDialActiveByNameStr( const string& dialName )
{

    if ( dialName == m_dialFailure.GetName() ) {
        
        return m_dialFailure.HasValue();
        
    }
    
    return false;

}

bool CVehFail::ResetDialByName( const string& dialName )
{

    if ( dialName == m_dialFailure.GetName() ) {
        
        m_dialFailure.Reset();
        return true;
        
    }
    
    return false;

}

CDriverMirror::CDriverMirror(
            CHcsmCollection* pRootCollection
            ):
    CHcsmConcurrent(
            pRootCollection,
            "DriverMirror",
            true,
            36
            )
,
    m_dialTargetVelocity( pRootCollection, "TargetVelocity" ),
    m_monitorRoadPos( pRootCollection, "RoadPos" ),
    m_monitorTrailerPos( pRootCollection, "TrailerPos" ),
    m_monitorTargCrdr( pRootCollection, "TargCrdr" ),
    m_monitorStoppedBehindObj( pRootCollection, "StoppedBehindObj" ),
    m_monitorImTargCrdrs( pRootCollection, "ImTargCrdrs" )
{


}

CDriverMirror::CDriverMirror( const CDriverMirror& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_name,
            objToCopy.m_root
            ),
    m_dialTargetVelocity( objToCopy.m_pRootCollection, objToCopy.m_dialTargetVelocity.GetName() ),
    m_monitorRoadPos( objToCopy.m_pRootCollection, objToCopy.m_monitorRoadPos.GetName() ),
    m_monitorTrailerPos( objToCopy.m_pRootCollection, objToCopy.m_monitorTrailerPos.GetName() ),
    m_monitorTargCrdr( objToCopy.m_pRootCollection, objToCopy.m_monitorTargCrdr.GetName() ),
    m_monitorStoppedBehindObj( objToCopy.m_pRootCollection, objToCopy.m_monitorStoppedBehindObj.GetName() ),
    m_monitorImTargCrdrs( objToCopy.m_pRootCollection, objToCopy.m_monitorImTargCrdrs.GetName() )
{

    // call the assignment operator
    *this = objToCopy;

}

CDriverMirror& CDriverMirror::operator=(
            const CDriverMirror& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CDriverMirror::~CDriverMirror()
{

    // call the deletion function
    Deletion();

}

void CDriverMirror::Creation()
{

	UserCreation();

}

void CDriverMirror::Deletion()
{

	UserDeletion();

}

void CDriverMirror::PreActivity()
{

	UserPreActivity();

}

void CDriverMirror::PostActivity()
{

	UserPostActivity();

}

string CDriverMirror::GetDialTargetVelocity()
{

    return m_dialTargetVelocity.GetValue();

}

void CDriverMirror::SetDialTargetVelocity( string value )
{

    m_dialTargetVelocity.SetValue( value );

}

void CDriverMirror::SetDialTargetVelocityNoValue()
{

    m_dialTargetVelocity.SetNoValue();

}

bool CDriverMirror::SetDialByName( const string& dialName, const int& value )
{

    
    return false;

}

bool CDriverMirror::SetDialByName( const string& dialName, const double& value )
{

    
    return false;

}

bool CDriverMirror::SetDialByName( const string& dialName, const string& value )
{

    if ( dialName == m_dialTargetVelocity.GetName() ) {
        
        m_dialTargetVelocity.SetValue( value );
        return true;
        
    }
    
    return false;

}

bool CDriverMirror::SetDialByName( const string& dialName, const float& value )
{

    
    return false;

}

bool CDriverMirror::SetDialByName( const string& dialName, const bool& value )
{

    
    return false;

}

bool CDriverMirror::SetDialByNameStr( const string& dialName, const string& value )
{

    if ( dialName == m_dialTargetVelocity.GetName() ) {
        
        m_dialTargetVelocity.SetValueStr( value );
        return true;
        
    }
    
    return false;

}

bool CDriverMirror::IsDialActiveByNameStr( const string& dialName )
{

    if ( dialName == m_dialTargetVelocity.GetName() ) {
        
        return m_dialTargetVelocity.HasValue();
        
    }
    
    return false;

}

bool CDriverMirror::ResetDialByName( const string& dialName )
{

    if ( dialName == m_dialTargetVelocity.GetName() ) {
        
        m_dialTargetVelocity.Reset();
        return true;
        
    }
    
    return false;

}

CRoadPos CDriverMirror::GetMonitorRoadPos()
{

    return m_monitorRoadPos.GetValue();

}

void CDriverMirror::SetMonitorRoadPos( CRoadPos value )
{

    m_monitorRoadPos.SetValue( value );

}

void CDriverMirror::SetMonitorRoadPosNoValue()
{

    m_monitorRoadPos.SetNoValue();

}

CRoadPos CDriverMirror::GetMonitorTrailerPos()
{

    return m_monitorTrailerPos.GetValue();

}

void CDriverMirror::SetMonitorTrailerPos( CRoadPos value )
{

    m_monitorTrailerPos.SetValue( value );

}

void CDriverMirror::SetMonitorTrailerPosNoValue()
{

    m_monitorTrailerPos.SetNoValue();

}

CCrdr CDriverMirror::GetMonitorTargCrdr()
{

    return m_monitorTargCrdr.GetValue();

}

void CDriverMirror::SetMonitorTargCrdr( CCrdr value )
{

    m_monitorTargCrdr.SetValue( value );

}

void CDriverMirror::SetMonitorTargCrdrNoValue()
{

    m_monitorTargCrdr.SetNoValue();

}

int CDriverMirror::GetMonitorStoppedBehindObj()
{

    return m_monitorStoppedBehindObj.GetValue();

}

void CDriverMirror::SetMonitorStoppedBehindObj( int value )
{

    m_monitorStoppedBehindObj.SetValue( value );

}

void CDriverMirror::SetMonitorStoppedBehindObjNoValue()
{

    m_monitorStoppedBehindObj.SetNoValue();

}

string CDriverMirror::GetMonitorImTargCrdrs()
{

    return m_monitorImTargCrdrs.GetValue();

}

void CDriverMirror::SetMonitorImTargCrdrs( string value )
{

    m_monitorImTargCrdrs.SetValue( value );

}

void CDriverMirror::SetMonitorImTargCrdrsNoValue()
{

    m_monitorImTargCrdrs.SetNoValue();

}

bool CDriverMirror::GetMonitorByName( const string& monitorName, CRoadPos* pValue )
{

    if ( monitorName == m_monitorRoadPos.GetName() ) {
        
        bool retVal = m_monitorRoadPos.HasValue();
        if ( retVal ) {
            *pValue = m_monitorRoadPos.GetValue();
        }
        
        return retVal;
        
    }
    
    if ( monitorName == m_monitorTrailerPos.GetName() ) {
        
        bool retVal = m_monitorTrailerPos.HasValue();
        if ( retVal ) {
            *pValue = m_monitorTrailerPos.GetValue();
        }
        
        return retVal;
        
    }
    
    return false;

}

bool CDriverMirror::GetMonitorByName( const string& monitorName, float* pValue )
{

    return false;

}

bool CDriverMirror::GetMonitorByName( const string& monitorName, CCrdr* pValue )
{

    if ( monitorName == m_monitorTargCrdr.GetName() ) {
        
        bool retVal = m_monitorTargCrdr.HasValue();
        if ( retVal ) {
            *pValue = m_monitorTargCrdr.GetValue();
        }
        
        return retVal;
        
    }
    
    return false;

}

bool CDriverMirror::GetMonitorByName( const string& monitorName, int* pValue )
{

    if ( monitorName == m_monitorStoppedBehindObj.GetName() ) {
        
        bool retVal = m_monitorStoppedBehindObj.HasValue();
        if ( retVal ) {
            *pValue = m_monitorStoppedBehindObj.GetValue();
        }
        
        return retVal;
        
    }
    
    return false;

}

bool CDriverMirror::GetMonitorByName( const string& monitorName, bool* pValue )
{

    return false;

}

bool CDriverMirror::GetMonitorByName( const string& monitorName, string* pValue )
{

    if ( monitorName == m_monitorImTargCrdrs.GetName() ) {
        
        bool retVal = m_monitorImTargCrdrs.HasValue();
        if ( retVal ) {
            *pValue = m_monitorImTargCrdrs.GetValue();
        }
        
        return retVal;
        
    }
    
    return false;

}

CTrafficData::CTrafficData(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CTrafficDataParseBlock( snoBlock ),
            "TrafficData",
            true,
            37
            )

{


}

CTrafficData::CTrafficData( const CTrafficData& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            )
{

    // call the assignment operator
    *this = objToCopy;

}

CTrafficData& CTrafficData::operator=(
            const CTrafficData& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CTrafficData::~CTrafficData()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CTrafficData::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafficDataParseBlock* pSnoBlock = dynamic_cast<const CTrafficDataParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CTrafficData::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafficDataParseBlock* pSnoBlock = dynamic_cast<const CTrafficDataParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CTrafficData::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafficDataParseBlock* pSnoBlock = dynamic_cast<const CTrafficDataParseBlock*>(pBaseSnoBlock);
	UserPreActivity( pSnoBlock );

}

void CTrafficData::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CTrafficDataParseBlock* pSnoBlock = dynamic_cast<const CTrafficDataParseBlock*>(pBaseSnoBlock);
	UserPostActivity( pSnoBlock );

}

CDaqDriver::CDaqDriver(
            CHcsmCollection* pRootCollection,
            const CSnoBlock& snoBlock
            ):
    CHcsmConcurrent(
            pRootCollection,
            new CDaqDriverParseBlock( snoBlock ),
            "DaqDriver",
            true,
            38
            )

{


}

CDaqDriver::CDaqDriver( const CDaqDriver& objToCopy ):
    CHcsmConcurrent(
            objToCopy.m_pRootCollection,
            objToCopy.m_pSnoBlock,
            objToCopy.m_name,
            objToCopy.m_root
            )
{

    // call the assignment operator
    *this = objToCopy;

}

CDaqDriver& CDaqDriver::operator=(
            const CDaqDriver& objToCopy
            )
{

    // check to see if the object passed in is really me
    if ( this != &objToCopy ) {

        // make a deep copy

    }

    return *this;

}

CDaqDriver::~CDaqDriver()
{

    // call the deletion function
    Deletion( m_pSnoBlock );

}

void CDaqDriver::Creation( const CSnoBlock* pBaseSnoBlock )
{

    const CDaqDriverParseBlock* pSnoBlock = dynamic_cast<const CDaqDriverParseBlock*>(pBaseSnoBlock);
	UserCreation( pSnoBlock );

}

void CDaqDriver::Deletion( const CSnoBlock* pBaseSnoBlock )
{

    const CDaqDriverParseBlock* pSnoBlock = dynamic_cast<const CDaqDriverParseBlock*>(pBaseSnoBlock);
	UserDeletion( pSnoBlock );

}

void CDaqDriver::PreActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CDaqDriverParseBlock* pSnoBlock = dynamic_cast<const CDaqDriverParseBlock*>(pBaseSnoBlock);
	UserPreActivity( pSnoBlock );

}

void CDaqDriver::PostActivity( const CSnoBlock* pBaseSnoBlock )
{

    const CDaqDriverParseBlock* pSnoBlock = dynamic_cast<const CDaqDriverParseBlock*>(pBaseSnoBlock);
	UserPostActivity( pSnoBlock );

}

